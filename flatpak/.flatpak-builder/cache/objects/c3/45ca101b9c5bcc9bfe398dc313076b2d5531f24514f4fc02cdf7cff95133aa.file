/* unity-io.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-io.vala, do not modify */

/*
 * Copyright (C) 2010 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Mikkel Kamstrup Erlandsen <mikkel.kamstrup@canonical.com>
 *
 */
/*
 * IMPLEMENTATION NOTE:
 * We want the generatedd C API to be nice and not too Vala-ish. We must
 * anticipate that place daemons consuming libunity will be written in
 * both Vala and C.
 *
 */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _UnityInternalIoReadStreamAsyncData UnityInternalIoReadStreamAsyncData;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _UnityInternalIoOpenFromDirsData UnityInternalIoOpenFromDirsData;
typedef struct _UnityInternalIoOpenFromDataDirsData UnityInternalIoOpenFromDataDirsData;

struct _UnityInternalIoReadStreamAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	GInputStream* input;
	gint io_priority;
	GCancellable* cancellable;
	guint8* data;
	gint data_length1;
	gsize size;
	GMemoryOutputStream* output;
	GMemoryOutputStream* _tmp0_;
	GMemoryOutputStream* _tmp1_;
	GMemoryOutputStream* _tmp2_;
	GMemoryOutputStream* _tmp3_;
	guint8* _tmp4_;
	GMemoryOutputStream* _tmp5_;
	GError * _inner_error_;
};

struct _UnityInternalIoOpenFromDirsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	gchar* filename;
	gchar** dirs;
	gint dirs_length1;
	GFileInputStream* result;
	gchar* path;
	GFile* datafile;
	gchar** dir_collection;
	gint dir_collection_length1;
	gint _dir_collection_size_;
	gint dir_it;
	gchar* _tmp0_;
	gchar* dir;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	GFile* _tmp4_;
	GFileInputStream* _tmp5_;
	GFile* _tmp6_;
	GFileInputStream* _tmp7_;
	GFileInputStream* _tmp8_;
	GError* ee;
	GError* _tmp9_;
	GError* _tmp10_;
	GError* _tmp11_;
	GError * _inner_error_;
};

struct _UnityInternalIoOpenFromDataDirsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	gchar* filename;
	GFileInputStream* result;
	gchar* path;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GFile* f;
	const gchar* _tmp2_;
	GFile* _tmp3_;
	GFileInputStream* _tmp4_;
	GFile* _tmp5_;
	GFileInputStream* _tmp6_;
	GFileInputStream* _tmp7_;
	GError* e;
	GError* _tmp8_;
	GError* _tmp9_;
	GError* _tmp10_;
	gchar** dirs;
	gint _tmp11_;
	gchar** _tmp12_;
	gint dirs_length1;
	gint _dirs_size_;
	GFileInputStream* _tmp13_;
	gchar** _tmp14_;
	gint _tmp14__length1;
	GFileInputStream* _tmp15_;
	GFileInputStream* _tmp16_;
	GError * _inner_error_;
};


extern gchar** unity_internal_io_system_data_dirs;
extern gint unity_internal_io_system_data_dirs_length1;
gchar** unity_internal_io_system_data_dirs = NULL;
gint unity_internal_io_system_data_dirs_length1 = 0;
static gint _unity_internal_io_system_data_dirs_size_ = 0;

static void unity_internal_io_read_stream_async_data_free (gpointer _data);
static void unity_internal_io_read_stream_async_async_ready_wrapper (GObject *source_object,
                                                              GAsyncResult *res,
                                                              void *user_data);
void unity_internal_io_read_stream_async (GInputStream* input,
                                          gint io_priority,
                                          GCancellable* cancellable,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_);
void unity_internal_io_read_stream_finish (GAsyncResult* _res_,
                                           guint8** data,
                                           int* data_length1,
                                           gsize* size,
                                           GError** error);
static gboolean unity_internal_io_read_stream_async_co (UnityInternalIoReadStreamAsyncData* _data_);
static void* _g_realloc_grealloc_func (void* data,
                                gsize size);
static void unity_internal_io_read_stream_async_ready (GObject* source_object,
                                                GAsyncResult* _res_,
                                                gpointer _user_data_);
static void unity_internal_io_open_from_dirs_data_free (gpointer _data);
static void unity_internal_io_open_from_dirs_async_ready_wrapper (GObject *source_object,
                                                           GAsyncResult *res,
                                                           void *user_data);
void unity_internal_io_open_from_dirs (const gchar* filename,
                                       gchar** dirs,
                                       int dirs_length1,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_);
GFileInputStream* unity_internal_io_open_from_dirs_finish (GAsyncResult* _res_,
                                                           GError** error);
static gboolean unity_internal_io_open_from_dirs_co (UnityInternalIoOpenFromDirsData* _data_);
static void unity_internal_io_open_from_dirs_ready (GObject* source_object,
                                             GAsyncResult* _res_,
                                             gpointer _user_data_);
static void unity_internal_io_open_from_data_dirs_data_free (gpointer _data);
static void unity_internal_io_open_from_data_dirs_async_ready_wrapper (GObject *source_object,
                                                                GAsyncResult *res,
                                                                void *user_data);
void unity_internal_io_open_from_data_dirs (const gchar* filename,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_);
GFileInputStream* unity_internal_io_open_from_data_dirs_finish (GAsyncResult* _res_,
                                                                GError** error);
static gboolean unity_internal_io_open_from_data_dirs_co (UnityInternalIoOpenFromDataDirsData* _data_);
static void unity_internal_io_open_from_data_dirs_ready (GObject* source_object,
                                                  GAsyncResult* _res_,
                                                  gpointer _user_data_);
gchar** unity_internal_io_get_system_data_dirs (int* result_length1);
static gchar** _vala_array_dup1 (gchar** self,
                          int length);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void
unity_internal_io_read_stream_async_data_free (gpointer _data)
{
	UnityInternalIoReadStreamAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->input);
	_g_object_unref0 (_data_->cancellable);
	g_slice_free (UnityInternalIoReadStreamAsyncData, _data_);
}


static void
unity_internal_io_read_stream_async_async_ready_wrapper (GObject *source_object,
                                                         GAsyncResult *res,
                                                         void *user_data)
{
	UnityInternalIoReadStreamAsyncData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


void
unity_internal_io_read_stream_async (GInputStream* input,
                                     gint io_priority,
                                     GCancellable* cancellable,
                                     GAsyncReadyCallback _callback_,
                                     gpointer _user_data_)
{
	UnityInternalIoReadStreamAsyncData* _data_;
	GInputStream* _tmp0_;
	GCancellable* _tmp1_;
	_data_ = g_slice_new0 (UnityInternalIoReadStreamAsyncData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, cancellable, unity_internal_io_read_stream_async_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_io_read_stream_async_data_free);
	_tmp0_ = _g_object_ref0 (input);
	_g_object_unref0 (_data_->input);
	_data_->input = _tmp0_;
	_data_->io_priority = io_priority;
	_tmp1_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp1_;
	unity_internal_io_read_stream_async_co (_data_);
}


void
unity_internal_io_read_stream_finish (GAsyncResult* _res_,
                                      guint8** data,
                                      int* data_length1,
                                      gsize* size,
                                      GError** error)
{
	UnityInternalIoReadStreamAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return;
	}
	if (data) {
		*data = _data_->data;
	} else {
		_data_->data = (g_free (_data_->data), NULL);
	}
	if (data_length1) {
		*data_length1 = _data_->data_length1;
	}
	_data_->data = NULL;
	if (size) {
		*size = _data_->size;
	}
}


/**
   * Asynchronously read a stream into memory. This method will close
   * the input stream when done.
   */
static void*
_g_realloc_grealloc_func (void* data,
                          gsize size)
{
	void* result;
	result = g_realloc (data, size);
	return result;
}


static void
unity_internal_io_read_stream_async_ready (GObject* source_object,
                                           GAsyncResult* _res_,
                                           gpointer _user_data_)
{
	UnityInternalIoReadStreamAsyncData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_io_read_stream_async_co (_data_);
}


static gboolean
unity_internal_io_read_stream_async_co (UnityInternalIoReadStreamAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = (GMemoryOutputStream*) g_memory_output_stream_new (NULL, 0, _g_realloc_grealloc_func, NULL);
	_data_->output = _data_->_tmp0_;
	_data_->_tmp1_ = _data_->output;
	_data_->_state_ = 1;
	g_output_stream_splice_async ((GOutputStream*) _data_->_tmp1_, _data_->input, G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE, _data_->io_priority, _data_->cancellable, unity_internal_io_read_stream_async_ready, _data_);
	return FALSE;
	_state_1:
	g_output_stream_splice_finish ((GOutputStream*) _data_->_tmp1_, _data_->_res_, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		if (_data_->_inner_error_->domain == G_IO_ERROR) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->output);
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_object_unref0 (_data_->output);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp2_ = _data_->output;
	g_output_stream_close ((GOutputStream*) _data_->_tmp2_, NULL, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		if (_data_->_inner_error_->domain == G_IO_ERROR) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->output);
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_object_unref0 (_data_->output);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp3_ = _data_->output;
	_data_->_tmp4_ = g_memory_output_stream_steal_data (_data_->_tmp3_);
	_data_->data = (g_free (_data_->data), NULL);
	_data_->data = _data_->_tmp4_;
	_data_->data_length1 = -1;
	_data_->_tmp5_ = _data_->output;
	_data_->size = g_memory_output_stream_get_data_size (_data_->_tmp5_);
	g_input_stream_close_async (_data_->input, G_PRIORITY_LOW, NULL, NULL, NULL);
	_g_object_unref0 (_data_->output);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_io_open_from_dirs_data_free (gpointer _data)
{
	UnityInternalIoOpenFromDirsData* _data_;
	_data_ = _data;
	_g_free0 (_data_->filename);
	_g_object_unref0 (_data_->result);
	g_slice_free (UnityInternalIoOpenFromDirsData, _data_);
}


static void
unity_internal_io_open_from_dirs_async_ready_wrapper (GObject *source_object,
                                                      GAsyncResult *res,
                                                      void *user_data)
{
	UnityInternalIoOpenFromDirsData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_internal_io_open_from_dirs (const gchar* filename,
                                  gchar** dirs,
                                  int dirs_length1,
                                  GAsyncReadyCallback _callback_,
                                  gpointer _user_data_)
{
	UnityInternalIoOpenFromDirsData* _data_;
	gchar* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalIoOpenFromDirsData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_io_open_from_dirs_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_io_open_from_dirs_data_free);
	_tmp0_ = g_strdup (filename);
	_g_free0 (_data_->filename);
	_data_->filename = _tmp0_;
	_data_->dirs = dirs;
	_data_->dirs_length1 = dirs_length1;
	unity_internal_io_open_from_dirs_co (_data_);
}


GFileInputStream*
unity_internal_io_open_from_dirs_finish (GAsyncResult* _res_,
                                         GError** error)
{
	GFileInputStream* result;
	UnityInternalIoOpenFromDirsData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
   * Asynchronously looks for a file with base name 'filename' in all the
   * directories defined in 'dirs' and returns a file input stream for it.
   *
   * If the file can not be found this method returns null.
   */
static void
unity_internal_io_open_from_dirs_ready (GObject* source_object,
                                        GAsyncResult* _res_,
                                        gpointer _user_data_)
{
	UnityInternalIoOpenFromDirsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_io_open_from_dirs_co (_data_);
}


static gpointer
_g_error_copy0 (gpointer self)
{
	return self ? g_error_copy (self) : NULL;
}


static gboolean
unity_internal_io_open_from_dirs_co (UnityInternalIoOpenFromDirsData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->dir_collection_length1 = 0;
		_data_->_dir_collection_size_ = 0;
		_data_->dir_collection = _data_->dirs;
		_data_->dir_collection_length1 = _data_->dirs_length1;
		for (_data_->dir_it = 0; _data_->dir_it < _data_->dirs_length1; _data_->dir_it = _data_->dir_it + 1) {
			_data_->_tmp0_ = g_strdup (_data_->dir_collection[_data_->dir_it]);
			_data_->dir = _data_->_tmp0_;
			{
				_data_->_tmp1_ = _data_->dir;
				_data_->_tmp2_ = g_build_filename (_data_->_tmp1_, _data_->filename, NULL, NULL);
				_g_free0 (_data_->path);
				_data_->path = _data_->_tmp2_;
				_data_->_tmp3_ = _data_->path;
				_data_->_tmp4_ = g_file_new_for_path (_data_->_tmp3_);
				_g_object_unref0 (_data_->datafile);
				_data_->datafile = _data_->_tmp4_;
				{
					_data_->_tmp6_ = _data_->datafile;
					_data_->_state_ = 1;
					g_file_read_async (_data_->_tmp6_, G_PRIORITY_DEFAULT, NULL, unity_internal_io_open_from_dirs_ready, _data_);
					return FALSE;
					_state_1:
					_data_->_tmp7_ = g_file_read_finish (_data_->_tmp6_, _data_->_res_, &_data_->_inner_error_);
					_data_->_tmp5_ = _data_->_tmp7_;
					if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
						goto __catch12_g_error;
					}
					_data_->_tmp8_ = _data_->_tmp5_;
					_data_->_tmp5_ = NULL;
					_data_->result = _data_->_tmp8_;
					_g_object_unref0 (_data_->_tmp5_);
					_g_free0 (_data_->dir);
					_g_object_unref0 (_data_->datafile);
					_g_free0 (_data_->path);
					g_task_return_pointer (_data_->_async_result, _data_, NULL);
					if (_data_->_state_ != 0) {
						while (_data_->_task_complete_ != TRUE) {
							g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
						}
					}
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
				goto __finally12;
				__catch12_g_error:
				{
					_data_->ee = _data_->_inner_error_;
					_data_->_inner_error_ = NULL;
					_data_->_tmp9_ = _data_->ee;
					if (!g_error_matches (_data_->_tmp9_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
						_data_->_tmp10_ = _data_->ee;
						_data_->_tmp11_ = _g_error_copy0 (_data_->_tmp10_);
						_data_->_inner_error_ = _data_->_tmp11_;
						_g_error_free0 (_data_->ee);
						goto __finally12;
					}
					_g_error_free0 (_data_->ee);
				}
				__finally12:
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					g_task_return_error (_data_->_async_result, _data_->_inner_error_);
					_g_free0 (_data_->dir);
					_g_object_unref0 (_data_->datafile);
					_g_free0 (_data_->path);
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
				_g_free0 (_data_->dir);
			}
		}
	}
	_data_->result = NULL;
	_g_object_unref0 (_data_->datafile);
	_g_free0 (_data_->path);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_io_open_from_data_dirs_data_free (gpointer _data)
{
	UnityInternalIoOpenFromDataDirsData* _data_;
	_data_ = _data;
	_g_free0 (_data_->filename);
	_g_object_unref0 (_data_->result);
	g_slice_free (UnityInternalIoOpenFromDataDirsData, _data_);
}


static void
unity_internal_io_open_from_data_dirs_async_ready_wrapper (GObject *source_object,
                                                           GAsyncResult *res,
                                                           void *user_data)
{
	UnityInternalIoOpenFromDataDirsData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_internal_io_open_from_data_dirs (const gchar* filename,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_)
{
	UnityInternalIoOpenFromDataDirsData* _data_;
	gchar* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalIoOpenFromDataDirsData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_io_open_from_data_dirs_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_io_open_from_data_dirs_data_free);
	_tmp0_ = g_strdup (filename);
	_g_free0 (_data_->filename);
	_data_->filename = _tmp0_;
	unity_internal_io_open_from_data_dirs_co (_data_);
}


GFileInputStream*
unity_internal_io_open_from_data_dirs_finish (GAsyncResult* _res_,
                                              GError** error)
{
	GFileInputStream* result;
	UnityInternalIoOpenFromDataDirsData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
   * Like open_from_dirs() but scans first the user data dir and then
   * the system data dirs as defined by the XDG_DATA_DIRS environment variable.
   */
static void
unity_internal_io_open_from_data_dirs_ready (GObject* source_object,
                                             GAsyncResult* _res_,
                                             gpointer _user_data_)
{
	UnityInternalIoOpenFromDataDirsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_io_open_from_data_dirs_co (_data_);
}


static gboolean
unity_internal_io_open_from_data_dirs_co (UnityInternalIoOpenFromDataDirsData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_get_user_data_dir ();
	_data_->_tmp1_ = g_build_filename (_data_->_tmp0_, _data_->filename, NULL, NULL);
	_data_->path = _data_->_tmp1_;
	_data_->_tmp2_ = _data_->path;
	_data_->_tmp3_ = g_file_new_for_path (_data_->_tmp2_);
	_data_->f = _data_->_tmp3_;
	{
		_data_->_tmp5_ = _data_->f;
		_data_->_state_ = 1;
		g_file_read_async (_data_->_tmp5_, G_PRIORITY_DEFAULT, NULL, unity_internal_io_open_from_data_dirs_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp6_ = g_file_read_finish (_data_->_tmp5_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp4_ = _data_->_tmp6_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch13_g_error;
		}
		_data_->_tmp7_ = _data_->_tmp4_;
		_data_->_tmp4_ = NULL;
		_data_->result = _data_->_tmp7_;
		_g_object_unref0 (_data_->_tmp4_);
		_g_object_unref0 (_data_->f);
		_g_free0 (_data_->path);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	goto __finally13;
	__catch13_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp8_ = _data_->e;
		if (!g_error_matches (_data_->_tmp8_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
			_data_->_tmp9_ = _data_->e;
			_data_->_tmp10_ = _g_error_copy0 (_data_->_tmp9_);
			_data_->_inner_error_ = _data_->_tmp10_;
			_g_error_free0 (_data_->e);
			goto __finally13;
		}
		_g_error_free0 (_data_->e);
	}
	__finally13:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->f);
		_g_free0 (_data_->path);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp11_ = 0;
	_data_->_tmp12_ = unity_internal_io_get_system_data_dirs (&_data_->_tmp11_);
	_data_->dirs = _data_->_tmp12_;
	_data_->dirs_length1 = _data_->_tmp11_;
	_data_->_dirs_size_ = _data_->dirs_length1;
	_data_->_tmp14_ = _data_->dirs;
	_data_->_tmp14__length1 = _data_->dirs_length1;
	_data_->_state_ = 2;
	unity_internal_io_open_from_dirs (_data_->filename, _data_->_tmp14_, _data_->_tmp14__length1, unity_internal_io_open_from_data_dirs_ready, _data_);
	return FALSE;
	_state_2:
	_data_->_tmp15_ = unity_internal_io_open_from_dirs_finish (_data_->_res_, &_data_->_inner_error_);
	_data_->_tmp13_ = _data_->_tmp15_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_data_->dirs = (_vala_array_free (_data_->dirs, _data_->dirs_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (_data_->f);
		_g_free0 (_data_->path);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp16_ = _data_->_tmp13_;
	_data_->_tmp13_ = NULL;
	_data_->result = _data_->_tmp16_;
	_g_object_unref0 (_data_->_tmp13_);
	_data_->dirs = (_vala_array_free (_data_->dirs, _data_->dirs_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (_data_->f);
	_g_free0 (_data_->path);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gchar**
_vala_array_dup1 (gchar** self,
                  int length)
{
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


gchar**
unity_internal_io_get_system_data_dirs (int* result_length1)
{
	gchar** result = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar** _tmp8_;
	gint _tmp8__length1;
	gchar** _tmp9_;
	gint _tmp9__length1;
	gchar** _tmp10_;
	gint _tmp10__length1;
	_tmp0_ = unity_internal_io_system_data_dirs;
	_tmp0__length1 = unity_internal_io_system_data_dirs_length1;
	if (_tmp0_ == NULL) {
		gchar* dirs = NULL;
		const gchar* _tmp1_;
		gchar* _tmp2_;
		const gchar* _tmp3_;
		_tmp1_ = g_getenv ("XDG_DATA_DIRS");
		_tmp2_ = g_strdup (_tmp1_);
		dirs = _tmp2_;
		_tmp3_ = dirs;
		if (_tmp3_ != NULL) {
			const gchar* _tmp4_;
			gchar** _tmp5_;
			gchar** _tmp6_;
			_tmp4_ = dirs;
			_tmp6_ = _tmp5_ = g_strsplit (_tmp4_, ":", 0);
			unity_internal_io_system_data_dirs = (_vala_array_free (unity_internal_io_system_data_dirs, unity_internal_io_system_data_dirs_length1, (GDestroyNotify) g_free), NULL);
			unity_internal_io_system_data_dirs = _tmp6_;
			unity_internal_io_system_data_dirs_length1 = _vala_array_length (_tmp5_);
			_unity_internal_io_system_data_dirs_size_ = unity_internal_io_system_data_dirs_length1;
		} else {
			gchar** _tmp7_;
			_tmp7_ = g_new0 (gchar*, 0 + 1);
			unity_internal_io_system_data_dirs = (_vala_array_free (unity_internal_io_system_data_dirs, unity_internal_io_system_data_dirs_length1, (GDestroyNotify) g_free), NULL);
			unity_internal_io_system_data_dirs = _tmp7_;
			unity_internal_io_system_data_dirs_length1 = 0;
			_unity_internal_io_system_data_dirs_size_ = unity_internal_io_system_data_dirs_length1;
		}
		_g_free0 (dirs);
	}
	_tmp8_ = unity_internal_io_system_data_dirs;
	_tmp8__length1 = unity_internal_io_system_data_dirs_length1;
	_tmp9_ = (_tmp8_ != NULL) ? _vala_array_dup1 (_tmp8_, _tmp8__length1) : ((gpointer) _tmp8_);
	_tmp9__length1 = _tmp8__length1;
	_tmp10_ = _tmp9_;
	_tmp10__length1 = _tmp9__length1;
	if (result_length1) {
		*result_length1 = _tmp10__length1;
	}
	result = _tmp10_;
	return result;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint
_vala_array_length (gpointer array)
{
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



