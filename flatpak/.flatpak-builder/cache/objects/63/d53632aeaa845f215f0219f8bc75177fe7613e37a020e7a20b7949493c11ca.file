/* unity-appinfo-manager.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-appinfo-manager.vala, do not modify */

/*
 * Copyright (C) 2010 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Mikkel Kamstrup Erlandsen <mikkel.kamstrup@canonical.com>
 *
 */
/*
 * IMPLEMENTATION NOTE:
 * We want the generatedd C API to be nice and not too Vala-ish. We must
 * anticipate that place daemons consuming libunity will be written in
 * both Vala and C.
 *
 */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include "unity.h"
#include <gio/gio.h>
#include <unity-trace.h>
#include <gio/gdesktopappinfo.h>

typedef struct _UnityStringArrayWrapper UnityStringArrayWrapper;
enum  {
	UNITY_APP_INFO_MANAGER_0_PROPERTY,
	UNITY_APP_INFO_MANAGER_NUM_PROPERTIES
};
static GParamSpec* unity_app_info_manager_properties[UNITY_APP_INFO_MANAGER_NUM_PROPERTIES];
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_key_file_unref0(var) ((var == NULL) ? NULL : (var = (g_key_file_unref (var), NULL)))
typedef struct _UnityAppInfoManagerLookupAsyncData UnityAppInfoManagerLookupAsyncData;
#define _unity_string_array_wrapper_free0(var) ((var == NULL) ? NULL : (var = (unity_string_array_wrapper_free (var), NULL)))
enum  {
	UNITY_APP_INFO_MANAGER_CHANGED_SIGNAL,
	UNITY_APP_INFO_MANAGER_NUM_SIGNALS
};
static guint unity_app_info_manager_signals[UNITY_APP_INFO_MANAGER_NUM_SIGNALS] = {0};

struct _UnityStringArrayWrapper {
	gchar** strings;
	gint strings_length1;
	gint _strings_size_;
};

struct _UnityAppInfoManagerPrivate {
	GHashTable* appinfo_by_id;
	GHashTable* monitors;
	GHashTable* categories_by_id;
	GHashTable* keywords_by_id;
	GHashTable* paths_by_id;
	GList* timeout_handlers;
};

struct _Block1Data {
	int _ref_count_;
	UnityAppInfoManager* self;
	guint timeout_handler;
	GFile* file;
};

struct _UnityAppInfoManagerLookupAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityAppInfoManager* self;
	gchar* id;
	GAppInfo* result;
	GHashTable* _tmp0_;
	gboolean _tmp1_;
	GHashTable* _tmp2_;
	gconstpointer _tmp3_;
	GAppInfo* _tmp4_;
	gsize data_size;
	guint8* data;
	gint data_length1;
	gint _data_size_;
	GFileInputStream* input;
	GFile* f;
	GFile* _tmp5_;
	GFileInputStream* _tmp6_;
	GFile* _tmp7_;
	GFileInputStream* _tmp8_;
	GFileInputStream* _tmp9_;
	GFile* dir;
	GFile* _tmp10_;
	GFile* _tmp11_;
	gchar* dir_uri;
	GFile* _tmp12_;
	gchar* _tmp13_;
	GHashTable* _tmp14_;
	const gchar* _tmp15_;
	gconstpointer _tmp16_;
	GFileMonitor* monitor;
	GFile* _tmp17_;
	GFileMonitor* _tmp18_;
	GFileMonitor* _tmp19_;
	GHashTable* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	GFileMonitor* _tmp23_;
	GFileMonitor* _tmp24_;
	const gchar* _tmp25_;
	GError* ioe;
	const gchar* _tmp26_;
	GError* _tmp27_;
	const gchar* _tmp28_;
	gchar* path;
	gchar* _tmp29_;
	GFileInputStream* _tmp30_;
	const gchar* _tmp31_;
	GFileInputStream* _tmp32_;
	GFileInputStream* _tmp33_;
	GFileInputStream* _tmp34_;
	GHashTable* _tmp35_;
	gchar* _tmp36_;
	GFileInputStream* _tmp37_;
	guint8* _tmp38_;
	gint _tmp39_;
	gsize _tmp40_;
	GError* e;
	GError* _tmp41_;
	const gchar* _tmp42_;
	GKeyFile* keyfile;
	GKeyFile* _tmp43_;
	GKeyFile* _tmp44_;
	guint8* _tmp45_;
	gint _tmp45__length1;
	gsize _tmp46_;
	GError* ee;
	GError* _tmp47_;
	const gchar* _tmp48_;
	GDesktopAppInfo* appinfo;
	GKeyFile* _tmp49_;
	GDesktopAppInfo* _tmp50_;
	GHashTable* _tmp51_;
	gchar* _tmp52_;
	GDesktopAppInfo* _tmp53_;
	GAppInfo* _tmp54_;
	GKeyFile* _tmp55_;
	GKeyFile* _tmp56_;
	GError * _inner_error_;
};


static gpointer unity_app_info_manager_parent_class = NULL;
static UnityAppInfoManager* unity_app_info_manager_singleton;
static UnityAppInfoManager* unity_app_info_manager_singleton = NULL;

void unity_string_array_wrapper_free (UnityStringArrayWrapper * self);
static void unity_string_array_wrapper_instance_init (UnityStringArrayWrapper * self);
void unity_string_array_wrapper_take_strings (UnityStringArrayWrapper* self,
                                              gchar** str_arr,
                                              int str_arr_length1);
UnityStringArrayWrapper* unity_string_array_wrapper_new (void);
#define UNITY_APP_INFO_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_APP_INFO_MANAGER, UnityAppInfoManagerPrivate))
static void _unity_app_info_manager___lambda5_ (UnityAppInfoManager* self,
                                         guint id);
static void __unity_app_info_manager___lambda5__gfunc (gconstpointer data,
                                                gpointer self);
static UnityAppInfoManager* unity_app_info_manager_new (void);
static UnityAppInfoManager* unity_app_info_manager_construct (GType object_type);
static void _g_free0_ (gpointer var);
static void _g_object_unref0_ (gpointer var);
static void _unity_string_array_wrapper_free0_ (gpointer var);
gchar** unity_internal_io_get_system_data_dirs (int* result_length1);
static void unity_app_info_manager_on_dir_changed (UnityAppInfoManager* self,
                                            GFileMonitor* mon,
                                            GFile* file,
                                            GFile* other_file,
                                            GFileMonitorEvent e);
static void _unity_app_info_manager_on_dir_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                                    GFile* file,
                                                                    GFile* other_file,
                                                                    GFileMonitorEvent event_type,
                                                                    gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block1Data* _data1_);
static gboolean ___lambda4__gsource_func (gpointer self);
static void unity_app_info_manager_register_categories (UnityAppInfoManager* self,
                                                 const gchar* id,
                                                 GKeyFile* keyfile);
static void unity_app_info_manager_register_keywords (UnityAppInfoManager* self,
                                               const gchar* id,
                                               GKeyFile* keyfile);
static void unity_app_info_manager_lookup_async_data_free (gpointer _data);
static void unity_app_info_manager_lookup_async_async_ready_wrapper (GObject *source_object,
                                                              GAsyncResult *res,
                                                              void *user_data);
static gboolean unity_app_info_manager_lookup_async_co (UnityAppInfoManagerLookupAsyncData* _data_);
static void unity_app_info_manager_lookup_async_ready (GObject* source_object,
                                                GAsyncResult* _res_,
                                                gpointer _user_data_);
void unity_internal_io_open_from_data_dirs (const gchar* filename,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_);
GFileInputStream* unity_internal_io_open_from_data_dirs_finish (GAsyncResult* _res_,
                                                                GError** error);
void unity_internal_io_read_stream_async (GInputStream* input,
                                          gint io_priority,
                                          GCancellable* cancellable,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_);
void unity_internal_io_read_stream_finish (GAsyncResult* _res_,
                                           guint8** data,
                                           int* data_length1,
                                           gsize* size,
                                           GError** error);
static void g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure,
                                                  GValue * return_value,
                                                  guint n_param_values,
                                                  const GValue * param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);
static void unity_app_info_manager_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);


void
unity_string_array_wrapper_take_strings (UnityStringArrayWrapper* self,
                                         gchar** str_arr,
                                         int str_arr_length1)
{
	gchar** _tmp0_;
	gint _tmp0__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = str_arr;
	_tmp0__length1 = str_arr_length1;
	str_arr = NULL;
	str_arr_length1 = 0;
	self->strings = (_vala_array_free (self->strings, self->strings_length1, (GDestroyNotify) g_free), NULL);
	self->strings = _tmp0_;
	self->strings_length1 = _tmp0__length1;
	self->_strings_size_ = self->strings_length1;
	str_arr = (_vala_array_free (str_arr, str_arr_length1, (GDestroyNotify) g_free), NULL);
}


UnityStringArrayWrapper*
unity_string_array_wrapper_new (void)
{
	UnityStringArrayWrapper* self;
	self = g_slice_new0 (UnityStringArrayWrapper);
	unity_string_array_wrapper_instance_init (self);
	return self;
}


static void
unity_string_array_wrapper_instance_init (UnityStringArrayWrapper * self)
{
}


void
unity_string_array_wrapper_free (UnityStringArrayWrapper * self)
{
	self->strings = (_vala_array_free (self->strings, self->strings_length1, (GDestroyNotify) g_free), NULL);
	g_slice_free (UnityStringArrayWrapper, self);
}


static void
_unity_app_info_manager___lambda5_ (UnityAppInfoManager* self,
                                    guint id)
{
	g_source_remove (id);
}


static void
__unity_app_info_manager___lambda5__gfunc (gconstpointer data,
                                           gpointer self)
{
	_unity_app_info_manager___lambda5_ ((UnityAppInfoManager*) self, (guint) ((guintptr) data));
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void
_unity_string_array_wrapper_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (unity_string_array_wrapper_free (var), NULL));
}


static void
_unity_app_info_manager_on_dir_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                               GFile* file,
                                                               GFile* other_file,
                                                               GFileMonitorEvent event_type,
                                                               gpointer self)
{
	unity_app_info_manager_on_dir_changed ((UnityAppInfoManager*) self, _sender, file, other_file, event_type);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static UnityAppInfoManager*
unity_app_info_manager_construct (GType object_type)
{
	UnityAppInfoManager * self = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GHashTable* _tmp5_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GHashTable* _tmp8_;
	GHashFunc _tmp9_;
	GEqualFunc _tmp10_;
	GHashTable* _tmp11_;
	GHashFunc _tmp12_;
	GEqualFunc _tmp13_;
	GHashTable* _tmp14_;
	gint _tmp15_ = 0;
	gchar** _tmp16_;
	GError * _inner_error_ = NULL;
	self = (UnityAppInfoManager*) g_object_new (object_type, NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (self->priv->appinfo_by_id);
	self->priv->appinfo_by_id = _tmp2_;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _unity_string_array_wrapper_free0_);
	_g_hash_table_unref0 (self->priv->categories_by_id);
	self->priv->categories_by_id = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, _unity_string_array_wrapper_free0_);
	_g_hash_table_unref0 (self->priv->keywords_by_id);
	self->priv->keywords_by_id = _tmp8_;
	_tmp9_ = g_str_hash;
	_tmp10_ = g_str_equal;
	_tmp11_ = g_hash_table_new_full (_tmp9_, _tmp10_, _g_free0_, _g_free0_);
	_g_hash_table_unref0 (self->priv->paths_by_id);
	self->priv->paths_by_id = _tmp11_;
	(self->priv->timeout_handlers == NULL) ? NULL : (self->priv->timeout_handlers = (g_list_free (self->priv->timeout_handlers), NULL));
	self->priv->timeout_handlers = NULL;
	_tmp12_ = g_str_hash;
	_tmp13_ = g_str_equal;
	_tmp14_ = g_hash_table_new_full (_tmp12_, _tmp13_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (self->priv->monitors);
	self->priv->monitors = _tmp14_;
	_tmp16_ = unity_internal_io_get_system_data_dirs (&_tmp15_);
	{
		gchar** path_collection = NULL;
		gint path_collection_length1 = 0;
		gint _path_collection_size_ = 0;
		gint path_it = 0;
		path_collection = _tmp16_;
		path_collection_length1 = _tmp15_;
		for (path_it = 0; path_it < _tmp15_; path_it = path_it + 1) {
			gchar* _tmp17_;
			gchar* path = NULL;
			_tmp17_ = g_strdup (path_collection[path_it]);
			path = _tmp17_;
			{
				GFile* dir = NULL;
				const gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				GFile* _tmp21_;
				GFile* _tmp22_;
				_tmp18_ = path;
				_tmp19_ = g_build_filename (_tmp18_, "applications", NULL);
				_tmp20_ = _tmp19_;
				_tmp21_ = g_file_new_for_path (_tmp20_);
				_tmp22_ = _tmp21_;
				_g_free0 (_tmp20_);
				dir = _tmp22_;
				{
					GFileMonitor* monitor = NULL;
					GFile* _tmp23_;
					GFileMonitor* _tmp24_;
					GFileMonitor* _tmp25_;
					GHashTable* _tmp26_;
					GFile* _tmp27_;
					gchar* _tmp28_;
					GFileMonitor* _tmp29_;
					GFileMonitor* _tmp30_;
					_tmp23_ = dir;
					_tmp24_ = g_file_monitor_directory (_tmp23_, G_FILE_MONITOR_NONE, NULL, &_inner_error_);
					monitor = _tmp24_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						if (_inner_error_->domain == G_IO_ERROR) {
							goto __catch0_g_io_error;
						}
						_g_object_unref0 (dir);
						_g_free0 (path);
						path_collection = (_vala_array_free (path_collection, path_collection_length1, (GDestroyNotify) g_free), NULL);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
					_tmp25_ = monitor;
					g_signal_connect_object (_tmp25_, "changed", (GCallback) _unity_app_info_manager_on_dir_changed_g_file_monitor_changed, self, 0);
					_tmp26_ = self->priv->monitors;
					_tmp27_ = dir;
					_tmp28_ = g_file_get_uri (_tmp27_);
					_tmp29_ = monitor;
					_tmp30_ = _g_object_ref0 (_tmp29_);
					g_hash_table_insert (_tmp26_, _tmp28_, _tmp30_);
					_g_object_unref0 (monitor);
				}
				goto __finally0;
				__catch0_g_io_error:
				{
					GError* e = NULL;
					GFile* _tmp31_;
					gchar* _tmp32_;
					gchar* _tmp33_;
					GError* _tmp34_;
					const gchar* _tmp35_;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp31_ = dir;
					_tmp32_ = g_file_get_uri (_tmp31_);
					_tmp33_ = _tmp32_;
					_tmp34_ = e;
					_tmp35_ = _tmp34_->message;
					g_warning ("unity-appinfo-manager.vala:86: Error setting up directory monitor on '" \
"%s': %s", _tmp33_, _tmp35_);
					_g_free0 (_tmp33_);
					_g_error_free0 (e);
				}
				__finally0:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (dir);
					_g_free0 (path);
					path_collection = (_vala_array_free (path_collection, path_collection_length1, (GDestroyNotify) g_free), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_g_object_unref0 (dir);
				_g_free0 (path);
			}
		}
		path_collection = (_vala_array_free (path_collection, path_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	return self;
}


static UnityAppInfoManager*
unity_app_info_manager_new (void)
{
	return unity_app_info_manager_construct (UNITY_TYPE_APP_INFO_MANAGER);
}


UnityAppInfoManager*
unity_app_info_manager_get_instance (void)
{
	UnityAppInfoManager* result = NULL;
	UnityAppInfoManager* _tmp0_;
	_tmp0_ = unity_app_info_manager_get_default ();
	result = _tmp0_;
	return result;
}


/**
     * Get a ref to the singleton AppInfoManager
     */
UnityAppInfoManager*
unity_app_info_manager_get_default (void)
{
	UnityAppInfoManager* result = NULL;
	UnityAppInfoManager* _tmp0_;
	UnityAppInfoManager* _tmp2_;
	UnityAppInfoManager* _tmp3_;
	_tmp0_ = unity_app_info_manager_singleton;
	if (_tmp0_ == NULL) {
		UnityAppInfoManager* _tmp1_;
		_tmp1_ = unity_app_info_manager_new ();
		_g_object_unref0 (unity_app_info_manager_singleton);
		unity_app_info_manager_singleton = _tmp1_;
	}
	_tmp2_ = unity_app_info_manager_singleton;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		UnityAppInfoManager* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->file);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean
__lambda4_ (Block1Data* _data1_)
{
	UnityAppInfoManager* self;
	gboolean result = FALSE;
	gchar* desktop_id = NULL;
	gchar* _tmp0_;
	gchar* path = NULL;
	gchar* _tmp1_;
	GAppInfo* appinfo = NULL;
	GHashTable* _tmp2_;
	const gchar* _tmp3_;
	GHashTable* _tmp8_;
	const gchar* _tmp9_;
	guint _tmp14_;
	self = _data1_->self;
	_tmp0_ = g_file_get_basename (_data1_->file);
	desktop_id = _tmp0_;
	_tmp1_ = g_file_get_path (_data1_->file);
	path = _tmp1_;
	_tmp2_ = self->priv->appinfo_by_id;
	_tmp3_ = desktop_id;
	if (g_hash_table_remove (_tmp2_, _tmp3_)) {
		const gchar* _tmp4_;
		GAppInfo* _tmp5_;
		const gchar* _tmp6_;
		GAppInfo* _tmp7_;
		_tmp4_ = desktop_id;
		_tmp5_ = unity_app_info_manager_lookup (self, _tmp4_);
		_g_object_unref0 (appinfo);
		appinfo = _tmp5_;
		_tmp6_ = desktop_id;
		_tmp7_ = appinfo;
		g_signal_emit (self, unity_app_info_manager_signals[UNITY_APP_INFO_MANAGER_CHANGED_SIGNAL], 0, _tmp6_, _tmp7_);
	}
	_tmp8_ = self->priv->appinfo_by_id;
	_tmp9_ = path;
	if (g_hash_table_remove (_tmp8_, _tmp9_)) {
		const gchar* _tmp10_;
		GAppInfo* _tmp11_;
		const gchar* _tmp12_;
		GAppInfo* _tmp13_;
		_tmp10_ = path;
		_tmp11_ = unity_app_info_manager_lookup (self, _tmp10_);
		_g_object_unref0 (appinfo);
		appinfo = _tmp11_;
		_tmp12_ = path;
		_tmp13_ = appinfo;
		g_signal_emit (self, unity_app_info_manager_signals[UNITY_APP_INFO_MANAGER_CHANGED_SIGNAL], 0, _tmp12_, _tmp13_);
	}
	_tmp14_ = _data1_->timeout_handler;
	self->priv->timeout_handlers = g_list_remove (self->priv->timeout_handlers, (gpointer) ((guintptr) _tmp14_));
	result = FALSE;
	_g_object_unref0 (appinfo);
	_g_free0 (path);
	_g_free0 (desktop_id);
	return result;
}


static gboolean
___lambda4__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda4_ (self);
	return result;
}


static void
unity_app_info_manager_on_dir_changed (UnityAppInfoManager* self,
                                       GFileMonitor* mon,
                                       GFile* file,
                                       GFile* other_file,
                                       GFileMonitorEvent e)
{
	Block1Data* _data1_;
	GFile* _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mon != NULL);
	g_return_if_fail (file != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (file);
	_g_object_unref0 (_data1_->file);
	_data1_->file = _tmp0_;
	_data1_->timeout_handler = (guint) 0;
	_data1_->timeout_handler = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 2, ___lambda4__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	_tmp1_ = _data1_->timeout_handler;
	self->priv->timeout_handlers = g_list_append (self->priv->timeout_handlers, (gpointer) ((guintptr) _tmp1_));
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


/**
     * Look up an AppInfo given its desktop id or absolute path. The desktop id
     * is the base filename of the .desktop file for the application including
     * the .desktop extension.
     *
     * If the AppInfo is not already cached this method will do synchronous
     * IO to look it up.
     */
GAppInfo*
unity_app_info_manager_lookup (UnityAppInfoManager* self,
                               const gchar* id)
{
	GAppInfo* result = NULL;
	GHashTable* _tmp0_;
	gboolean _tmp1_;
	GAppInfo* appinfo = NULL;
	GKeyFile* keyfile = NULL;
	GKeyFile* _tmp5_;
	GKeyFile* _tmp59_;
	GHashTable* _tmp64_;
	gchar* _tmp65_;
	GAppInfo* _tmp66_;
	GAppInfo* _tmp67_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = self->priv->appinfo_by_id;
	_tmp1_ = g_hash_table_lookup_extended (_tmp0_, id, NULL, NULL);
	if (_tmp1_) {
		GHashTable* _tmp2_;
		gconstpointer _tmp3_;
		GAppInfo* _tmp4_;
		_tmp2_ = self->priv->appinfo_by_id;
		_tmp3_ = g_hash_table_lookup (_tmp2_, id);
		_tmp4_ = _g_object_ref0 ((GAppInfo*) _tmp3_);
		result = _tmp4_;
		return result;
	}
	_tmp5_ = g_key_file_new ();
	keyfile = _tmp5_;
	if (g_str_has_prefix (id, "/")) {
		GHashTable* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		GFile* dir = NULL;
		GFile* _tmp15_;
		GFile* _tmp16_;
		GFile* _tmp17_;
		GFile* _tmp18_;
		gchar* dir_uri = NULL;
		GFile* _tmp19_;
		gchar* _tmp20_;
		GHashTable* _tmp21_;
		const gchar* _tmp22_;
		gconstpointer _tmp23_;
		_tmp6_ = self->priv->paths_by_id;
		_tmp7_ = g_strdup (id);
		_tmp8_ = g_strdup (id);
		g_hash_table_insert (_tmp6_, _tmp7_, _tmp8_);
		{
			GKeyFile* _tmp9_;
			_tmp9_ = keyfile;
			g_key_file_load_from_file (_tmp9_, id, G_KEY_FILE_NONE, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch1_g_error;
			}
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError* e = NULL;
			gboolean _tmp10_ = FALSE;
			GError* _tmp11_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_key_file_unref0 (keyfile);
			keyfile = NULL;
			_tmp11_ = e;
			if (g_error_matches (_tmp11_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
				_tmp10_ = TRUE;
			} else {
				GError* _tmp12_;
				_tmp12_ = e;
				_tmp10_ = g_error_matches (_tmp12_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_NOT_FOUND);
			}
			if (!_tmp10_) {
				GError* _tmp13_;
				const gchar* _tmp14_;
				_tmp13_ = e;
				_tmp14_ = _tmp13_->message;
				g_warning ("unity-appinfo-manager.vala:180: Error loading '%s': %s", id, _tmp14_);
			}
			_g_error_free0 (e);
		}
		__finally1:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_key_file_unref0 (keyfile);
			_g_object_unref0 (appinfo);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp15_ = g_file_new_for_path (id);
		_tmp16_ = _tmp15_;
		_tmp17_ = g_file_get_parent (_tmp16_);
		_tmp18_ = _tmp17_;
		_g_object_unref0 (_tmp16_);
		dir = _tmp18_;
		_tmp19_ = dir;
		_tmp20_ = g_file_get_uri (_tmp19_);
		dir_uri = _tmp20_;
		_tmp21_ = self->priv->monitors;
		_tmp22_ = dir_uri;
		_tmp23_ = g_hash_table_lookup (_tmp21_, _tmp22_);
		if (((GFileMonitor*) _tmp23_) == NULL) {
			{
				GFileMonitor* monitor = NULL;
				GFile* _tmp24_;
				GFileMonitor* _tmp25_;
				GFileMonitor* _tmp26_;
				GHashTable* _tmp27_;
				const gchar* _tmp28_;
				gchar* _tmp29_;
				GFileMonitor* _tmp30_;
				GFileMonitor* _tmp31_;
				const gchar* _tmp32_;
				_tmp24_ = dir;
				_tmp25_ = g_file_monitor_directory (_tmp24_, G_FILE_MONITOR_NONE, NULL, &_inner_error_);
				monitor = _tmp25_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if (_inner_error_->domain == G_IO_ERROR) {
						goto __catch2_g_io_error;
					}
					_g_free0 (dir_uri);
					_g_object_unref0 (dir);
					_g_key_file_unref0 (keyfile);
					_g_object_unref0 (appinfo);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_tmp26_ = monitor;
				g_signal_connect_object (_tmp26_, "changed", (GCallback) _unity_app_info_manager_on_dir_changed_g_file_monitor_changed, self, 0);
				_tmp27_ = self->priv->monitors;
				_tmp28_ = dir_uri;
				_tmp29_ = g_strdup (_tmp28_);
				_tmp30_ = monitor;
				_tmp31_ = _g_object_ref0 (_tmp30_);
				g_hash_table_insert (_tmp27_, _tmp29_, _tmp31_);
				_tmp32_ = dir_uri;
				unity_trace_log_object ((GObject*) self, "Monitoring extra app directory: %s", _tmp32_);
				_g_object_unref0 (monitor);
			}
			goto __finally2;
			__catch2_g_io_error:
			{
				GError* ioe = NULL;
				const gchar* _tmp33_;
				GError* _tmp34_;
				const gchar* _tmp35_;
				ioe = _inner_error_;
				_inner_error_ = NULL;
				_tmp33_ = dir_uri;
				_tmp34_ = ioe;
				_tmp35_ = _tmp34_->message;
				g_warning ("unity-appinfo-manager.vala:192: Error setting up extra app directory m" \
"onitor on '%s': %s", _tmp33_, _tmp35_);
				_g_error_free0 (ioe);
			}
			__finally2:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (dir_uri);
				_g_object_unref0 (dir);
				_g_key_file_unref0 (keyfile);
				_g_object_unref0 (appinfo);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_g_free0 (dir_uri);
		_g_object_unref0 (dir);
	} else {
		gchar* path = NULL;
		gchar* _tmp36_;
		gchar* full_path = NULL;
		const gchar* _tmp45_;
		_tmp36_ = g_build_filename ("applications", id, NULL, NULL);
		path = _tmp36_;
		full_path = NULL;
		{
			GKeyFile* _tmp37_;
			const gchar* _tmp38_;
			gchar* _tmp39_ = NULL;
			_tmp37_ = keyfile;
			_tmp38_ = path;
			g_key_file_load_from_data_dirs (_tmp37_, _tmp38_, &_tmp39_, G_KEY_FILE_NONE, &_inner_error_);
			_g_free0 (full_path);
			full_path = _tmp39_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch3_g_error;
			}
		}
		goto __finally3;
		__catch3_g_error:
		{
			GError* e = NULL;
			gboolean _tmp40_ = FALSE;
			GError* _tmp41_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_key_file_unref0 (keyfile);
			keyfile = NULL;
			_tmp41_ = e;
			if (g_error_matches (_tmp41_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
				_tmp40_ = TRUE;
			} else {
				GError* _tmp42_;
				_tmp42_ = e;
				_tmp40_ = g_error_matches (_tmp42_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_NOT_FOUND);
			}
			if (!_tmp40_) {
				GError* _tmp43_;
				const gchar* _tmp44_;
				_tmp43_ = e;
				_tmp44_ = _tmp43_->message;
				g_warning ("unity-appinfo-manager.vala:206: Error loading '%s': %s", id, _tmp44_);
			}
			_g_error_free0 (e);
		}
		__finally3:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (full_path);
			_g_free0 (path);
			_g_key_file_unref0 (keyfile);
			_g_object_unref0 (appinfo);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp45_ = full_path;
		if (_tmp45_ != NULL) {
			GFile* file = NULL;
			const gchar* _tmp46_;
			GFile* _tmp47_;
			GFile* _tmp48_;
			GFile* _tmp49_;
			gchar* _tmp50_;
			gchar* _tmp51_;
			GFile* _tmp52_;
			GHashTable* _tmp53_;
			gchar* _tmp54_;
			GFile* _tmp55_;
			gchar* _tmp56_;
			_tmp46_ = full_path;
			_tmp47_ = g_file_new_for_path (_tmp46_);
			file = _tmp47_;
			_tmp48_ = file;
			_tmp49_ = file;
			_tmp50_ = g_file_get_path (_tmp49_);
			_tmp51_ = _tmp50_;
			_tmp52_ = g_file_resolve_relative_path (_tmp48_, _tmp51_);
			_g_object_unref0 (file);
			file = _tmp52_;
			_g_free0 (_tmp51_);
			_tmp53_ = self->priv->paths_by_id;
			_tmp54_ = g_strdup (id);
			_tmp55_ = file;
			_tmp56_ = g_file_get_path (_tmp55_);
			g_hash_table_insert (_tmp53_, _tmp54_, _tmp56_);
			_g_object_unref0 (file);
		} else {
			GHashTable* _tmp57_;
			gchar* _tmp58_;
			_tmp57_ = self->priv->paths_by_id;
			_tmp58_ = g_strdup (id);
			g_hash_table_insert (_tmp57_, _tmp58_, NULL);
		}
		_g_free0 (full_path);
		_g_free0 (path);
	}
	_tmp59_ = keyfile;
	if (_tmp59_ != NULL) {
		GKeyFile* _tmp60_;
		GDesktopAppInfo* _tmp61_;
		GKeyFile* _tmp62_;
		GKeyFile* _tmp63_;
		_tmp60_ = keyfile;
		_tmp61_ = g_desktop_app_info_new_from_keyfile (_tmp60_);
		_g_object_unref0 (appinfo);
		appinfo = (GAppInfo*) _tmp61_;
		_tmp62_ = keyfile;
		unity_app_info_manager_register_categories (self, id, _tmp62_);
		_tmp63_ = keyfile;
		unity_app_info_manager_register_keywords (self, id, _tmp63_);
	} else {
		_g_object_unref0 (appinfo);
		appinfo = NULL;
	}
	_tmp64_ = self->priv->appinfo_by_id;
	_tmp65_ = g_strdup (id);
	_tmp66_ = appinfo;
	_tmp67_ = _g_object_ref0 (_tmp66_);
	g_hash_table_insert (_tmp64_, _tmp65_, _tmp67_);
	result = appinfo;
	_g_key_file_unref0 (keyfile);
	return result;
}


/**
     * Look up XDG categories for for desktop id or file path @id.
     * Returns null if id is not found.
     * This method will do sync IO if the desktop file for @id is not
     * already cached. So if you are living in an async world you must first
     * do an async call to lookup_async(id) before calling this method, in which
     * case no sync io will be done.
     */
gchar**
unity_app_info_manager_get_categories (UnityAppInfoManager* self,
                                       const gchar* id,
                                       int* result_length1)
{
	gchar** result = NULL;
	GAppInfo* appinfo = NULL;
	GAppInfo* _tmp0_;
	GAppInfo* _tmp1_;
	UnityStringArrayWrapper* _result_ = NULL;
	GHashTable* _tmp3_;
	gconstpointer _tmp4_;
	gchar** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gint __tmp5__size_ = 0;
	UnityStringArrayWrapper* _tmp6_;
	gchar** _tmp9_;
	gint _tmp9__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = unity_app_info_manager_lookup (self, id);
	appinfo = _tmp0_;
	_tmp1_ = appinfo;
	if (_tmp1_ == NULL) {
		gchar** _tmp2_;
		gint _tmp2__length1;
		_tmp2_ = NULL;
		_tmp2__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp2__length1;
		}
		result = _tmp2_;
		_g_object_unref0 (appinfo);
		return result;
	}
	_tmp3_ = self->priv->categories_by_id;
	_tmp4_ = g_hash_table_lookup (_tmp3_, id);
	_result_ = (UnityStringArrayWrapper*) _tmp4_;
	_tmp6_ = _result_;
	if (_tmp6_ != NULL) {
		UnityStringArrayWrapper* _tmp7_;
		gchar** _tmp8_;
		gint _tmp8__length1;
		_tmp7_ = _result_;
		_tmp8_ = _tmp7_->strings;
		_tmp8__length1 = _tmp7_->strings_length1;
		_tmp5_ = _tmp8_;
		_tmp5__length1 = _tmp8__length1;
		__tmp5__size_ = _tmp5__length1;
	} else {
		_tmp5_ = NULL;
		_tmp5__length1 = 0;
		__tmp5__size_ = _tmp5__length1;
	}
	_tmp9_ = _tmp5_;
	_tmp9__length1 = _tmp5__length1;
	if (result_length1) {
		*result_length1 = _tmp9__length1;
	}
	result = _tmp9_;
	_g_object_unref0 (appinfo);
	return result;
}


/**
     * Look up keywords for for desktop id or file path @id. The keywords will
     * be an amalgamation of the X-GNOME-Keywords and X-AppInstall-Keywords
     * fields from the .desktopfile.
     * Returns null if id is not found.
     * This method will do sync IO if the desktop file for @id is not
     * already cached. So if you are living in an async world you must first
     * do an async call to lookup_async(id) before calling this method, in which
     * case no sync io will be done.
     */
gchar**
unity_app_info_manager_get_keywords (UnityAppInfoManager* self,
                                     const gchar* id,
                                     int* result_length1)
{
	gchar** result = NULL;
	GAppInfo* appinfo = NULL;
	GAppInfo* _tmp0_;
	GAppInfo* _tmp1_;
	UnityStringArrayWrapper* _result_ = NULL;
	GHashTable* _tmp3_;
	gconstpointer _tmp4_;
	gchar** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gint __tmp5__size_ = 0;
	UnityStringArrayWrapper* _tmp6_;
	gchar** _tmp9_;
	gint _tmp9__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = unity_app_info_manager_lookup (self, id);
	appinfo = _tmp0_;
	_tmp1_ = appinfo;
	if (_tmp1_ == NULL) {
		gchar** _tmp2_;
		gint _tmp2__length1;
		_tmp2_ = NULL;
		_tmp2__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp2__length1;
		}
		result = _tmp2_;
		_g_object_unref0 (appinfo);
		return result;
	}
	_tmp3_ = self->priv->keywords_by_id;
	_tmp4_ = g_hash_table_lookup (_tmp3_, id);
	_result_ = (UnityStringArrayWrapper*) _tmp4_;
	_tmp6_ = _result_;
	if (_tmp6_ != NULL) {
		UnityStringArrayWrapper* _tmp7_;
		gchar** _tmp8_;
		gint _tmp8__length1;
		_tmp7_ = _result_;
		_tmp8_ = _tmp7_->strings;
		_tmp8__length1 = _tmp7_->strings_length1;
		_tmp5_ = _tmp8_;
		_tmp5__length1 = _tmp8__length1;
		__tmp5__size_ = _tmp5__length1;
	} else {
		_tmp5_ = NULL;
		_tmp5__length1 = 0;
		__tmp5__size_ = _tmp5__length1;
	}
	_tmp9_ = _tmp5_;
	_tmp9__length1 = _tmp5__length1;
	if (result_length1) {
		*result_length1 = _tmp9__length1;
	}
	result = _tmp9_;
	_g_object_unref0 (appinfo);
	return result;
}


/**
     * Look up the full path to the desktop file for desktop id @id.
     * Returns null if @id is not found.
     * This method will do sync IO if the desktop file for @id is not
     * already cached. So if you are living in an async world you must
     * first do an async call to lookup_async(id) before calling this 
     * method, in which case no sync io will be done.
     */
gchar*
unity_app_info_manager_get_path (UnityAppInfoManager* self,
                                 const gchar* id)
{
	gchar* result = NULL;
	GAppInfo* appinfo = NULL;
	GAppInfo* _tmp0_;
	GAppInfo* _tmp1_;
	GHashTable* _tmp2_;
	gconstpointer _tmp3_;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = unity_app_info_manager_lookup (self, id);
	appinfo = _tmp0_;
	_tmp1_ = appinfo;
	if (_tmp1_ == NULL) {
		result = NULL;
		_g_object_unref0 (appinfo);
		return result;
	}
	_tmp2_ = self->priv->paths_by_id;
	_tmp3_ = g_hash_table_lookup (_tmp2_, id);
	_tmp4_ = g_strdup ((const gchar*) _tmp3_);
	result = _tmp4_;
	_g_object_unref0 (appinfo);
	return result;
}


static void
unity_app_info_manager_lookup_async_data_free (gpointer _data)
{
	UnityAppInfoManagerLookupAsyncData* _data_;
	_data_ = _data;
	_g_free0 (_data_->id);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityAppInfoManagerLookupAsyncData, _data_);
}


static void
unity_app_info_manager_lookup_async_async_ready_wrapper (GObject *source_object,
                                                         GAsyncResult *res,
                                                         void *user_data)
{
	UnityAppInfoManagerLookupAsyncData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_app_info_manager_lookup_async (UnityAppInfoManager* self,
                                     const gchar* id,
                                     GAsyncReadyCallback _callback_,
                                     gpointer _user_data_)
{
	UnityAppInfoManagerLookupAsyncData* _data_;
	UnityAppInfoManager* _tmp0_;
	gchar* _tmp1_;
	_data_ = g_slice_new0 (UnityAppInfoManagerLookupAsyncData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, unity_app_info_manager_lookup_async_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_app_info_manager_lookup_async_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = g_strdup (id);
	_g_free0 (_data_->id);
	_data_->id = _tmp1_;
	unity_app_info_manager_lookup_async_co (_data_);
}


GAppInfo*
unity_app_info_manager_lookup_finish (UnityAppInfoManager* self,
                                      GAsyncResult* _res_,
                                      GError** error)
{
	GAppInfo* result;
	UnityAppInfoManagerLookupAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
     * Look up an AppInfo given its desktop id or absolute path.
     * The desktop id is the base filename of the .desktop file for the
     * application including the .desktop extension.
     *
     * If the AppInfo is not already cached this method will do asynchronous
     * IO to look it up.
     */
static void
unity_app_info_manager_lookup_async_ready (GObject* source_object,
                                           GAsyncResult* _res_,
                                           gpointer _user_data_)
{
	UnityAppInfoManagerLookupAsyncData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_app_info_manager_lookup_async_co (_data_);
}


static gboolean
unity_app_info_manager_lookup_async_co (UnityAppInfoManagerLookupAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->appinfo_by_id;
	_data_->_tmp1_ = g_hash_table_lookup_extended (_data_->_tmp0_, _data_->id, NULL, NULL);
	if (_data_->_tmp1_) {
		_data_->_tmp2_ = _data_->self->priv->appinfo_by_id;
		_data_->_tmp3_ = g_hash_table_lookup (_data_->_tmp2_, _data_->id);
		_data_->_tmp4_ = _g_object_ref0 ((GAppInfo*) _data_->_tmp3_);
		_data_->result = _data_->_tmp4_;
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->data_length1 = 0;
	_data_->_data_size_ = 0;
	if (g_str_has_prefix (_data_->id, "/")) {
		_data_->_tmp5_ = g_file_new_for_path (_data_->id);
		_data_->f = _data_->_tmp5_;
		_data_->_tmp7_ = _data_->f;
		_data_->_state_ = 1;
		g_file_read_async (_data_->_tmp7_, G_PRIORITY_DEFAULT, NULL, unity_app_info_manager_lookup_async_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp8_ = g_file_read_finish (_data_->_tmp7_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp6_ = _data_->_tmp8_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->f);
			_g_object_unref0 (_data_->input);
			_data_->data = (g_free (_data_->data), NULL);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp9_ = _data_->_tmp6_;
		_data_->_tmp6_ = NULL;
		_g_object_unref0 (_data_->input);
		_data_->input = _data_->_tmp9_;
		_data_->_tmp10_ = _data_->f;
		_data_->_tmp11_ = g_file_get_parent (_data_->_tmp10_);
		_data_->dir = _data_->_tmp11_;
		_data_->_tmp12_ = _data_->dir;
		_data_->_tmp13_ = g_file_get_uri (_data_->_tmp12_);
		_data_->dir_uri = _data_->_tmp13_;
		_data_->_tmp14_ = _data_->self->priv->monitors;
		_data_->_tmp15_ = _data_->dir_uri;
		_data_->_tmp16_ = g_hash_table_lookup (_data_->_tmp14_, _data_->_tmp15_);
		if (((GFileMonitor*) _data_->_tmp16_) == NULL) {
			{
				_data_->_tmp17_ = _data_->dir;
				_data_->_tmp18_ = g_file_monitor_directory (_data_->_tmp17_, G_FILE_MONITOR_NONE, NULL, &_data_->_inner_error_);
				_data_->monitor = _data_->_tmp18_;
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					if (_data_->_inner_error_->domain == G_IO_ERROR) {
						goto __catch4_g_io_error;
					}
					_g_free0 (_data_->dir_uri);
					_g_object_unref0 (_data_->dir);
					_g_object_unref0 (_data_->_tmp6_);
					_g_object_unref0 (_data_->f);
					_g_object_unref0 (_data_->input);
					_data_->data = (g_free (_data_->data), NULL);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
				_data_->_tmp19_ = _data_->monitor;
				g_signal_connect_object (_data_->_tmp19_, "changed", (GCallback) _unity_app_info_manager_on_dir_changed_g_file_monitor_changed, _data_->self, 0);
				_data_->_tmp20_ = _data_->self->priv->monitors;
				_data_->_tmp21_ = _data_->dir_uri;
				_data_->_tmp22_ = g_strdup (_data_->_tmp21_);
				_data_->_tmp23_ = _data_->monitor;
				_data_->_tmp24_ = _g_object_ref0 (_data_->_tmp23_);
				g_hash_table_insert (_data_->_tmp20_, _data_->_tmp22_, _data_->_tmp24_);
				_data_->_tmp25_ = _data_->dir_uri;
				unity_trace_log_object ((GObject*) _data_->self, "Monitoring extra app directory: %s", _data_->_tmp25_);
				_g_object_unref0 (_data_->monitor);
			}
			goto __finally4;
			__catch4_g_io_error:
			{
				_data_->ioe = _data_->_inner_error_;
				_data_->_inner_error_ = NULL;
				_data_->_tmp26_ = _data_->dir_uri;
				_data_->_tmp27_ = _data_->ioe;
				_data_->_tmp28_ = _data_->_tmp27_->message;
				g_warning ("unity-appinfo-manager.vala:333: Error setting up extra app directory m" \
"onitor on '%s': %s", _data_->_tmp26_, _data_->_tmp28_);
				_g_error_free0 (_data_->ioe);
			}
			__finally4:
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				g_task_return_error (_data_->_async_result, _data_->_inner_error_);
				_g_free0 (_data_->dir_uri);
				_g_object_unref0 (_data_->dir);
				_g_object_unref0 (_data_->_tmp6_);
				_g_object_unref0 (_data_->f);
				_g_object_unref0 (_data_->input);
				_data_->data = (g_free (_data_->data), NULL);
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
		}
		_g_free0 (_data_->dir_uri);
		_g_object_unref0 (_data_->dir);
		_g_object_unref0 (_data_->_tmp6_);
		_g_object_unref0 (_data_->f);
	} else {
		_data_->_tmp29_ = g_build_filename ("applications", _data_->id, NULL, NULL);
		_data_->path = _data_->_tmp29_;
		_data_->_tmp31_ = _data_->path;
		_data_->_state_ = 2;
		unity_internal_io_open_from_data_dirs (_data_->_tmp31_, unity_app_info_manager_lookup_async_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp32_ = unity_internal_io_open_from_data_dirs_finish (_data_->_res_, &_data_->_inner_error_);
		_data_->_tmp30_ = _data_->_tmp32_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_free0 (_data_->path);
			_g_object_unref0 (_data_->input);
			_data_->data = (g_free (_data_->data), NULL);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp33_ = _data_->_tmp30_;
		_data_->_tmp30_ = NULL;
		_g_object_unref0 (_data_->input);
		_data_->input = _data_->_tmp33_;
		_g_object_unref0 (_data_->_tmp30_);
		_g_free0 (_data_->path);
	}
	_data_->_tmp34_ = _data_->input;
	if (_data_->_tmp34_ == NULL) {
		_data_->_tmp35_ = _data_->self->priv->appinfo_by_id;
		_data_->_tmp36_ = g_strdup (_data_->id);
		g_hash_table_insert (_data_->_tmp35_, _data_->_tmp36_, NULL);
		_data_->result = NULL;
		_g_object_unref0 (_data_->input);
		_data_->data = (g_free (_data_->data), NULL);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	{
		_data_->_tmp37_ = _data_->input;
		_data_->_tmp38_ = NULL;
		_data_->_tmp40_ = 0UL;
		_data_->_state_ = 3;
		unity_internal_io_read_stream_async ((GInputStream*) _data_->_tmp37_, G_PRIORITY_LOW, NULL, unity_app_info_manager_lookup_async_ready, _data_);
		return FALSE;
		_state_3:
		unity_internal_io_read_stream_finish (_data_->_res_, &_data_->_tmp38_, &_data_->_tmp39_, &_data_->_tmp40_, &_data_->_inner_error_);
		_data_->data = (g_free (_data_->data), NULL);
		_data_->data = _data_->_tmp38_;
		_data_->data_length1 = _data_->_tmp39_;
		_data_->_data_size_ = _data_->data_length1;
		_data_->data_size = _data_->_tmp40_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp41_ = _data_->e;
		_data_->_tmp42_ = _data_->_tmp41_->message;
		g_warning ("unity-appinfo-manager.vala:361: Error reading '%s': %s", _data_->id, _data_->_tmp42_);
		_data_->result = NULL;
		_g_error_free0 (_data_->e);
		_g_object_unref0 (_data_->input);
		_data_->data = (g_free (_data_->data), NULL);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally5:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->input);
		_data_->data = (g_free (_data_->data), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp43_ = g_key_file_new ();
	_data_->keyfile = _data_->_tmp43_;
	{
		_data_->_tmp44_ = _data_->keyfile;
		_data_->_tmp45_ = _data_->data;
		_data_->_tmp45__length1 = _data_->data_length1;
		_data_->_tmp46_ = _data_->data_size;
		g_key_file_load_from_data (_data_->_tmp44_, (const gchar*) _data_->_tmp45_, _data_->_tmp46_, G_KEY_FILE_NONE, &_data_->_inner_error_);
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
	}
	goto __finally6;
	__catch6_g_error:
	{
		_data_->ee = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp47_ = _data_->ee;
		_data_->_tmp48_ = _data_->_tmp47_->message;
		g_warning ("unity-appinfo-manager.vala:372: Error parsing '%s': %s", _data_->id, _data_->_tmp48_);
		_data_->result = NULL;
		_g_error_free0 (_data_->ee);
		_g_key_file_unref0 (_data_->keyfile);
		_g_object_unref0 (_data_->input);
		_data_->data = (g_free (_data_->data), NULL);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally6:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_key_file_unref0 (_data_->keyfile);
		_g_object_unref0 (_data_->input);
		_data_->data = (g_free (_data_->data), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp49_ = _data_->keyfile;
	_data_->_tmp50_ = g_desktop_app_info_new_from_keyfile (_data_->_tmp49_);
	_data_->appinfo = _data_->_tmp50_;
	_data_->_tmp51_ = _data_->self->priv->appinfo_by_id;
	_data_->_tmp52_ = g_strdup (_data_->id);
	_data_->_tmp53_ = _data_->appinfo;
	_data_->_tmp54_ = _g_object_ref0 ((GAppInfo*) _data_->_tmp53_);
	g_hash_table_insert (_data_->_tmp51_, _data_->_tmp52_, _data_->_tmp54_);
	_data_->_tmp55_ = _data_->keyfile;
	unity_app_info_manager_register_categories (_data_->self, _data_->id, _data_->_tmp55_);
	_data_->_tmp56_ = _data_->keyfile;
	unity_app_info_manager_register_keywords (_data_->self, _data_->id, _data_->_tmp56_);
	_data_->result = (GAppInfo*) _data_->appinfo;
	_g_key_file_unref0 (_data_->keyfile);
	_g_object_unref0 (_data_->input);
	_data_->data = (g_free (_data_->data), NULL);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void
unity_app_info_manager_clear (UnityAppInfoManager* self)
{
	GHashTable* _tmp0_;
	GHashTable* _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->appinfo_by_id;
	g_hash_table_remove_all (_tmp0_);
	_tmp1_ = self->priv->categories_by_id;
	g_hash_table_remove_all (_tmp1_);
	_tmp2_ = self->priv->keywords_by_id;
	g_hash_table_remove_all (_tmp2_);
	_tmp3_ = self->priv->paths_by_id;
	g_hash_table_remove_all (_tmp3_);
}


static void
unity_app_info_manager_register_categories (UnityAppInfoManager* self,
                                            const gchar* id,
                                            GKeyFile* keyfile)
{
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id != NULL);
	g_return_if_fail (keyfile != NULL);
	{
		gchar** categories = NULL;
		gsize _tmp0_;
		gchar** _tmp1_;
		gint categories_length1;
		gint _categories_size_;
		UnityStringArrayWrapper* wrapper = NULL;
		UnityStringArrayWrapper* _tmp2_;
		UnityStringArrayWrapper* _tmp3_;
		gchar** _tmp4_;
		gint _tmp4__length1;
		GHashTable* _tmp5_;
		gchar* _tmp6_;
		UnityStringArrayWrapper* _tmp7_;
		_tmp1_ = g_key_file_get_string_list (keyfile, "Desktop Entry", "Categories", &_tmp0_, &_inner_error_);
		categories = _tmp1_;
		categories_length1 = _tmp0_;
		_categories_size_ = categories_length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch7_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp2_ = unity_string_array_wrapper_new ();
		wrapper = _tmp2_;
		_tmp3_ = wrapper;
		_tmp4_ = categories;
		_tmp4__length1 = categories_length1;
		categories = NULL;
		categories_length1 = 0;
		unity_string_array_wrapper_take_strings (_tmp3_, _tmp4_, _tmp4__length1);
		_tmp5_ = self->priv->categories_by_id;
		_tmp6_ = g_strdup (id);
		_tmp7_ = wrapper;
		wrapper = NULL;
		g_hash_table_insert (_tmp5_, _tmp6_, _tmp7_);
		_unity_string_array_wrapper_free0 (wrapper);
		categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally7;
	__catch7_g_key_file_error:
	{
		GError* eee = NULL;
		eee = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (eee);
	}
	__finally7:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void
unity_app_info_manager_register_keywords (UnityAppInfoManager* self,
                                          const gchar* id,
                                          GKeyFile* keyfile)
{
	gchar** gkeywords = NULL;
	gint gkeywords_length1 = 0;
	gint _gkeywords_size_ = 0;
	gchar** akeywords = NULL;
	gint akeywords_length1 = 0;
	gint _akeywords_size_ = 0;
	gchar** xdgkeywords = NULL;
	gint xdgkeywords_length1 = 0;
	gint _xdgkeywords_size_ = 0;
	gchar** keywords = NULL;
	gchar** _tmp15_;
	gint _tmp15__length1;
	gchar** _tmp16_;
	gint _tmp16__length1;
	gchar** _tmp17_;
	gint _tmp17__length1;
	gchar** _tmp18_;
	gint keywords_length1;
	gint _keywords_size_;
	UnityStringArrayWrapper* wrapper = NULL;
	UnityStringArrayWrapper* _tmp55_;
	UnityStringArrayWrapper* _tmp56_;
	gchar** _tmp57_;
	gint _tmp57__length1;
	GHashTable* _tmp58_;
	gchar* _tmp59_;
	UnityStringArrayWrapper* _tmp60_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id != NULL);
	g_return_if_fail (keyfile != NULL);
	{
		gchar** _tmp0_ = NULL;
		gsize _tmp1_;
		gchar** _tmp2_;
		gint _tmp0__length1;
		gint __tmp0__size_;
		gchar** _tmp3_;
		gint _tmp3__length1;
		_tmp2_ = g_key_file_get_locale_string_list (keyfile, "Desktop Entry", "X-GNOME-Keywords", NULL, &_tmp1_, &_inner_error_);
		_tmp0_ = _tmp2_;
		_tmp0__length1 = _tmp1_;
		__tmp0__size_ = _tmp0__length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch8_g_key_file_error;
			}
			xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
			akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
			gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp3_ = _tmp0_;
		_tmp3__length1 = _tmp0__length1;
		_tmp0_ = NULL;
		_tmp0__length1 = 0;
		gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
		gkeywords = _tmp3_;
		gkeywords_length1 = _tmp3__length1;
		_gkeywords_size_ = gkeywords_length1;
		_tmp0_ = (_vala_array_free (_tmp0_, _tmp0__length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally8;
	__catch8_g_key_file_error:
	{
		GError* e = NULL;
		gchar** _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = g_new0 (gchar*, 0 + 1);
		gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
		gkeywords = _tmp4_;
		gkeywords_length1 = 0;
		_gkeywords_size_ = gkeywords_length1;
		_g_error_free0 (e);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
		akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
		gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gchar** _tmp5_ = NULL;
		gsize _tmp6_;
		gchar** _tmp7_;
		gint _tmp5__length1;
		gint __tmp5__size_;
		gchar** _tmp8_;
		gint _tmp8__length1;
		_tmp7_ = g_key_file_get_locale_string_list (keyfile, "Desktop Entry", "X-AppInstall-Keywords", NULL, &_tmp6_, &_inner_error_);
		_tmp5_ = _tmp7_;
		_tmp5__length1 = _tmp6_;
		__tmp5__size_ = _tmp5__length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch9_g_key_file_error;
			}
			xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
			akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
			gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp8_ = _tmp5_;
		_tmp8__length1 = _tmp5__length1;
		_tmp5_ = NULL;
		_tmp5__length1 = 0;
		akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
		akeywords = _tmp8_;
		akeywords_length1 = _tmp8__length1;
		_akeywords_size_ = akeywords_length1;
		_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally9;
	__catch9_g_key_file_error:
	{
		GError* e = NULL;
		gchar** _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp9_ = g_new0 (gchar*, 0 + 1);
		akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
		akeywords = _tmp9_;
		akeywords_length1 = 0;
		_akeywords_size_ = akeywords_length1;
		_g_error_free0 (e);
	}
	__finally9:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
		akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
		gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gchar** _tmp10_ = NULL;
		gsize _tmp11_;
		gchar** _tmp12_;
		gint _tmp10__length1;
		gint __tmp10__size_;
		gchar** _tmp13_;
		gint _tmp13__length1;
		_tmp12_ = g_key_file_get_locale_string_list (keyfile, "Desktop Entry", "Keywords", NULL, &_tmp11_, &_inner_error_);
		_tmp10_ = _tmp12_;
		_tmp10__length1 = _tmp11_;
		__tmp10__size_ = _tmp10__length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch10_g_key_file_error;
			}
			xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
			akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
			gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp13_ = _tmp10_;
		_tmp13__length1 = _tmp10__length1;
		_tmp10_ = NULL;
		_tmp10__length1 = 0;
		xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
		xdgkeywords = _tmp13_;
		xdgkeywords_length1 = _tmp13__length1;
		_xdgkeywords_size_ = xdgkeywords_length1;
		_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally10;
	__catch10_g_key_file_error:
	{
		GError* e = NULL;
		gchar** _tmp14_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = g_new0 (gchar*, 0 + 1);
		xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
		xdgkeywords = _tmp14_;
		xdgkeywords_length1 = 0;
		_xdgkeywords_size_ = xdgkeywords_length1;
		_g_error_free0 (e);
	}
	__finally10:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
		akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
		gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp15_ = gkeywords;
	_tmp15__length1 = gkeywords_length1;
	_tmp16_ = akeywords;
	_tmp16__length1 = akeywords_length1;
	_tmp17_ = xdgkeywords;
	_tmp17__length1 = xdgkeywords_length1;
	_tmp18_ = g_new0 (gchar*, ((_tmp15__length1 + _tmp16__length1) + _tmp17__length1) + 1);
	keywords = _tmp18_;
	keywords_length1 = (_tmp15__length1 + _tmp16__length1) + _tmp17__length1;
	_keywords_size_ = keywords_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp19_ = FALSE;
			_tmp19_ = TRUE;
			while (TRUE) {
				gint _tmp21_;
				gchar** _tmp22_;
				gint _tmp22__length1;
				gchar** _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				gchar** _tmp25_;
				gint _tmp25__length1;
				gint _tmp26_;
				const gchar* _tmp27_;
				gchar* _tmp28_;
				gchar* _tmp29_;
				if (!_tmp19_) {
					gint _tmp20_;
					_tmp20_ = i;
					i = _tmp20_ + 1;
				}
				_tmp19_ = FALSE;
				_tmp21_ = i;
				_tmp22_ = gkeywords;
				_tmp22__length1 = gkeywords_length1;
				if (!(_tmp21_ < _tmp22__length1)) {
					break;
				}
				_tmp23_ = keywords;
				_tmp23__length1 = keywords_length1;
				_tmp24_ = i;
				_tmp25_ = gkeywords;
				_tmp25__length1 = gkeywords_length1;
				_tmp26_ = i;
				_tmp27_ = _tmp25_[_tmp26_];
				_tmp28_ = g_strdup (_tmp27_);
				_g_free0 (_tmp23_[_tmp24_]);
				_tmp23_[_tmp24_] = _tmp28_;
				_tmp29_ = _tmp23_[_tmp24_];
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp30_ = FALSE;
			_tmp30_ = TRUE;
			while (TRUE) {
				gint _tmp32_;
				gchar** _tmp33_;
				gint _tmp33__length1;
				gchar** _tmp34_;
				gint _tmp34__length1;
				gchar** _tmp35_;
				gint _tmp35__length1;
				gint _tmp36_;
				gchar** _tmp37_;
				gint _tmp37__length1;
				gint _tmp38_;
				const gchar* _tmp39_;
				gchar* _tmp40_;
				gchar* _tmp41_;
				if (!_tmp30_) {
					gint _tmp31_;
					_tmp31_ = i;
					i = _tmp31_ + 1;
				}
				_tmp30_ = FALSE;
				_tmp32_ = i;
				_tmp33_ = akeywords;
				_tmp33__length1 = akeywords_length1;
				if (!(_tmp32_ < _tmp33__length1)) {
					break;
				}
				_tmp34_ = keywords;
				_tmp34__length1 = keywords_length1;
				_tmp35_ = gkeywords;
				_tmp35__length1 = gkeywords_length1;
				_tmp36_ = i;
				_tmp37_ = akeywords;
				_tmp37__length1 = akeywords_length1;
				_tmp38_ = i;
				_tmp39_ = _tmp37_[_tmp38_];
				_tmp40_ = g_strdup (_tmp39_);
				_g_free0 (_tmp34_[_tmp35__length1 + _tmp36_]);
				_tmp34_[_tmp35__length1 + _tmp36_] = _tmp40_;
				_tmp41_ = _tmp34_[_tmp35__length1 + _tmp36_];
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp42_ = FALSE;
			_tmp42_ = TRUE;
			while (TRUE) {
				gint _tmp44_;
				gchar** _tmp45_;
				gint _tmp45__length1;
				gchar** _tmp46_;
				gint _tmp46__length1;
				gchar** _tmp47_;
				gint _tmp47__length1;
				gchar** _tmp48_;
				gint _tmp48__length1;
				gint _tmp49_;
				gchar** _tmp50_;
				gint _tmp50__length1;
				gint _tmp51_;
				const gchar* _tmp52_;
				gchar* _tmp53_;
				gchar* _tmp54_;
				if (!_tmp42_) {
					gint _tmp43_;
					_tmp43_ = i;
					i = _tmp43_ + 1;
				}
				_tmp42_ = FALSE;
				_tmp44_ = i;
				_tmp45_ = xdgkeywords;
				_tmp45__length1 = xdgkeywords_length1;
				if (!(_tmp44_ < _tmp45__length1)) {
					break;
				}
				_tmp46_ = keywords;
				_tmp46__length1 = keywords_length1;
				_tmp47_ = gkeywords;
				_tmp47__length1 = gkeywords_length1;
				_tmp48_ = akeywords;
				_tmp48__length1 = akeywords_length1;
				_tmp49_ = i;
				_tmp50_ = xdgkeywords;
				_tmp50__length1 = xdgkeywords_length1;
				_tmp51_ = i;
				_tmp52_ = _tmp50_[_tmp51_];
				_tmp53_ = g_strdup (_tmp52_);
				_g_free0 (_tmp46_[(_tmp47__length1 + _tmp48__length1) + _tmp49_]);
				_tmp46_[(_tmp47__length1 + _tmp48__length1) + _tmp49_] = _tmp53_;
				_tmp54_ = _tmp46_[(_tmp47__length1 + _tmp48__length1) + _tmp49_];
			}
		}
	}
	_tmp55_ = unity_string_array_wrapper_new ();
	wrapper = _tmp55_;
	_tmp56_ = wrapper;
	_tmp57_ = keywords;
	_tmp57__length1 = keywords_length1;
	keywords = NULL;
	keywords_length1 = 0;
	unity_string_array_wrapper_take_strings (_tmp56_, _tmp57_, _tmp57__length1);
	_tmp58_ = self->priv->keywords_by_id;
	_tmp59_ = g_strdup (id);
	_tmp60_ = wrapper;
	wrapper = NULL;
	g_hash_table_insert (_tmp58_, _tmp59_, _tmp60_);
	_unity_string_array_wrapper_free0 (wrapper);
	keywords = (_vala_array_free (keywords, keywords_length1, (GDestroyNotify) g_free), NULL);
	xdgkeywords = (_vala_array_free (xdgkeywords, xdgkeywords_length1, (GDestroyNotify) g_free), NULL);
	akeywords = (_vala_array_free (akeywords, akeywords_length1, (GDestroyNotify) g_free), NULL);
	gkeywords = (_vala_array_free (gkeywords, gkeywords_length1, (GDestroyNotify) g_free), NULL);
}


static void
g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure,
                                             GValue * return_value,
                                             guint n_param_values,
                                             const GValue * param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_OBJECT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static void
unity_app_info_manager_class_init (UnityAppInfoManagerClass * klass)
{
	unity_app_info_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityAppInfoManagerPrivate));
	G_OBJECT_CLASS (klass)->finalize = unity_app_info_manager_finalize;
	/**
	     * Emitted whenever an AppInfo in any of the monitored paths change.
	     * Note that @new_appinfo may be null in case it has been removed.
	     */
	unity_app_info_manager_signals[UNITY_APP_INFO_MANAGER_CHANGED_SIGNAL] = g_signal_new ("changed", UNITY_TYPE_APP_INFO_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_OBJECT, G_TYPE_NONE, 2, G_TYPE_STRING, g_app_info_get_type ());
}


static void
unity_app_info_manager_instance_init (UnityAppInfoManager * self)
{
	self->priv = UNITY_APP_INFO_MANAGER_GET_PRIVATE (self);
}


static void
unity_app_info_manager_finalize (GObject * obj)
{
	UnityAppInfoManager * self;
	GList* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_APP_INFO_MANAGER, UnityAppInfoManager);
	_tmp0_ = self->priv->timeout_handlers;
	g_list_foreach (_tmp0_, __unity_app_info_manager___lambda5__gfunc, self);
	_g_hash_table_unref0 (self->priv->appinfo_by_id);
	_g_hash_table_unref0 (self->priv->monitors);
	_g_hash_table_unref0 (self->priv->categories_by_id);
	_g_hash_table_unref0 (self->priv->keywords_by_id);
	_g_hash_table_unref0 (self->priv->paths_by_id);
	(self->priv->timeout_handlers == NULL) ? NULL : (self->priv->timeout_handlers = (g_list_free (self->priv->timeout_handlers), NULL));
	G_OBJECT_CLASS (unity_app_info_manager_parent_class)->finalize (obj);
}


/**
   * A singleton class that caches GLib.AppInfo objects.
   * Singletons are evil, yes, but this on slightly less
   * so because the exposed API is immutable.
   *
   * To detect when any of the managed AppInfo objects changes, appears,
   * or goes away listen for the 'changed' signal.
   */
GType
unity_app_info_manager_get_type (void)
{
	static volatile gsize unity_app_info_manager_type_id__volatile = 0;
	if (g_once_init_enter (&unity_app_info_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityAppInfoManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_app_info_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityAppInfoManager), 0, (GInstanceInitFunc) unity_app_info_manager_instance_init, NULL };
		GType unity_app_info_manager_type_id;
		unity_app_info_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityAppInfoManager", &g_define_type_info, 0);
		g_once_init_leave (&unity_app_info_manager_type_id__volatile, unity_app_info_manager_type_id);
	}
	return unity_app_info_manager_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



