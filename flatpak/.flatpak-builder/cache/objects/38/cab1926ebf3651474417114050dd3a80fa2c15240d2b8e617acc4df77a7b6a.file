/* unity-aggregator-scope.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-aggregator-scope.vala, do not modify */

/*
 * Copyright (C) 2013 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.hruby@canonical.com>
 *             Pawel Stolowski <pawel.stolowski@canonical.com>
 *
 */


#include <glib.h>
#include <glib-object.h>
#include "unity.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <unity-protocol.h>
#include <dee.h>

enum  {
	UNITY_AGGREGATOR_SCOPE_0_PROPERTY,
	UNITY_AGGREGATOR_SCOPE_MERGE_MODE_PROPERTY,
	UNITY_AGGREGATOR_SCOPE_PROXY_FILTER_HINTS_PROPERTY,
	UNITY_AGGREGATOR_SCOPE_AUTOMATIC_FLUSHING_PROPERTY,
	UNITY_AGGREGATOR_SCOPE_NUM_PROPERTIES
};
static GParamSpec* unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_NUM_PROPERTIES];

#define UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL (unity_internal_aggregator_scope_impl_get_type ())
#define UNITY_INTERNAL_AGGREGATOR_SCOPE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL, UnityInternalAggregatorScopeImpl))
#define UNITY_INTERNAL_AGGREGATOR_SCOPE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL, UnityInternalAggregatorScopeImplClass))
#define UNITY_INTERNAL_IS_AGGREGATOR_SCOPE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL))
#define UNITY_INTERNAL_IS_AGGREGATOR_SCOPE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL))
#define UNITY_INTERNAL_AGGREGATOR_SCOPE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL, UnityInternalAggregatorScopeImplClass))

typedef struct _UnityInternalAggregatorScopeImpl UnityInternalAggregatorScopeImpl;
typedef struct _UnityInternalAggregatorScopeImplClass UnityInternalAggregatorScopeImplClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _UnityAggregatorScopeActivateData UnityAggregatorScopeActivateData;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _UnityAggregatorScopeSearchScopeData UnityAggregatorScopeSearchScopeData;
typedef struct _UnityAggregatorScopePushResultsData UnityAggregatorScopePushResultsData;

struct _UnityAggregatorScopePrivate {
	UnityAggregatorScopeMergeMode _merge_mode;
	gboolean _proxy_filter_hints;
	gboolean _automatic_flushing;
};

struct _UnityAggregatorScopeActivateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityAggregatorScope* self;
	UnityAggregatorActivation* activation;
	UnityActivationResponse* result;
};

struct _UnityAggregatorScopeSearchScopeData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityAggregatorScope* self;
	UnityAggregatedScopeSearch* search;
	gchar* scope_id;
	gchar* search_query;
	UnitySearchType search_type;
	GHashTable* hints;
	GCancellable* cancellable;
	GHashTable* result;
	UnityInternalAggregatorScopeImpl* pimpl;
	GObject* _tmp0_;
	UnityInternalAggregatorScopeImpl* _tmp1_;
	GHashTable* res;
	GHashTable* _tmp2_;
	GError* scope_error;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GHashTable* _tmp5_;
	GError * _inner_error_;
};

struct _UnityAggregatorScopePushResultsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityAggregatorScope* self;
	gchar* channel_id;
	gchar* search_string;
	gchar* scope_id;
	DeeSerializableModel* results_model;
	gchar** category_ids;
	gint category_ids_length1;
	GCancellable* cancellable;
	UnityInternalAggregatorScopeImpl* pimpl;
	GObject* _tmp0_;
	UnityInternalAggregatorScopeImpl* _tmp1_;
	GError* err;
	GError* _tmp2_;
	const gchar* _tmp3_;
	GError * _inner_error_;
};


static gpointer unity_aggregator_scope_parent_class = NULL;

#define UNITY_AGGREGATOR_SCOPE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_AGGREGATOR_SCOPE, UnityAggregatorScopePrivate))
static gint unity_aggregator_scope_real_category_index_for_scope_id (UnityAggregatorScope* self,
                                                              const gchar* scope_id);
GType unity_internal_aggregator_scope_impl_get_type (void) G_GNUC_CONST;
GObject* unity_deprecated_scope_base_get_impl (UnityDeprecatedScopeBase* self);
void unity_internal_aggregator_scope_impl_add_sorter (UnityInternalAggregatorScopeImpl* self,
                                                      guint category_index,
                                                      const gchar* field,
                                                      UnityAggregatorScopeSortFlags flags);
void unity_internal_aggregator_scope_impl_add_constraint (UnityInternalAggregatorScopeImpl* self,
                                                          gint category_index,
                                                          const gchar* field);
static void unity_aggregator_scope_real_activate_data_free (gpointer _data);
static void unity_aggregator_scope_real_activate_async_ready_wrapper (GObject *source_object,
                                                               GAsyncResult *res,
                                                               void *user_data);
static void unity_aggregator_scope_real_activate (UnityAggregatorScope* self,
                                           UnityAggregatorActivation* activation,
                                           GAsyncReadyCallback _callback_,
                                           gpointer _user_data_);
static gboolean unity_aggregator_scope_real_activate_co (UnityAggregatorScopeActivateData* _data_);
static void unity_aggregator_scope_search_scope_data_free (gpointer _data);
static void unity_aggregator_scope_search_scope_async_ready_wrapper (GObject *source_object,
                                                              GAsyncResult *res,
                                                              void *user_data);
void unity_aggregator_scope_search_scope (UnityAggregatorScope* self,
                                          UnityAggregatedScopeSearch* search,
                                          const gchar* scope_id,
                                          const gchar* search_query,
                                          UnitySearchType search_type,
                                          GHashTable* hints,
                                          GCancellable* cancellable,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_);
GHashTable* unity_aggregator_scope_search_scope_finish (UnityAggregatorScope* self,
                                                        GAsyncResult* _res_,
                                                        GError** error);
static gboolean unity_aggregator_scope_search_scope_co (UnityAggregatorScopeSearchScopeData* _data_);
void unity_internal_aggregator_scope_impl_search_scope (UnityInternalAggregatorScopeImpl* self,
                                                        UnityAggregatedScopeSearch* search,
                                                        const gchar* scope_id,
                                                        const gchar* search_string,
                                                        UnitySearchType search_type,
                                                        GHashTable* hints,
                                                        GCancellable* cancellable,
                                                        GAsyncReadyCallback _callback_,
                                                        gpointer _user_data_);
GHashTable* unity_internal_aggregator_scope_impl_search_scope_finish (UnityInternalAggregatorScopeImpl* self,
                                                                      GAsyncResult* _res_,
                                                                      GError** error);
static void unity_aggregator_scope_search_scope_ready (GObject* source_object,
                                                GAsyncResult* _res_,
                                                gpointer _user_data_);
static void _g_free0_ (gpointer var);
static void _g_variant_unref0_ (gpointer var);
static void unity_aggregator_scope_push_results_data_free (gpointer _data);
static void unity_aggregator_scope_push_results_async_ready_wrapper (GObject *source_object,
                                                              GAsyncResult *res,
                                                              void *user_data);
void unity_aggregator_scope_push_results (UnityAggregatorScope* self,
                                          const gchar* channel_id,
                                          const gchar* search_string,
                                          const gchar* scope_id,
                                          DeeSerializableModel* results_model,
                                          gchar** category_ids,
                                          int category_ids_length1,
                                          GCancellable* cancellable,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_);
void unity_aggregator_scope_push_results_finish (UnityAggregatorScope* self,
                                                 GAsyncResult* _res_);
static gboolean unity_aggregator_scope_push_results_co (UnityAggregatorScopePushResultsData* _data_);
void unity_internal_aggregator_scope_impl_push_results_to_scope (UnityInternalAggregatorScopeImpl* self,
                                                                 const gchar* channel_id,
                                                                 const gchar* search_string,
                                                                 const gchar* scope_id,
                                                                 DeeSerializableModel* results_model,
                                                                 gchar** category_ids,
                                                                 int category_ids_length1,
                                                                 GCancellable* cancellable,
                                                                 GAsyncReadyCallback _callback_,
                                                                 gpointer _user_data_);
void unity_internal_aggregator_scope_impl_push_results_to_scope_finish (UnityInternalAggregatorScopeImpl* self,
                                                                        GAsyncResult* _res_,
                                                                        GError** error);
static void unity_aggregator_scope_push_results_ready (GObject* source_object,
                                                GAsyncResult* _res_,
                                                gpointer _user_data_);
void unity_aggregator_scope_push_filter_settings (UnityAggregatorScope* self,
                                                  const gchar* channel_id,
                                                  UnityFilterSet* filters);
void unity_internal_aggregator_scope_impl_push_filter_settings (UnityInternalAggregatorScopeImpl* self,
                                                                const gchar* channel_id,
                                                                UnityFilterSet* filters);
static GObject* unity_aggregator_scope_real_create_impl (UnityDeprecatedScopeBase* base);
UnityInternalAggregatorScopeImpl* unity_internal_aggregator_scope_impl_new (UnityAggregatorScope* owner);
UnityInternalAggregatorScopeImpl* unity_internal_aggregator_scope_impl_construct (GType object_type,
                                                                                  UnityAggregatorScope* owner);
static void unity_aggregator_scope_finalize (GObject * obj);
static void _vala_unity_aggregator_scope_get_property (GObject * object,
                                                guint property_id,
                                                GValue * value,
                                                GParamSpec * pspec);
static void _vala_unity_aggregator_scope_set_property (GObject * object,
                                                guint property_id,
                                                const GValue * value,
                                                GParamSpec * pspec);


GType
unity_aggregator_scope_sort_flags_get_type (void)
{
	static volatile gsize unity_aggregator_scope_sort_flags_type_id__volatile = 0;
	if (g_once_init_enter (&unity_aggregator_scope_sort_flags_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_AGGREGATOR_SCOPE_SORT_FLAGS_ASCENDING, "UNITY_AGGREGATOR_SCOPE_SORT_FLAGS_ASCENDING", "ascending"}, {UNITY_AGGREGATOR_SCOPE_SORT_FLAGS_DESCENDING, "UNITY_AGGREGATOR_SCOPE_SORT_FLAGS_DESCENDING", "descending"}, {UNITY_AGGREGATOR_SCOPE_SORT_FLAGS_CASE_INSENSITIVE, "UNITY_AGGREGATOR_SCOPE_SORT_FLAGS_CASE_INSENSITIVE", "case-insensitive"}, {0, NULL, NULL}};
		GType unity_aggregator_scope_sort_flags_type_id;
		unity_aggregator_scope_sort_flags_type_id = g_enum_register_static ("UnityAggregatorScopeSortFlags", values);
		g_once_init_leave (&unity_aggregator_scope_sort_flags_type_id__volatile, unity_aggregator_scope_sort_flags_type_id);
	}
	return unity_aggregator_scope_sort_flags_type_id__volatile;
}


GType
unity_aggregator_scope_merge_mode_get_type (void)
{
	static volatile gsize unity_aggregator_scope_merge_mode_type_id__volatile = 0;
	if (g_once_init_enter (&unity_aggregator_scope_merge_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_AGGREGATOR_SCOPE_MERGE_MODE_CATEGORY_ID, "UNITY_AGGREGATOR_SCOPE_MERGE_MODE_CATEGORY_ID", "category-id"}, {UNITY_AGGREGATOR_SCOPE_MERGE_MODE_OWNER_SCOPE, "UNITY_AGGREGATOR_SCOPE_MERGE_MODE_OWNER_SCOPE", "owner-scope"}, {0, NULL, NULL}};
		GType unity_aggregator_scope_merge_mode_type_id;
		unity_aggregator_scope_merge_mode_type_id = g_enum_register_static ("UnityAggregatorScopeMergeMode", values);
		g_once_init_leave (&unity_aggregator_scope_merge_mode_type_id__volatile, unity_aggregator_scope_merge_mode_type_id);
	}
	return unity_aggregator_scope_merge_mode_type_id__volatile;
}


/**
   * Maps scope ids to associated category index, needed if merge mode is OWNER_SCOPE.
   * A dummy implementation may be provided for merge mode = DISPLAY_NAME.
   */
static gint
unity_aggregator_scope_real_category_index_for_scope_id (UnityAggregatorScope* self,
                                                         const gchar* scope_id)
{
	gint _tmp0_ = 0;
	g_critical ("Type `%s' does not implement abstract method `unity_aggregator_scope_category_index_for_scope_id'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}


gint
unity_aggregator_scope_category_index_for_scope_id (UnityAggregatorScope* self,
                                                    const gchar* scope_id)
{
	g_return_val_if_fail (self != NULL, 0);
	return UNITY_AGGREGATOR_SCOPE_GET_CLASS (self)->category_index_for_scope_id (self, scope_id);
}


UnityAggregatorScope*
unity_aggregator_scope_construct (GType object_type,
                                  const gchar* dbus_path_,
                                  const gchar* id_,
                                  UnityAggregatorScopeMergeMode merge_mode,
                                  gboolean proxy_filter_hints)
{
	UnityAggregatorScope * self = NULL;
	g_return_val_if_fail (dbus_path_ != NULL, NULL);
	g_return_val_if_fail (id_ != NULL, NULL);
	self = (UnityAggregatorScope*) g_object_new (object_type, "dbus-path", dbus_path_, "id", id_, "is-master", TRUE, "merge-mode", merge_mode, "proxy-filter-hints", proxy_filter_hints, NULL);
	return self;
}


/**
   * Sort data in a given category by values of 'field'.
   *
   * Aggregating results from multiple scopes often needs a clear way to sort
   * the results, to do that you can define category-specific sorting rules.
   * As an example, a category displaying recent items might be sorted using
   * a "timestamp" field (which would be defined as either a required or 
   * optional metadata field {@link Unity.Scope.metadata_schema}).
   * For categories that don't have any obvious order it is recommended to sort
   * them according to the "title" field.
   *
   * @param category_index Index of the sorted category
   * @param field Name of the field the order will be based on
   * @param flags The way sorting is performed
   */
static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


void
unity_aggregator_scope_add_sorter (UnityAggregatorScope* self,
                                   guint category_index,
                                   const gchar* field,
                                   UnityAggregatorScopeSortFlags flags)
{
	UnityInternalAggregatorScopeImpl* pimpl = NULL;
	GObject* _tmp0_;
	UnityInternalAggregatorScopeImpl* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (field != NULL);
	_tmp0_ = unity_deprecated_scope_base_get_impl ((UnityDeprecatedScopeBase*) self);
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL) ? ((UnityInternalAggregatorScopeImpl*) _tmp0_) : NULL);
	pimpl = _tmp1_;
	unity_internal_aggregator_scope_impl_add_sorter (pimpl, category_index, field, flags);
	_g_object_unref0 (pimpl);
}


/**
   * Constraint data to be unique according to value of 'field'.
   *
   * This method allows de-duplication of results from multiple scopes
   * by only allowing unique values for the given field.
   * As an example, a scope that is aggregating results from different local
   * music databases could simply constraint the results on values of the "uri"
   * field, which would ensure that songs with the same uri are displayed only
   * once.
   * 
   * @param category_index Index of the constrained category,
   *                       or -1 to constraint all categories
   * @param field Name of the constrained field
   */
void
unity_aggregator_scope_add_constraint (UnityAggregatorScope* self,
                                       gint category_index,
                                       const gchar* field)
{
	UnityInternalAggregatorScopeImpl* pimpl = NULL;
	GObject* _tmp0_;
	UnityInternalAggregatorScopeImpl* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (field != NULL);
	_tmp0_ = unity_deprecated_scope_base_get_impl ((UnityDeprecatedScopeBase*) self);
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL) ? ((UnityInternalAggregatorScopeImpl*) _tmp0_) : NULL);
	pimpl = _tmp1_;
	unity_internal_aggregator_scope_impl_add_constraint (pimpl, category_index, field);
	_g_object_unref0 (pimpl);
}


void
unity_aggregator_scope_search (UnityAggregatorScope* self,
                               UnityAggregatedScopeSearch* scope_search,
                               GAsyncReadyCallback _callback_,
                               gpointer _user_data_)
{
	UNITY_AGGREGATOR_SCOPE_GET_CLASS (self)->search (self, scope_search, _callback_, _user_data_);
}


void
unity_aggregator_scope_search_finish (UnityAggregatorScope* self,
                                      GAsyncResult* _res_)
{
	UNITY_AGGREGATOR_SCOPE_GET_CLASS (self)->search_finish (self, _res_);
}


static void
unity_aggregator_scope_real_activate_data_free (gpointer _data)
{
	UnityAggregatorScopeActivateData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->activation);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityAggregatorScopeActivateData, _data_);
}


static void
unity_aggregator_scope_real_activate_async_ready_wrapper (GObject *source_object,
                                                          GAsyncResult *res,
                                                          void *user_data)
{
	UnityAggregatorScopeActivateData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static void
unity_aggregator_scope_real_activate (UnityAggregatorScope* self,
                                      UnityAggregatorActivation* activation,
                                      GAsyncReadyCallback _callback_,
                                      gpointer _user_data_)
{
	UnityAggregatorScopeActivateData* _data_;
	UnityAggregatorScope* _tmp0_;
	UnityAggregatorActivation* _tmp1_;
	_data_ = g_slice_new0 (UnityAggregatorScopeActivateData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, unity_aggregator_scope_real_activate_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_aggregator_scope_real_activate_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (activation);
	_g_object_unref0 (_data_->activation);
	_data_->activation = _tmp1_;
	unity_aggregator_scope_real_activate_co (_data_);
}


static UnityActivationResponse*
unity_aggregator_scope_real_activate_finish (UnityAggregatorScope* self,
                                             GAsyncResult* _res_)
{
	UnityActivationResponse* result;
	UnityAggregatorScopeActivateData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static gboolean
unity_aggregator_scope_real_activate_co (UnityAggregatorScopeActivateData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->result = NULL;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void
unity_aggregator_scope_activate (UnityAggregatorScope* self,
                                 UnityAggregatorActivation* activation,
                                 GAsyncReadyCallback _callback_,
                                 gpointer _user_data_)
{
	UNITY_AGGREGATOR_SCOPE_GET_CLASS (self)->activate (self, activation, _callback_, _user_data_);
}


UnityActivationResponse*
unity_aggregator_scope_activate_finish (UnityAggregatorScope* self,
                                        GAsyncResult* _res_)
{
	return UNITY_AGGREGATOR_SCOPE_GET_CLASS (self)->activate_finish (self, _res_);
}


static void
unity_aggregator_scope_search_scope_data_free (gpointer _data)
{
	UnityAggregatorScopeSearchScopeData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->search);
	_g_free0 (_data_->scope_id);
	_g_free0 (_data_->search_query);
	_g_hash_table_unref0 (_data_->hints);
	_g_object_unref0 (_data_->cancellable);
	_g_hash_table_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityAggregatorScopeSearchScopeData, _data_);
}


static void
unity_aggregator_scope_search_scope_async_ready_wrapper (GObject *source_object,
                                                         GAsyncResult *res,
                                                         void *user_data)
{
	UnityAggregatorScopeSearchScopeData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_g_hash_table_ref0 (gpointer self)
{
	return self ? g_hash_table_ref (self) : NULL;
}


void
unity_aggregator_scope_search_scope (UnityAggregatorScope* self,
                                     UnityAggregatedScopeSearch* search,
                                     const gchar* scope_id,
                                     const gchar* search_query,
                                     UnitySearchType search_type,
                                     GHashTable* hints,
                                     GCancellable* cancellable,
                                     GAsyncReadyCallback _callback_,
                                     gpointer _user_data_)
{
	UnityAggregatorScopeSearchScopeData* _data_;
	UnityAggregatorScope* _tmp0_;
	UnityAggregatedScopeSearch* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	GHashTable* _tmp4_;
	GCancellable* _tmp5_;
	_data_ = g_slice_new0 (UnityAggregatorScopeSearchScopeData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, unity_aggregator_scope_search_scope_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_aggregator_scope_search_scope_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (search);
	_g_object_unref0 (_data_->search);
	_data_->search = _tmp1_;
	_tmp2_ = g_strdup (scope_id);
	_g_free0 (_data_->scope_id);
	_data_->scope_id = _tmp2_;
	_tmp3_ = g_strdup (search_query);
	_g_free0 (_data_->search_query);
	_data_->search_query = _tmp3_;
	_data_->search_type = search_type;
	_tmp4_ = _g_hash_table_ref0 (hints);
	_g_hash_table_unref0 (_data_->hints);
	_data_->hints = _tmp4_;
	_tmp5_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp5_;
	unity_aggregator_scope_search_scope_co (_data_);
}


GHashTable*
unity_aggregator_scope_search_scope_finish (UnityAggregatorScope* self,
                                            GAsyncResult* _res_,
                                            GError** error)
{
	GHashTable* result;
	UnityAggregatorScopeSearchScopeData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static void
unity_aggregator_scope_search_scope_ready (GObject* source_object,
                                           GAsyncResult* _res_,
                                           gpointer _user_data_)
{
	UnityAggregatorScopeSearchScopeData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_aggregator_scope_search_scope_co (_data_);
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
_g_variant_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_variant_unref (var), NULL));
}


static gboolean
unity_aggregator_scope_search_scope_co (UnityAggregatorScopeSearchScopeData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = unity_deprecated_scope_base_get_impl ((UnityDeprecatedScopeBase*) _data_->self);
	_data_->_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp0_, UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL) ? ((UnityInternalAggregatorScopeImpl*) _data_->_tmp0_) : NULL);
	_data_->pimpl = _data_->_tmp1_;
	{
		_data_->_state_ = 1;
		unity_internal_aggregator_scope_impl_search_scope (_data_->pimpl, _data_->search, _data_->scope_id, _data_->search_query, _data_->search_type, _data_->hints, _data_->cancellable, unity_aggregator_scope_search_scope_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp2_ = unity_internal_aggregator_scope_impl_search_scope_finish (_data_->pimpl, _data_->_res_, &_data_->_inner_error_);
		_data_->res = _data_->_tmp2_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			if (g_error_matches (_data_->_inner_error_, UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DISABLED_CONTENT)) {
				goto __catch24_unity_protocol_scope_error_disabled_content;
			}
			goto __finally24;
		}
		_data_->result = _data_->res;
		_g_object_unref0 (_data_->pimpl);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	goto __finally24;
	__catch24_unity_protocol_scope_error_disabled_content:
	{
		_data_->scope_error = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp3_ = g_str_hash;
		_data_->_tmp4_ = g_str_equal;
		_data_->_tmp5_ = g_hash_table_new_full (_data_->_tmp3_, _data_->_tmp4_, _g_free0_, _g_variant_unref0_);
		_data_->result = _data_->_tmp5_;
		_g_error_free0 (_data_->scope_error);
		_g_object_unref0 (_data_->pimpl);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally24:
	g_task_return_error (_data_->_async_result, _data_->_inner_error_);
	_g_object_unref0 (_data_->pimpl);
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_aggregator_scope_push_results_data_free (gpointer _data)
{
	UnityAggregatorScopePushResultsData* _data_;
	_data_ = _data;
	_g_free0 (_data_->channel_id);
	_g_free0 (_data_->search_string);
	_g_free0 (_data_->scope_id);
	_g_object_unref0 (_data_->results_model);
	_g_object_unref0 (_data_->cancellable);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityAggregatorScopePushResultsData, _data_);
}


static void
unity_aggregator_scope_push_results_async_ready_wrapper (GObject *source_object,
                                                         GAsyncResult *res,
                                                         void *user_data)
{
	UnityAggregatorScopePushResultsData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_aggregator_scope_push_results (UnityAggregatorScope* self,
                                     const gchar* channel_id,
                                     const gchar* search_string,
                                     const gchar* scope_id,
                                     DeeSerializableModel* results_model,
                                     gchar** category_ids,
                                     int category_ids_length1,
                                     GCancellable* cancellable,
                                     GAsyncReadyCallback _callback_,
                                     gpointer _user_data_)
{
	UnityAggregatorScopePushResultsData* _data_;
	UnityAggregatorScope* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	DeeSerializableModel* _tmp4_;
	GCancellable* _tmp5_;
	_data_ = g_slice_new0 (UnityAggregatorScopePushResultsData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, unity_aggregator_scope_push_results_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_aggregator_scope_push_results_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = g_strdup (channel_id);
	_g_free0 (_data_->channel_id);
	_data_->channel_id = _tmp1_;
	_tmp2_ = g_strdup (search_string);
	_g_free0 (_data_->search_string);
	_data_->search_string = _tmp2_;
	_tmp3_ = g_strdup (scope_id);
	_g_free0 (_data_->scope_id);
	_data_->scope_id = _tmp3_;
	_tmp4_ = _g_object_ref0 (results_model);
	_g_object_unref0 (_data_->results_model);
	_data_->results_model = _tmp4_;
	_data_->category_ids = category_ids;
	_data_->category_ids_length1 = category_ids_length1;
	_tmp5_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp5_;
	unity_aggregator_scope_push_results_co (_data_);
}


void
unity_aggregator_scope_push_results_finish (UnityAggregatorScope* self,
                                            GAsyncResult* _res_)
{
	UnityAggregatorScopePushResultsData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	if (NULL == _data_) {
		return;
	}
}


static void
unity_aggregator_scope_push_results_ready (GObject* source_object,
                                           GAsyncResult* _res_,
                                           gpointer _user_data_)
{
	UnityAggregatorScopePushResultsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_aggregator_scope_push_results_co (_data_);
}


static gboolean
unity_aggregator_scope_push_results_co (UnityAggregatorScopePushResultsData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = unity_deprecated_scope_base_get_impl ((UnityDeprecatedScopeBase*) _data_->self);
	_data_->_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp0_, UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL) ? ((UnityInternalAggregatorScopeImpl*) _data_->_tmp0_) : NULL);
	_data_->pimpl = _data_->_tmp1_;
	{
		_data_->_state_ = 1;
		unity_internal_aggregator_scope_impl_push_results_to_scope (_data_->pimpl, _data_->channel_id, _data_->search_string, _data_->scope_id, _data_->results_model, _data_->category_ids, _data_->category_ids_length1, _data_->cancellable, unity_aggregator_scope_push_results_ready, _data_);
		return FALSE;
		_state_1:
		unity_internal_aggregator_scope_impl_push_results_to_scope_finish (_data_->pimpl, _data_->_res_, &_data_->_inner_error_);
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch25_g_error;
		}
	}
	goto __finally25;
	__catch25_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp2_ = _data_->err;
		_data_->_tmp3_ = _data_->_tmp2_->message;
		g_warning ("unity-aggregator-scope.vala:145: %s", _data_->_tmp3_);
		_g_error_free0 (_data_->err);
	}
	__finally25:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_object_unref0 (_data_->pimpl);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_g_object_unref0 (_data_->pimpl);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void
unity_aggregator_scope_push_filter_settings (UnityAggregatorScope* self,
                                             const gchar* channel_id,
                                             UnityFilterSet* filters)
{
	UnityInternalAggregatorScopeImpl* pimpl = NULL;
	GObject* _tmp0_;
	UnityInternalAggregatorScopeImpl* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (channel_id != NULL);
	g_return_if_fail (filters != NULL);
	_tmp0_ = unity_deprecated_scope_base_get_impl ((UnityDeprecatedScopeBase*) self);
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, UNITY_INTERNAL_TYPE_AGGREGATOR_SCOPE_IMPL) ? ((UnityInternalAggregatorScopeImpl*) _tmp0_) : NULL);
	pimpl = _tmp1_;
	unity_internal_aggregator_scope_impl_push_filter_settings (pimpl, channel_id, filters);
	_g_object_unref0 (pimpl);
}


static GObject*
unity_aggregator_scope_real_create_impl (UnityDeprecatedScopeBase* base)
{
	UnityAggregatorScope * self;
	GObject* result = NULL;
	UnityInternalAggregatorScopeImpl* _tmp0_;
	self = (UnityAggregatorScope*) base;
	_tmp0_ = unity_internal_aggregator_scope_impl_new (self);
	result = (GObject*) _tmp0_;
	return result;
}


UnityAggregatorScopeMergeMode
unity_aggregator_scope_get_merge_mode (UnityAggregatorScope* self)
{
	UnityAggregatorScopeMergeMode result;
	UnityAggregatorScopeMergeMode _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_merge_mode;
	result = _tmp0_;
	return result;
}


void
unity_aggregator_scope_set_merge_mode (UnityAggregatorScope* self,
                                       UnityAggregatorScopeMergeMode value)
{
	g_return_if_fail (self != NULL);
	if (unity_aggregator_scope_get_merge_mode (self) != value) {
		self->priv->_merge_mode = value;
		g_object_notify_by_pspec ((GObject *) self, unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_MERGE_MODE_PROPERTY]);
	}
}


gboolean
unity_aggregator_scope_get_proxy_filter_hints (UnityAggregatorScope* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_proxy_filter_hints;
	result = _tmp0_;
	return result;
}


void
unity_aggregator_scope_set_proxy_filter_hints (UnityAggregatorScope* self,
                                               gboolean value)
{
	g_return_if_fail (self != NULL);
	if (unity_aggregator_scope_get_proxy_filter_hints (self) != value) {
		self->priv->_proxy_filter_hints = value;
		g_object_notify_by_pspec ((GObject *) self, unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_PROXY_FILTER_HINTS_PROPERTY]);
	}
}


gboolean
unity_aggregator_scope_get_automatic_flushing (UnityAggregatorScope* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_automatic_flushing;
	result = _tmp0_;
	return result;
}


void
unity_aggregator_scope_set_automatic_flushing (UnityAggregatorScope* self,
                                               gboolean value)
{
	g_return_if_fail (self != NULL);
	if (unity_aggregator_scope_get_automatic_flushing (self) != value) {
		self->priv->_automatic_flushing = value;
		g_object_notify_by_pspec ((GObject *) self, unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_AUTOMATIC_FLUSHING_PROPERTY]);
	}
}


static void
unity_aggregator_scope_class_init (UnityAggregatorScopeClass * klass)
{
	unity_aggregator_scope_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityAggregatorScopePrivate));
	((UnityAggregatorScopeClass *) klass)->category_index_for_scope_id = (gint (*) (UnityAggregatorScope *, const gchar*)) unity_aggregator_scope_real_category_index_for_scope_id;
	((UnityAggregatorScopeClass *) klass)->activate = (void (*) (UnityAggregatorScope *, UnityAggregatorActivation*, GAsyncReadyCallback, gpointer)) unity_aggregator_scope_real_activate;
	((UnityAggregatorScopeClass *) klass)->activate_finish = (UnityActivationResponse* (*) (UnityAggregatorScope *, GAsyncResult*)) unity_aggregator_scope_real_activate_finish;
	((UnityDeprecatedScopeBaseClass *) klass)->create_impl = (GObject* (*) (UnityDeprecatedScopeBase *)) unity_aggregator_scope_real_create_impl;
	G_OBJECT_CLASS (klass)->get_property = _vala_unity_aggregator_scope_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_unity_aggregator_scope_set_property;
	G_OBJECT_CLASS (klass)->finalize = unity_aggregator_scope_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_AGGREGATOR_SCOPE_MERGE_MODE_PROPERTY, unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_MERGE_MODE_PROPERTY] = g_param_spec_enum ("merge-mode", "merge-mode", "merge-mode", UNITY_AGGREGATOR_SCOPE_TYPE_MERGE_MODE, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_AGGREGATOR_SCOPE_PROXY_FILTER_HINTS_PROPERTY, unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_PROXY_FILTER_HINTS_PROPERTY] = g_param_spec_boolean ("proxy-filter-hints", "proxy-filter-hints", "proxy-filter-hints", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_AGGREGATOR_SCOPE_AUTOMATIC_FLUSHING_PROPERTY, unity_aggregator_scope_properties[UNITY_AGGREGATOR_SCOPE_AUTOMATIC_FLUSHING_PROPERTY] = g_param_spec_boolean ("automatic-flushing", "automatic-flushing", "automatic-flushing", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void
unity_aggregator_scope_instance_init (UnityAggregatorScope * self)
{
	self->priv = UNITY_AGGREGATOR_SCOPE_GET_PRIVATE (self);
	self->priv->_automatic_flushing = TRUE;
}


static void
unity_aggregator_scope_finalize (GObject * obj)
{
	UnityAggregatorScope * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_AGGREGATOR_SCOPE, UnityAggregatorScope);
	G_OBJECT_CLASS (unity_aggregator_scope_parent_class)->finalize (obj);
}


GType
unity_aggregator_scope_get_type (void)
{
	static volatile gsize unity_aggregator_scope_type_id__volatile = 0;
	if (g_once_init_enter (&unity_aggregator_scope_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityAggregatorScopeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_aggregator_scope_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityAggregatorScope), 0, (GInstanceInitFunc) unity_aggregator_scope_instance_init, NULL };
		GType unity_aggregator_scope_type_id;
		unity_aggregator_scope_type_id = g_type_register_static (UNITY_TYPE_DEPRECATED_SCOPE_BASE, "UnityAggregatorScope", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_aggregator_scope_type_id__volatile, unity_aggregator_scope_type_id);
	}
	return unity_aggregator_scope_type_id__volatile;
}


static void
_vala_unity_aggregator_scope_get_property (GObject * object,
                                           guint property_id,
                                           GValue * value,
                                           GParamSpec * pspec)
{
	UnityAggregatorScope * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, UNITY_TYPE_AGGREGATOR_SCOPE, UnityAggregatorScope);
	switch (property_id) {
		case UNITY_AGGREGATOR_SCOPE_MERGE_MODE_PROPERTY:
		g_value_set_enum (value, unity_aggregator_scope_get_merge_mode (self));
		break;
		case UNITY_AGGREGATOR_SCOPE_PROXY_FILTER_HINTS_PROPERTY:
		g_value_set_boolean (value, unity_aggregator_scope_get_proxy_filter_hints (self));
		break;
		case UNITY_AGGREGATOR_SCOPE_AUTOMATIC_FLUSHING_PROPERTY:
		g_value_set_boolean (value, unity_aggregator_scope_get_automatic_flushing (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_vala_unity_aggregator_scope_set_property (GObject * object,
                                           guint property_id,
                                           const GValue * value,
                                           GParamSpec * pspec)
{
	UnityAggregatorScope * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, UNITY_TYPE_AGGREGATOR_SCOPE, UnityAggregatorScope);
	switch (property_id) {
		case UNITY_AGGREGATOR_SCOPE_MERGE_MODE_PROPERTY:
		unity_aggregator_scope_set_merge_mode (self, g_value_get_enum (value));
		break;
		case UNITY_AGGREGATOR_SCOPE_PROXY_FILTER_HINTS_PROPERTY:
		unity_aggregator_scope_set_proxy_filter_hints (self, g_value_get_boolean (value));
		break;
		case UNITY_AGGREGATOR_SCOPE_AUTOMATIC_FLUSHING_PROPERTY:
		unity_aggregator_scope_set_automatic_flushing (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



