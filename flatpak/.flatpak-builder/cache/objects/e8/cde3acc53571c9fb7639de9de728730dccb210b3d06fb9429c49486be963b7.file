/* unity-scope-channel.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-scope-channel.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Neil Jagdish Patel <neil.patel@canonical.com>
 *             Michal Hruby <michal.hruby@canonical.com>
 *
 */


#include <glib.h>
#include <glib-object.h>
#include <dee.h>
#include "unity.h"
#include <unity-protocol.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define UNITY_INTERNAL_TYPE_CHANNEL_STATE (unity_internal_channel_state_get_type ())

#define UNITY_INTERNAL_TYPE_SCOPE_CHANNEL (unity_internal_scope_channel_get_type ())
#define UNITY_INTERNAL_SCOPE_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannel))
#define UNITY_INTERNAL_SCOPE_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannelClass))
#define UNITY_INTERNAL_IS_SCOPE_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL))
#define UNITY_INTERNAL_IS_SCOPE_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL))
#define UNITY_INTERNAL_SCOPE_CHANNEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannelClass))

typedef struct _UnityInternalScopeChannel UnityInternalScopeChannel;
typedef struct _UnityInternalScopeChannelClass UnityInternalScopeChannelClass;
typedef struct _UnityInternalScopeChannelPrivate UnityInternalScopeChannelPrivate;

#define UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX (unity_internal_utils_async_mutex_get_type ())
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutex))
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexClass))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_MUTEX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_MUTEX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX))
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexClass))

typedef struct _UnityInternalUtilsAsyncMutex UnityInternalUtilsAsyncMutex;
typedef struct _UnityInternalUtilsAsyncMutexClass UnityInternalUtilsAsyncMutexClass;
typedef struct _UnityInternalUtilsDelegateWrapper UnityInternalUtilsDelegateWrapper;

#define UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER (unity_internal_scope_channel_owner_watcher_get_type ())
#define UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER, UnityInternalScopeChannelOwnerWatcher))
#define UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER, UnityInternalScopeChannelOwnerWatcherClass))
#define UNITY_INTERNAL_SCOPE_CHANNEL_IS_OWNER_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER))
#define UNITY_INTERNAL_SCOPE_CHANNEL_IS_OWNER_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER))
#define UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER, UnityInternalScopeChannelOwnerWatcherClass))

typedef struct _UnityInternalScopeChannelOwnerWatcher UnityInternalScopeChannelOwnerWatcher;
typedef struct _UnityInternalScopeChannelOwnerWatcherClass UnityInternalScopeChannelOwnerWatcherClass;
enum  {
	UNITY_INTERNAL_SCOPE_CHANNEL_0_PROPERTY,
	UNITY_INTERNAL_SCOPE_CHANNEL_NUM_PROPERTIES
};
static GParamSpec* unity_internal_scope_channel_properties[UNITY_INTERNAL_SCOPE_CHANNEL_NUM_PROPERTIES];
#define _unity_internal_utils_async_mutex_unref0(var) ((var == NULL) ? NULL : (var = (unity_internal_utils_async_mutex_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _unity_internal_scope_channel_owner_watcher_unref0(var) ((var == NULL) ? NULL : (var = (unity_internal_scope_channel_owner_watcher_unref (var), NULL)))
typedef struct _Block17Data Block17Data;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define UNITY_INTERNAL_TYPE_DIFF_MODEL (unity_internal_diff_model_get_type ())
#define UNITY_INTERNAL_DIFF_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_DIFF_MODEL, UnityInternalDiffModel))
#define UNITY_INTERNAL_DIFF_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_DIFF_MODEL, UnityInternalDiffModelClass))
#define UNITY_INTERNAL_IS_DIFF_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_DIFF_MODEL))
#define UNITY_INTERNAL_IS_DIFF_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_DIFF_MODEL))
#define UNITY_INTERNAL_DIFF_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_DIFF_MODEL, UnityInternalDiffModelClass))

typedef struct _UnityInternalDiffModel UnityInternalDiffModel;
typedef struct _UnityInternalDiffModelClass UnityInternalDiffModelClass;
typedef struct _UnityInternalScopeChannelWaitForSearchData UnityInternalScopeChannelWaitForSearchData;
typedef struct _UnityInternalScopeChannelOwnerWatcherPrivate UnityInternalScopeChannelOwnerWatcherPrivate;
typedef struct _UnityInternalScopeChannelParamSpecOwnerWatcher UnityInternalScopeChannelParamSpecOwnerWatcher;
enum  {
	UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_LOST_SIGNAL,
	UNITY_INTERNAL_SCOPE_CHANNEL_NUM_SIGNALS
};
static guint unity_internal_scope_channel_signals[UNITY_INTERNAL_SCOPE_CHANNEL_NUM_SIGNALS] = {0};

typedef enum  {
	UNITY_INTERNAL_CHANNEL_STATE_IDLE,
	UNITY_INTERNAL_CHANNEL_STATE_SEARCH_ACTIVE
} UnityInternalChannelState;

struct _UnityInternalScopeChannel {
	GObject parent_instance;
	UnityInternalScopeChannelPrivate * priv;
	UnityInternalUtilsAsyncMutex* model_lock;
	DeeSharedModel* transfer_model;
	DeeSerializableModel* backend_model;
	UnityFilterSet* filters;
	UnityProtocolChannelType channel_type;
	gchar* id;
	UnityScopeSearchBase* last_search;
	guint last_search_tag;
};

struct _UnityInternalScopeChannelClass {
	GObjectClass parent_class;
};

struct _UnityInternalScopeChannelPrivate {
	UnityInternalChannelState state;
	UnityInternalUtilsDelegateWrapper** callbacks;
	gint callbacks_length1;
	gint _callbacks_size_;
	gchar* last_push_search_string;
	GList* pushed_models;
	UnityInternalScopeChannelOwnerWatcher* watcher;
};

struct _Block17Data {
	int _ref_count_;
	GHashTable* types;
};

struct _UnityInternalScopeChannelWaitForSearchData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeChannel* self;
	UnityScopeSearchBase* _tmp0_;
	UnityInternalUtilsDelegateWrapper** _tmp1_;
	gint _tmp1__length1;
	UnityInternalUtilsDelegateWrapper* _tmp2_;
};

struct _UnityInternalUtilsDelegateWrapper {
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
};

struct _UnityInternalScopeChannelOwnerWatcher {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityInternalScopeChannelOwnerWatcherPrivate * priv;
};

struct _UnityInternalScopeChannelOwnerWatcherClass {
	GTypeClass parent_class;
	void (*finalize) (UnityInternalScopeChannelOwnerWatcher *self);
};

struct _UnityInternalScopeChannelOwnerWatcherPrivate {
	guint owner_changed_signal_id;
	UnityInternalScopeChannel* owner_channel;
	GDBusConnection* dbus_connection;
};

struct _UnityInternalScopeChannelParamSpecOwnerWatcher {
	GParamSpec parent_instance;
};


static gpointer unity_internal_scope_channel_parent_class = NULL;
static gpointer unity_internal_scope_channel_owner_watcher_parent_class = NULL;

GType unity_internal_channel_state_get_type (void) G_GNUC_CONST;
GType unity_internal_scope_channel_get_type (void) G_GNUC_CONST;
gpointer unity_internal_utils_async_mutex_ref (gpointer instance);
void unity_internal_utils_async_mutex_unref (gpointer instance);
GParamSpec* unity_internal_utils_param_spec_async_mutex (const gchar* name,
                                                         const gchar* nick,
                                                         const gchar* blurb,
                                                         GType object_type,
                                                         GParamFlags flags);
void unity_internal_utils_value_set_async_mutex (GValue* value,
                                                 gpointer v_object);
void unity_internal_utils_value_take_async_mutex (GValue* value,
                                                  gpointer v_object);
gpointer unity_internal_utils_value_get_async_mutex (const GValue* value);
GType unity_internal_utils_async_mutex_get_type (void) G_GNUC_CONST;
void unity_internal_utils_delegate_wrapper_free (UnityInternalUtilsDelegateWrapper * self);
static gpointer unity_internal_scope_channel_owner_watcher_ref (gpointer instance);
static void unity_internal_scope_channel_owner_watcher_unref (gpointer instance);
static GParamSpec* unity_internal_scope_channel_param_spec_owner_watcher (const gchar* name,
                                                                   const gchar* nick,
                                                                   const gchar* blurb,
                                                                   GType object_type,
                                                                   GParamFlags flags) G_GNUC_UNUSED;
static void unity_internal_scope_channel_value_set_owner_watcher (GValue* value,
                                                           gpointer v_object) G_GNUC_UNUSED;
static void unity_internal_scope_channel_value_take_owner_watcher (GValue* value,
                                                            gpointer v_object) G_GNUC_UNUSED;
static gpointer unity_internal_scope_channel_value_get_owner_watcher (const GValue* value) G_GNUC_UNUSED;
static GType unity_internal_scope_channel_owner_watcher_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define UNITY_INTERNAL_SCOPE_CHANNEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannelPrivate))
static void unity_internal_scope_channel_owner_watcher_unwatch (UnityInternalScopeChannelOwnerWatcher* self);
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
#define UNITY_INTERNAL_SCOPE_CHANNEL_METADATA_COLUMN ((guint) 8)
UnityInternalScopeChannel* unity_internal_scope_channel_new (UnityProtocolChannelType channel_type_);
UnityInternalScopeChannel* unity_internal_scope_channel_construct (GType object_type,
                                                                   UnityProtocolChannelType channel_type_);
UnityInternalUtilsAsyncMutex* unity_internal_utils_async_mutex_new (void);
UnityInternalUtilsAsyncMutex* unity_internal_utils_async_mutex_construct (GType object_type);
UnitySearchType unity_internal_scope_channel_get_search_type (UnityInternalScopeChannel* self);
static DeeSerializableModel* unity_internal_scope_channel_create_filter_model (DeeModel* backend,
                                                                        GHashTable* metadata_schema);
static Block17Data* block17_data_ref (Block17Data* _data17_);
static void block17_data_unref (void * _userdata_);
static void _g_free0_ (gpointer var);
static void _g_variant_type_free0_ (gpointer var);
static void __lambda10_ (Block17Data* _data17_,
                  const gchar* field,
                  const gchar* schema);
static void ___lambda10__gh_func (gconstpointer key,
                           gconstpointer value,
                           gpointer self);
static void __lambda11_ (void);
static void ___lambda11__dee_filter_map_func (DeeModel* orig_model,
                                       DeeFilterModel* filter_model,
                                       void* data);
static gboolean __lambda12_ (Block17Data* _data17_,
                      DeeModel* orig_model,
                      DeeModelIter* iter,
                      DeeFilterModel* filter_model);
static gboolean ___lambda12__dee_filter_map_notify (DeeModel* orig_model,
                                             DeeModelIter* orig_iter,
                                             DeeFilterModel* filter_model,
                                             gpointer self);
static DeeSerializableModel* unity_internal_scope_channel_create_backend_model (UnityInternalScopeChannel* self,
                                                                         GHashTable* metadata_schema,
                                                                         gboolean no_filtering,
                                                                         DeeSerializableModel* * real_backend);
gchar* unity_internal_scope_channel_create_channel (UnityInternalScopeChannel* self,
                                                    const gchar* swarm_name,
                                                    GHashTable* metadata_schema,
                                                    GHashTable* optional_metadata,
                                                    DeeSerializableModel* filter_model,
                                                    UnityProtocolChannelFlags flags);
GType unity_internal_diff_model_get_type (void) G_GNUC_CONST;
UnityInternalDiffModel* unity_internal_diff_model_new (DeePeer* peer,
                                                       DeeModel* target);
UnityInternalDiffModel* unity_internal_diff_model_construct (GType object_type,
                                                             DeePeer* peer,
                                                             DeeModel* target);
void unity_internal_scope_channel_set_filter_base (UnityInternalScopeChannel* self,
                                                   DeeSerializableModel* filter_model);
UnityFilter* unity_filter_for_filter_model_row (DeeModel* model,
                                                DeeModelIter* iter);
UnityFilter* unity_internal_scope_channel_get_filter_by_id (UnityInternalScopeChannel* self,
                                                            const gchar* filter_id);
static void unity_internal_scope_channel_wait_for_search_data_free (gpointer _data);
static void unity_internal_scope_channel_wait_for_search_async_ready_wrapper (GObject *source_object,
                                                                       GAsyncResult *res,
                                                                       void *user_data);
void unity_internal_scope_channel_wait_for_search (UnityInternalScopeChannel* self,
                                                   GAsyncReadyCallback _callback_,
                                                   gpointer _user_data_);
void unity_internal_scope_channel_wait_for_search_finish (UnityInternalScopeChannel* self,
                                                          GAsyncResult* _res_);
static gboolean unity_internal_scope_channel_wait_for_search_co (UnityInternalScopeChannelWaitForSearchData* _data_);
static gboolean _unity_internal_scope_channel_wait_for_search_co_gsource_func (gpointer self);
UnityInternalUtilsDelegateWrapper* unity_internal_utils_delegate_wrapper_new (GSourceFunc cb,
                                                                              gpointer cb_target,
                                                                              GDestroyNotify cb_target_destroy_notify);
static void _vala_array_add3 (UnityInternalUtilsDelegateWrapper** * array,
                       int* length,
                       int* size,
                       UnityInternalUtilsDelegateWrapper* value);
void unity_internal_scope_channel_set_state (UnityInternalScopeChannel* self,
                                             UnityInternalChannelState new_state);
const gchar* unity_internal_channel_state_to_string (UnityInternalChannelState self);
gboolean unity_internal_scope_channel_is_search_running (UnityInternalScopeChannel* self);
guint64 unity_internal_scope_channel_get_last_seqnum (UnityInternalScopeChannel* self);
void unity_internal_diff_model_commit_changes (UnityInternalDiffModel* self);
void unity_internal_scope_channel_register_pushed_model (UnityInternalScopeChannel* self,
                                                         const gchar* search_string,
                                                         DeeSerializableModel* model);
GList* unity_internal_scope_channel_get_pushed_models (UnityInternalScopeChannel* self,
                                                       const gchar* search_string);
void unity_internal_scope_channel_watch_owner (UnityInternalScopeChannel* self,
                                               GDBusConnection* connection,
                                               const char* owner);
static UnityInternalScopeChannelOwnerWatcher* unity_internal_scope_channel_owner_watcher_new (UnityInternalScopeChannel* channel,
                                                                                       GDBusConnection* connection,
                                                                                       const char* owner);
static UnityInternalScopeChannelOwnerWatcher* unity_internal_scope_channel_owner_watcher_construct (GType object_type,
                                                                                             UnityInternalScopeChannel* channel,
                                                                                             GDBusConnection* connection,
                                                                                             const char* owner);
#define UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_WATCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER, UnityInternalScopeChannelOwnerWatcherPrivate))
static void unity_internal_scope_channel_owner_watcher_owner_changed (UnityInternalScopeChannelOwnerWatcher* self,
                                                               GDBusConnection* con,
                                                               const gchar* sender_name,
                                                               const gchar* obj_path,
                                                               const gchar* ifc_name,
                                                               const gchar* sig_name,
                                                               GVariant* parameters);
static void _unity_internal_scope_channel_owner_watcher_owner_changed_gd_bus_signal_callback (GDBusConnection* connection,
                                                                                       const gchar* sender_name,
                                                                                       const gchar* object_path,
                                                                                       const gchar* interface_name,
                                                                                       const gchar* signal_name,
                                                                                       GVariant* parameters,
                                                                                       gpointer self);
static void unity_internal_scope_channel_owner_watcher_finalize (UnityInternalScopeChannelOwnerWatcher * obj);
static void unity_internal_scope_channel_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

extern const gchar* UNITY_INTERNAL_RESULTS_SCHEMA[9];
extern const gchar* UNITY_INTERNAL_RESULTS_COLUMN_NAMES[9];

GType
unity_internal_channel_state_get_type (void)
{
	static volatile gsize unity_internal_channel_state_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_channel_state_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_INTERNAL_CHANNEL_STATE_IDLE, "UNITY_INTERNAL_CHANNEL_STATE_IDLE", "idle"}, {UNITY_INTERNAL_CHANNEL_STATE_SEARCH_ACTIVE, "UNITY_INTERNAL_CHANNEL_STATE_SEARCH_ACTIVE", "search-active"}, {0, NULL, NULL}};
		GType unity_internal_channel_state_type_id;
		unity_internal_channel_state_type_id = g_enum_register_static ("UnityInternalChannelState", values);
		g_once_init_leave (&unity_internal_channel_state_type_id__volatile, unity_internal_channel_state_type_id);
	}
	return unity_internal_channel_state_type_id__volatile;
}


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}


UnityInternalScopeChannel*
unity_internal_scope_channel_construct (GType object_type,
                                        UnityProtocolChannelType channel_type_)
{
	UnityInternalScopeChannel * self = NULL;
	gchar* _tmp0_;
	UnityFilterSet* _tmp1_;
	UnityInternalUtilsAsyncMutex* _tmp2_;
	self = (UnityInternalScopeChannel*) g_object_new (object_type, NULL);
	self->channel_type = channel_type_;
	_tmp0_ = g_strdup_printf ("%p", self);
	_g_free0 (self->id);
	self->id = _tmp0_;
	_tmp1_ = unity_filter_set_new ();
	_g_object_unref0 (self->filters);
	self->filters = _tmp1_;
	_tmp2_ = unity_internal_utils_async_mutex_new ();
	_unity_internal_utils_async_mutex_unref0 (self->model_lock);
	self->model_lock = _tmp2_;
	return self;
}


UnityInternalScopeChannel*
unity_internal_scope_channel_new (UnityProtocolChannelType channel_type_)
{
	return unity_internal_scope_channel_construct (UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, channel_type_);
}


UnitySearchType
unity_internal_scope_channel_get_search_type (UnityInternalScopeChannel* self)
{
	UnitySearchType result = 0;
	UnitySearchType _tmp0_ = 0;
	UnityProtocolChannelType _tmp1_;
	UnitySearchType search_type = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = self->channel_type;
	if (_tmp1_ == UNITY_PROTOCOL_CHANNEL_TYPE_DEFAULT) {
		_tmp0_ = UNITY_SEARCH_TYPE_DEFAULT;
	} else {
		_tmp0_ = UNITY_SEARCH_TYPE_GLOBAL;
	}
	search_type = _tmp0_;
	result = search_type;
	return result;
}


static Block17Data*
block17_data_ref (Block17Data* _data17_)
{
	g_atomic_int_inc (&_data17_->_ref_count_);
	return _data17_;
}


static void
block17_data_unref (void * _userdata_)
{
	Block17Data* _data17_;
	_data17_ = (Block17Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data17_->_ref_count_)) {
		_g_hash_table_unref0 (_data17_->types);
		g_slice_free (Block17Data, _data17_);
	}
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
_g_variant_type_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL));
}


static void
__lambda10_ (Block17Data* _data17_,
             const gchar* field,
             const gchar* schema)
{
	gchar* _tmp0_;
	GVariantType* _tmp1_;
	g_return_if_fail (field != NULL);
	g_return_if_fail (schema != NULL);
	_tmp0_ = g_strdup (field);
	_tmp1_ = g_variant_type_new (schema);
	g_hash_table_insert (_data17_->types, _tmp0_, _tmp1_);
}


static void
___lambda10__gh_func (gconstpointer key,
                      gconstpointer value,
                      gpointer self)
{
	__lambda10_ (self, (const gchar*) key, (const gchar*) value);
}


static void
__lambda11_ (void)
{
}


static void
___lambda11__dee_filter_map_func (DeeModel* orig_model,
                                  DeeFilterModel* filter_model,
                                  void* data)
{
	__lambda11_ ();
}


static gboolean
__lambda12_ (Block17Data* _data17_,
             DeeModel* orig_model,
             DeeModelIter* iter,
             DeeFilterModel* filter_model)
{
	gboolean result = FALSE;
	GVariant* metadata = NULL;
	GVariant* _tmp0_;
	const gchar* field_name = NULL;
	const GVariantType* schema = NULL;
	GHashTableIter ht_iter = {0};
	g_return_val_if_fail (orig_model != NULL, FALSE);
	g_return_val_if_fail (iter != NULL, FALSE);
	g_return_val_if_fail (filter_model != NULL, FALSE);
	_tmp0_ = dee_model_get_value (orig_model, iter, UNITY_INTERNAL_SCOPE_CHANNEL_METADATA_COLUMN);
	metadata = _tmp0_;
	g_hash_table_iter_init (&ht_iter, _data17_->types);
	while (TRUE) {
		gconstpointer _tmp1_ = NULL;
		gconstpointer _tmp2_ = NULL;
		gboolean _tmp3_;
		GVariant* field = NULL;
		GVariant* _tmp4_;
		const gchar* _tmp5_;
		const GVariantType* _tmp6_;
		GVariant* _tmp7_;
		GVariant* _tmp8_;
		_tmp3_ = g_hash_table_iter_next (&ht_iter, (gpointer*) (&_tmp1_), (gpointer*) (&_tmp2_));
		field_name = _tmp1_;
		schema = _tmp2_;
		if (!_tmp3_) {
			break;
		}
		_tmp4_ = metadata;
		_tmp5_ = field_name;
		_tmp6_ = schema;
		_tmp7_ = g_variant_lookup_value (_tmp4_, _tmp5_, _tmp6_);
		field = _tmp7_;
		_tmp8_ = field;
		if (_tmp8_ == NULL) {
			const gchar* _tmp9_;
			_tmp9_ = field_name;
			g_warning ("unity-scope-channel.vala:109: Row doesn't contain required data: missi" \
"ng '%s'", _tmp9_);
			result = FALSE;
			_g_variant_unref0 (field);
			_g_variant_unref0 (metadata);
			return result;
		}
		_g_variant_unref0 (field);
	}
	dee_filter_model_insert_iter_with_original_order (filter_model, iter);
	result = TRUE;
	_g_variant_unref0 (metadata);
	return result;
}


static gboolean
___lambda12__dee_filter_map_notify (DeeModel* orig_model,
                                    DeeModelIter* orig_iter,
                                    DeeFilterModel* filter_model,
                                    gpointer self)
{
	gboolean result;
	result = __lambda12_ (self, orig_model, orig_iter, filter_model);
	return result;
}


static DeeSerializableModel*
unity_internal_scope_channel_create_filter_model (DeeModel* backend,
                                                  GHashTable* metadata_schema)
{
	DeeSerializableModel* result = NULL;
	Block17Data* _data17_;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	DeeFilterModel* model = NULL;
	DeeFilter _tmp3_ = {0};
	DeeFilterModel* _tmp4_;
	g_return_val_if_fail (backend != NULL, NULL);
	g_return_val_if_fail (metadata_schema != NULL, NULL);
	_data17_ = g_slice_new0 (Block17Data);
	_data17_->_ref_count_ = 1;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_variant_type_free0_);
	_data17_->types = _tmp2_;
	g_hash_table_foreach (metadata_schema, ___lambda10__gh_func, _data17_);
	dee_filter_new (___lambda11__dee_filter_map_func, ___lambda12__dee_filter_map_notify, block17_data_ref (_data17_), block17_data_unref, &_tmp3_);
	_tmp4_ = (DeeFilterModel*) dee_filter_model_new (backend, &_tmp3_);
	model = _tmp4_;
	result = (DeeSerializableModel*) model;
	block17_data_unref (_data17_);
	_data17_ = NULL;
	return result;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static DeeSerializableModel*
unity_internal_scope_channel_create_backend_model (UnityInternalScopeChannel* self,
                                                   GHashTable* metadata_schema,
                                                   gboolean no_filtering,
                                                   DeeSerializableModel* * real_backend)
{
	DeeSerializableModel* _vala_real_backend = NULL;
	DeeSerializableModel* result = NULL;
	DeeSequenceModel* backend = NULL;
	DeeSequenceModel* _tmp0_;
	DeeSequenceModel* _tmp1_;
	DeeSerializableModel* _tmp2_;
	gboolean _tmp3_ = FALSE;
	DeeSequenceModel* _tmp4_;
	DeeSerializableModel* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (metadata_schema != NULL, NULL);
	_tmp0_ = (DeeSequenceModel*) dee_sequence_model_new ();
	backend = _tmp0_;
	_tmp1_ = backend;
	_tmp2_ = _g_object_ref0 ((DeeSerializableModel*) _tmp1_);
	_g_object_unref0 (_vala_real_backend);
	_vala_real_backend = _tmp2_;
	if (no_filtering) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = g_hash_table_size (metadata_schema) == ((guint) 0);
	}
	if (_tmp3_) {
		result = (DeeSerializableModel*) backend;
		if (real_backend) {
			*real_backend = _vala_real_backend;
		} else {
			_g_object_unref0 (_vala_real_backend);
		}
		return result;
	}
	_tmp4_ = backend;
	_tmp5_ = unity_internal_scope_channel_create_filter_model ((DeeModel*) _tmp4_, metadata_schema);
	result = _tmp5_;
	_g_object_unref0 (backend);
	if (real_backend) {
		*real_backend = _vala_real_backend;
	} else {
		_g_object_unref0 (_vala_real_backend);
	}
	return result;
}


gchar*
unity_internal_scope_channel_create_channel (UnityInternalScopeChannel* self,
                                             const gchar* swarm_name,
                                             GHashTable* metadata_schema,
                                             GHashTable* optional_metadata,
                                             DeeSerializableModel* filter_model,
                                             UnityProtocolChannelFlags flags)
{
	gchar* result = NULL;
	const gchar* field_name = NULL;
	const gchar* schema = NULL;
	GHashTable* vardict_schema = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTableIter iter = {0};
	GType _tmp15_ = 0UL;
	GType peer_type = 0UL;
	DeePeer* peer = NULL;
	GType _tmp16_;
	GObject* _tmp17_;
	GObject* _tmp18_;
	DeePeer* _tmp19_;
	DeeModel* backend = NULL;
	DeeSerializableModel* _tmp20_ = NULL;
	DeeSerializableModel* _tmp21_;
	DeeSerializableModel* _tmp41_;
	DeeSerializableModel* _tmp42_;
	DeeSerializableModel* _tmp43_;
	GHashTable* _tmp44_;
	gchar* _tmp45_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (swarm_name != NULL, NULL);
	g_return_val_if_fail (metadata_schema != NULL, NULL);
	g_return_val_if_fail (optional_metadata != NULL, NULL);
	g_return_val_if_fail (filter_model != NULL, NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, NULL, NULL);
	vardict_schema = _tmp2_;
	g_hash_table_iter_init (&iter, optional_metadata);
	while (TRUE) {
		gconstpointer _tmp3_ = NULL;
		gconstpointer _tmp4_ = NULL;
		gboolean _tmp5_;
		GHashTable* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		_tmp5_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp3_), (gpointer*) (&_tmp4_));
		field_name = _tmp3_;
		schema = _tmp4_;
		if (!_tmp5_) {
			break;
		}
		_tmp6_ = vardict_schema;
		_tmp7_ = field_name;
		_tmp8_ = schema;
		g_hash_table_insert (_tmp6_, _tmp7_, _tmp8_);
	}
	g_hash_table_iter_init (&iter, metadata_schema);
	while (TRUE) {
		gconstpointer _tmp9_ = NULL;
		gconstpointer _tmp10_ = NULL;
		gboolean _tmp11_;
		GHashTable* _tmp12_;
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp11_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp9_), (gpointer*) (&_tmp10_));
		field_name = _tmp9_;
		schema = _tmp10_;
		if (!_tmp11_) {
			break;
		}
		_tmp12_ = vardict_schema;
		_tmp13_ = field_name;
		_tmp14_ = schema;
		g_hash_table_insert (_tmp12_, _tmp13_, _tmp14_);
	}
	if ((flags & UNITY_PROTOCOL_CHANNEL_FLAGS_PRIVATE) == UNITY_PROTOCOL_CHANNEL_FLAGS_PRIVATE) {
		_tmp15_ = dee_server_get_type ();
	} else {
		_tmp15_ = dee_peer_get_type ();
	}
	peer_type = _tmp15_;
	_tmp16_ = peer_type;
	_tmp17_ = g_object_new (_tmp16_, "swarm-name", swarm_name, "swarm-owner", TRUE, NULL);
	_tmp18_ = G_IS_INITIALLY_UNOWNED (_tmp17_) ? g_object_ref_sink (_tmp17_) : _tmp17_;
	_tmp19_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp18_, dee_peer_get_type ()) ? ((DeePeer*) _tmp18_) : NULL;
	if (_tmp19_ == NULL) {
		_g_object_unref0 (_tmp18_);
	}
	peer = _tmp19_;
	_tmp21_ = unity_internal_scope_channel_create_backend_model (self, metadata_schema, (flags & UNITY_PROTOCOL_CHANNEL_FLAGS_NO_FILTERING) == UNITY_PROTOCOL_CHANNEL_FLAGS_NO_FILTERING, &_tmp20_);
	_g_object_unref0 (self->backend_model);
	self->backend_model = _tmp20_;
	backend = (DeeModel*) _tmp21_;
	if ((flags & UNITY_PROTOCOL_CHANNEL_FLAGS_DIFF_CHANGES) == UNITY_PROTOCOL_CHANNEL_FLAGS_DIFF_CHANGES) {
		UnityInternalDiffModel* sm = NULL;
		DeePeer* _tmp22_;
		DeeModel* _tmp23_;
		UnityInternalDiffModel* _tmp24_;
		UnityInternalDiffModel* _tmp25_;
		UnityInternalDiffModel* _tmp26_;
		UnityInternalDiffModel* _tmp27_;
		UnityInternalDiffModel* _tmp28_;
		GHashTable* _tmp29_;
		UnityInternalDiffModel* _tmp30_;
		DeeSharedModel* _tmp31_;
		_tmp22_ = peer;
		_tmp23_ = backend;
		_tmp24_ = unity_internal_diff_model_new (_tmp22_, _tmp23_);
		sm = _tmp24_;
		_tmp25_ = sm;
		dee_shared_model_set_flush_mode ((DeeSharedModel*) _tmp25_, DEE_SHARED_MODEL_FLUSH_MODE_MANUAL);
		_tmp26_ = sm;
		dee_model_set_schema_full ((DeeModel*) _tmp26_, UNITY_INTERNAL_RESULTS_SCHEMA, (guint) G_N_ELEMENTS (UNITY_INTERNAL_RESULTS_SCHEMA));
		_tmp27_ = sm;
		dee_model_set_column_names_full ((DeeModel*) _tmp27_, UNITY_INTERNAL_RESULTS_COLUMN_NAMES, (guint) G_N_ELEMENTS (UNITY_INTERNAL_RESULTS_COLUMN_NAMES));
		_tmp28_ = sm;
		_tmp29_ = vardict_schema;
		dee_model_register_vardict_schema ((DeeModel*) _tmp28_, UNITY_INTERNAL_SCOPE_CHANNEL_METADATA_COLUMN, _tmp29_);
		_tmp30_ = sm;
		_tmp31_ = _g_object_ref0 ((DeeSharedModel*) _tmp30_);
		_g_object_unref0 (self->transfer_model);
		self->transfer_model = _tmp31_;
		_g_object_unref0 (sm);
	} else {
		DeeSharedModelAccessMode mode_flag = 0;
		DeeSharedModel* sm = NULL;
		DeePeer* _tmp32_;
		DeeModel* _tmp33_;
		DeeSharedModelAccessMode _tmp34_;
		GObject* _tmp35_;
		GObject* _tmp36_;
		DeeSharedModel* _tmp37_;
		DeeSharedModel* _tmp38_;
		DeeSharedModel* _tmp39_;
		DeeSharedModel* _tmp40_;
		mode_flag = DEE_SHARED_MODEL_ACCESS_MODE_LEADER_WRITABLE;
		_tmp32_ = peer;
		_tmp33_ = backend;
		_tmp34_ = mode_flag;
		_tmp35_ = g_object_new (dee_shared_model_get_type (), "peer", _tmp32_, "back-end", _tmp33_, "access-mode", _tmp34_, NULL);
		_tmp36_ = G_IS_INITIALLY_UNOWNED (_tmp35_) ? g_object_ref_sink (_tmp35_) : _tmp35_;
		_tmp37_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp36_, dee_shared_model_get_type ()) ? ((DeeSharedModel*) _tmp36_) : NULL;
		if (_tmp37_ == NULL) {
			_g_object_unref0 (_tmp36_);
		}
		sm = _tmp37_;
		_tmp38_ = sm;
		dee_shared_model_set_flush_mode (_tmp38_, DEE_SHARED_MODEL_FLUSH_MODE_MANUAL);
		_tmp39_ = sm;
		_tmp40_ = _g_object_ref0 (_tmp39_);
		_g_object_unref0 (self->transfer_model);
		self->transfer_model = _tmp40_;
		_g_object_unref0 (sm);
	}
	_tmp41_ = self->backend_model;
	dee_model_set_schema_full ((DeeModel*) _tmp41_, UNITY_INTERNAL_RESULTS_SCHEMA, (guint) G_N_ELEMENTS (UNITY_INTERNAL_RESULTS_SCHEMA));
	_tmp42_ = self->backend_model;
	dee_model_set_column_names_full ((DeeModel*) _tmp42_, UNITY_INTERNAL_RESULTS_COLUMN_NAMES, (guint) G_N_ELEMENTS (UNITY_INTERNAL_RESULTS_COLUMN_NAMES));
	_tmp43_ = self->backend_model;
	_tmp44_ = vardict_schema;
	dee_model_register_vardict_schema ((DeeModel*) _tmp43_, UNITY_INTERNAL_SCOPE_CHANNEL_METADATA_COLUMN, _tmp44_);
	unity_internal_scope_channel_set_filter_base (self, filter_model);
	_tmp45_ = g_strdup (swarm_name);
	result = _tmp45_;
	_g_object_unref0 (backend);
	_g_object_unref0 (peer);
	_g_hash_table_unref0 (vardict_schema);
	return result;
}


void
unity_internal_scope_channel_set_filter_base (UnityInternalScopeChannel* self,
                                              DeeSerializableModel* filter_model)
{
	UnityFilterSet* _tmp0_;
	DeeModelIter* fm_iter = NULL;
	DeeModelIter* _tmp1_;
	DeeModelIter* end_iter = NULL;
	DeeModelIter* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (filter_model != NULL);
	_tmp0_ = unity_filter_set_new ();
	_g_object_unref0 (self->filters);
	self->filters = _tmp0_;
	_tmp1_ = dee_model_get_first_iter ((DeeModel*) filter_model);
	fm_iter = _tmp1_;
	_tmp2_ = dee_model_get_last_iter ((DeeModel*) filter_model);
	end_iter = _tmp2_;
	while (TRUE) {
		DeeModelIter* _tmp3_;
		DeeModelIter* _tmp4_;
		UnityFilter* filter = NULL;
		DeeModelIter* _tmp5_;
		UnityFilter* _tmp6_;
		UnityFilter* _tmp7_;
		DeeModelIter* _tmp10_;
		DeeModelIter* _tmp11_;
		_tmp3_ = fm_iter;
		_tmp4_ = end_iter;
		if (!(_tmp3_ != _tmp4_)) {
			break;
		}
		_tmp5_ = fm_iter;
		_tmp6_ = unity_filter_for_filter_model_row ((DeeModel*) filter_model, _tmp5_);
		filter = _tmp6_;
		_tmp7_ = filter;
		if (_tmp7_ != NULL) {
			UnityFilterSet* _tmp8_;
			UnityFilter* _tmp9_;
			_tmp8_ = self->filters;
			_tmp9_ = filter;
			unity_filter_set_add (_tmp8_, _tmp9_);
		}
		_tmp10_ = fm_iter;
		_tmp11_ = dee_model_next ((DeeModel*) filter_model, _tmp10_);
		fm_iter = _tmp11_;
		_g_object_unref0 (filter);
	}
}


UnityFilter*
unity_internal_scope_channel_get_filter_by_id (UnityInternalScopeChannel* self,
                                               const gchar* filter_id)
{
	UnityFilter* result = NULL;
	UnityFilterSet* _tmp0_;
	UnityFilter* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filter_id != NULL, NULL);
	_tmp0_ = self->filters;
	_tmp1_ = unity_filter_set_get_filter_by_id (_tmp0_, filter_id);
	result = _tmp1_;
	return result;
}


static void
unity_internal_scope_channel_wait_for_search_data_free (gpointer _data)
{
	UnityInternalScopeChannelWaitForSearchData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeChannelWaitForSearchData, _data_);
}


static void
unity_internal_scope_channel_wait_for_search_async_ready_wrapper (GObject *source_object,
                                                                  GAsyncResult *res,
                                                                  void *user_data)
{
	UnityInternalScopeChannelWaitForSearchData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_internal_scope_channel_wait_for_search (UnityInternalScopeChannel* self,
                                              GAsyncReadyCallback _callback_,
                                              gpointer _user_data_)
{
	UnityInternalScopeChannelWaitForSearchData* _data_;
	UnityInternalScopeChannel* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalScopeChannelWaitForSearchData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, unity_internal_scope_channel_wait_for_search_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_channel_wait_for_search_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	unity_internal_scope_channel_wait_for_search_co (_data_);
}


void
unity_internal_scope_channel_wait_for_search_finish (UnityInternalScopeChannel* self,
                                                     GAsyncResult* _res_)
{
	UnityInternalScopeChannelWaitForSearchData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}


static gboolean
_unity_internal_scope_channel_wait_for_search_co_gsource_func (gpointer self)
{
	gboolean result;
	result = unity_internal_scope_channel_wait_for_search_co (self);
	return result;
}


static void
_vala_array_add3 (UnityInternalUtilsDelegateWrapper** * array,
                  int* length,
                  int* size,
                  UnityInternalUtilsDelegateWrapper* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (UnityInternalUtilsDelegateWrapper*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean
unity_internal_scope_channel_wait_for_search_co (UnityInternalScopeChannelWaitForSearchData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->last_search;
	if (_data_->_tmp0_ == NULL) {
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp1_ = _data_->self->priv->callbacks;
	_data_->_tmp1__length1 = _data_->self->priv->callbacks_length1;
	_data_->_tmp2_ = unity_internal_utils_delegate_wrapper_new (_unity_internal_scope_channel_wait_for_search_co_gsource_func, _data_, NULL);
	_vala_array_add3 (&_data_->self->priv->callbacks, &_data_->self->priv->callbacks_length1, &_data_->self->priv->_callbacks_size_, _data_->_tmp2_);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void
unity_internal_scope_channel_set_state (UnityInternalScopeChannel* self,
                                        UnityInternalChannelState new_state)
{
	UnityInternalChannelState _tmp0_;
	UnityInternalChannelState old_state = 0;
	UnityInternalChannelState _tmp3_;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state;
	if (new_state == _tmp0_) {
		const gchar* _tmp1_;
		GEnumValue* _tmp2_;
		_tmp1_ = self->id;
		_tmp2_ = g_enum_get_value (g_type_class_ref (UNITY_INTERNAL_TYPE_CHANNEL_STATE), new_state);
		g_warning ("unity-scope-channel.vala:241: channel \"%s\", trying to change state t" \
"o %s", _tmp1_, (_tmp2_ != NULL) ? _tmp2_->value_name : NULL);
		return;
	}
	_tmp3_ = self->priv->state;
	old_state = _tmp3_;
	self->priv->state = new_state;
	if (new_state == UNITY_INTERNAL_CHANNEL_STATE_IDLE) {
		UnityInternalChannelState _tmp5_;
		_tmp5_ = old_state;
		_tmp4_ = _tmp5_ == UNITY_INTERNAL_CHANNEL_STATE_SEARCH_ACTIVE;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		UnityInternalUtilsDelegateWrapper** _tmp6_;
		gint _tmp6__length1;
		UnityInternalUtilsDelegateWrapper** _tmp9_;
		_tmp6_ = self->priv->callbacks;
		_tmp6__length1 = self->priv->callbacks_length1;
		{
			UnityInternalUtilsDelegateWrapper** wrapper_collection = NULL;
			gint wrapper_collection_length1 = 0;
			gint _wrapper_collection_size_ = 0;
			gint wrapper_it = 0;
			wrapper_collection = _tmp6_;
			wrapper_collection_length1 = _tmp6__length1;
			for (wrapper_it = 0; wrapper_it < _tmp6__length1; wrapper_it = wrapper_it + 1) {
				UnityInternalUtilsDelegateWrapper* wrapper = NULL;
				wrapper = wrapper_collection[wrapper_it];
				{
					UnityInternalUtilsDelegateWrapper* _tmp7_;
					GSourceFunc _tmp8_;
					void* _tmp8__target;
					_tmp7_ = wrapper;
					_tmp8_ = _tmp7_->callback;
					_tmp8__target = _tmp7_->callback_target;
					_tmp8_ (_tmp8__target);
				}
			}
		}
		_tmp9_ = g_new0 (UnityInternalUtilsDelegateWrapper*, 0 + 1);
		self->priv->callbacks = (_vala_array_free (self->priv->callbacks, self->priv->callbacks_length1, (GDestroyNotify) unity_internal_utils_delegate_wrapper_free), NULL);
		self->priv->callbacks = _tmp9_;
		self->priv->callbacks_length1 = 0;
		self->priv->_callbacks_size_ = self->priv->callbacks_length1;
	}
}


gboolean
unity_internal_scope_channel_is_search_running (UnityInternalScopeChannel* self)
{
	gboolean result = FALSE;
	UnityInternalChannelState _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->state;
	result = _tmp0_ == UNITY_INTERNAL_CHANNEL_STATE_SEARCH_ACTIVE;
	return result;
}


guint64
unity_internal_scope_channel_get_last_seqnum (UnityInternalScopeChannel* self)
{
	guint64 result = 0ULL;
	DeeSharedModel* _tmp0_;
	DeeSerializableModel* _tmp4_;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->transfer_model;
	if (_tmp0_ != NULL) {
		DeeSharedModel* _tmp1_;
		DeeSharedModel* _tmp3_;
		_tmp1_ = self->transfer_model;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, UNITY_INTERNAL_TYPE_DIFF_MODEL)) {
			DeeSharedModel* _tmp2_;
			_tmp2_ = self->transfer_model;
			unity_internal_diff_model_commit_changes (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, UNITY_INTERNAL_TYPE_DIFF_MODEL) ? ((UnityInternalDiffModel*) _tmp2_) : NULL);
		}
		_tmp3_ = self->transfer_model;
		result = dee_serializable_model_get_seqnum ((DeeSerializableModel*) _tmp3_);
		return result;
	}
	_tmp4_ = self->backend_model;
	result = dee_serializable_model_get_seqnum (_tmp4_);
	return result;
}


void
unity_internal_scope_channel_register_pushed_model (UnityInternalScopeChannel* self,
                                                    const gchar* search_string,
                                                    DeeSerializableModel* model)
{
	const gchar* _tmp0_;
	DeeSerializableModel* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (search_string != NULL);
	g_return_if_fail (model != NULL);
	_tmp0_ = self->priv->last_push_search_string;
	if (g_strcmp0 (search_string, _tmp0_) != 0) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup (search_string);
		_g_free0 (self->priv->last_push_search_string);
		self->priv->last_push_search_string = _tmp1_;
		(self->priv->pushed_models == NULL) ? NULL : (self->priv->pushed_models = (_g_list_free__g_object_unref0_ (self->priv->pushed_models), NULL));
		self->priv->pushed_models = NULL;
	}
	_tmp2_ = _g_object_ref0 (model);
	self->priv->pushed_models = g_list_append (self->priv->pushed_models, _tmp2_);
}


GList*
unity_internal_scope_channel_get_pushed_models (UnityInternalScopeChannel* self,
                                                const gchar* search_string)
{
	GList* result = NULL;
	const gchar* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (search_string != NULL, NULL);
	_tmp0_ = self->priv->last_push_search_string;
	if (g_strcmp0 (_tmp0_, search_string) != 0) {
		result = NULL;
		return result;
	}
	_tmp1_ = self->priv->pushed_models;
	_tmp2_ = g_list_copy (_tmp1_);
	result = _tmp2_;
	return result;
}


void
unity_internal_scope_channel_watch_owner (UnityInternalScopeChannel* self,
                                          GDBusConnection* connection,
                                          const char* owner)
{
	UnityInternalScopeChannelOwnerWatcher* _tmp0_;
	UnityInternalScopeChannelOwnerWatcher* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (owner != NULL);
	_tmp0_ = self->priv->watcher;
	if (_tmp0_ != NULL) {
		UnityInternalScopeChannelOwnerWatcher* _tmp1_;
		_tmp1_ = self->priv->watcher;
		unity_internal_scope_channel_owner_watcher_unwatch (_tmp1_);
	}
	_tmp2_ = unity_internal_scope_channel_owner_watcher_new (self, connection, owner);
	_unity_internal_scope_channel_owner_watcher_unref0 (self->priv->watcher);
	self->priv->watcher = _tmp2_;
}


static void
_unity_internal_scope_channel_owner_watcher_owner_changed_gd_bus_signal_callback (GDBusConnection* connection,
                                                                                  const gchar* sender_name,
                                                                                  const gchar* object_path,
                                                                                  const gchar* interface_name,
                                                                                  const gchar* signal_name,
                                                                                  GVariant* parameters,
                                                                                  gpointer self)
{
	unity_internal_scope_channel_owner_watcher_owner_changed ((UnityInternalScopeChannelOwnerWatcher*) self, connection, sender_name, object_path, interface_name, signal_name, parameters);
}


static UnityInternalScopeChannelOwnerWatcher*
unity_internal_scope_channel_owner_watcher_construct (GType object_type,
                                                      UnityInternalScopeChannel* channel,
                                                      GDBusConnection* connection,
                                                      const char* owner)
{
	UnityInternalScopeChannelOwnerWatcher* self = NULL;
	GDBusConnection* _tmp0_;
	GDBusConnection* _tmp1_;
	g_return_val_if_fail (channel != NULL, NULL);
	g_return_val_if_fail (connection != NULL, NULL);
	g_return_val_if_fail (owner != NULL, NULL);
	self = (UnityInternalScopeChannelOwnerWatcher*) g_type_create_instance (object_type);
	self->priv->owner_channel = channel;
	_tmp0_ = _g_object_ref0 (connection);
	_g_object_unref0 (self->priv->dbus_connection);
	self->priv->dbus_connection = _tmp0_;
	_tmp1_ = self->priv->dbus_connection;
	self->priv->owner_changed_signal_id = g_dbus_connection_signal_subscribe (_tmp1_, NULL, "org.freedesktop.DBus", "NameOwnerChanged", NULL, (const gchar*) owner, G_DBUS_SIGNAL_FLAGS_NONE, _unity_internal_scope_channel_owner_watcher_owner_changed_gd_bus_signal_callback, unity_internal_scope_channel_owner_watcher_ref (self), unity_internal_scope_channel_owner_watcher_unref);
	return self;
}


static UnityInternalScopeChannelOwnerWatcher*
unity_internal_scope_channel_owner_watcher_new (UnityInternalScopeChannel* channel,
                                                GDBusConnection* connection,
                                                const char* owner)
{
	return unity_internal_scope_channel_owner_watcher_construct (UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER, channel, connection, owner);
}


static void
unity_internal_scope_channel_owner_watcher_owner_changed (UnityInternalScopeChannelOwnerWatcher* self,
                                                          GDBusConnection* con,
                                                          const gchar* sender_name,
                                                          const gchar* obj_path,
                                                          const gchar* ifc_name,
                                                          const gchar* sig_name,
                                                          GVariant* parameters)
{
	gchar* new_owner = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (con != NULL);
	g_return_if_fail (sender_name != NULL);
	g_return_if_fail (obj_path != NULL);
	g_return_if_fail (ifc_name != NULL);
	g_return_if_fail (sig_name != NULL);
	g_return_if_fail (parameters != NULL);
	_tmp0_ = g_variant_get_child_value (parameters, (gsize) 2);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_variant_get_string (_tmp1_, NULL);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_variant_unref0 (_tmp1_);
	new_owner = _tmp4_;
	_tmp5_ = new_owner;
	if (g_strcmp0 (_tmp5_, "") == 0) {
		UnityInternalScopeChannel* _tmp6_;
		_tmp6_ = self->priv->owner_channel;
		g_signal_emit (_tmp6_, unity_internal_scope_channel_signals[UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_LOST_SIGNAL], 0);
	}
	_g_free0 (new_owner);
}


static void
unity_internal_scope_channel_owner_watcher_unwatch (UnityInternalScopeChannelOwnerWatcher* self)
{
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->owner_changed_signal_id;
	if (_tmp0_ != ((guint) 0)) {
		GDBusConnection* _tmp1_;
		guint _tmp2_;
		_tmp1_ = self->priv->dbus_connection;
		_tmp2_ = self->priv->owner_changed_signal_id;
		g_dbus_connection_signal_unsubscribe (_tmp1_, _tmp2_);
		self->priv->owner_changed_signal_id = (guint) 0;
	}
}


static void
unity_internal_scope_channel_value_owner_watcher_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}


static void
unity_internal_scope_channel_value_owner_watcher_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		unity_internal_scope_channel_owner_watcher_unref (value->data[0].v_pointer);
	}
}


static void
unity_internal_scope_channel_value_owner_watcher_copy_value (const GValue* src_value,
                                                             GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_internal_scope_channel_owner_watcher_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer
unity_internal_scope_channel_value_owner_watcher_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}


static gchar*
unity_internal_scope_channel_value_owner_watcher_collect_value (GValue* value,
                                                                guint n_collect_values,
                                                                GTypeCValue* collect_values,
                                                                guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		UnityInternalScopeChannelOwnerWatcher * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_internal_scope_channel_owner_watcher_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar*
unity_internal_scope_channel_value_owner_watcher_lcopy_value (const GValue* value,
                                                              guint n_collect_values,
                                                              GTypeCValue* collect_values,
                                                              guint collect_flags)
{
	UnityInternalScopeChannelOwnerWatcher ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_internal_scope_channel_owner_watcher_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec*
unity_internal_scope_channel_param_spec_owner_watcher (const gchar* name,
                                                       const gchar* nick,
                                                       const gchar* blurb,
                                                       GType object_type,
                                                       GParamFlags flags)
{
	UnityInternalScopeChannelParamSpecOwnerWatcher* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer
unity_internal_scope_channel_value_get_owner_watcher (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER), NULL);
	return value->data[0].v_pointer;
}


static void
unity_internal_scope_channel_value_set_owner_watcher (GValue* value,
                                                      gpointer v_object)
{
	UnityInternalScopeChannelOwnerWatcher * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_internal_scope_channel_owner_watcher_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_internal_scope_channel_owner_watcher_unref (old);
	}
}


static void
unity_internal_scope_channel_value_take_owner_watcher (GValue* value,
                                                       gpointer v_object)
{
	UnityInternalScopeChannelOwnerWatcher * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_internal_scope_channel_owner_watcher_unref (old);
	}
}


static void
unity_internal_scope_channel_owner_watcher_class_init (UnityInternalScopeChannelOwnerWatcherClass * klass)
{
	unity_internal_scope_channel_owner_watcher_parent_class = g_type_class_peek_parent (klass);
	((UnityInternalScopeChannelOwnerWatcherClass *) klass)->finalize = unity_internal_scope_channel_owner_watcher_finalize;
	g_type_class_add_private (klass, sizeof (UnityInternalScopeChannelOwnerWatcherPrivate));
}


static void
unity_internal_scope_channel_owner_watcher_instance_init (UnityInternalScopeChannelOwnerWatcher * self)
{
	self->priv = UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_WATCHER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void
unity_internal_scope_channel_owner_watcher_finalize (UnityInternalScopeChannelOwnerWatcher * obj)
{
	UnityInternalScopeChannelOwnerWatcher * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_INTERNAL_SCOPE_CHANNEL_TYPE_OWNER_WATCHER, UnityInternalScopeChannelOwnerWatcher);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->dbus_connection);
}


static GType
unity_internal_scope_channel_owner_watcher_get_type (void)
{
	static volatile gsize unity_internal_scope_channel_owner_watcher_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_scope_channel_owner_watcher_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_internal_scope_channel_value_owner_watcher_init, unity_internal_scope_channel_value_owner_watcher_free_value, unity_internal_scope_channel_value_owner_watcher_copy_value, unity_internal_scope_channel_value_owner_watcher_peek_pointer, "p", unity_internal_scope_channel_value_owner_watcher_collect_value, "p", unity_internal_scope_channel_value_owner_watcher_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityInternalScopeChannelOwnerWatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_internal_scope_channel_owner_watcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityInternalScopeChannelOwnerWatcher), 0, (GInstanceInitFunc) unity_internal_scope_channel_owner_watcher_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_internal_scope_channel_owner_watcher_type_id;
		unity_internal_scope_channel_owner_watcher_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityInternalScopeChannelOwnerWatcher", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_internal_scope_channel_owner_watcher_type_id__volatile, unity_internal_scope_channel_owner_watcher_type_id);
	}
	return unity_internal_scope_channel_owner_watcher_type_id__volatile;
}


static gpointer
unity_internal_scope_channel_owner_watcher_ref (gpointer instance)
{
	UnityInternalScopeChannelOwnerWatcher * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void
unity_internal_scope_channel_owner_watcher_unref (gpointer instance)
{
	UnityInternalScopeChannelOwnerWatcher * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_WATCHER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void
unity_internal_scope_channel_class_init (UnityInternalScopeChannelClass * klass)
{
	unity_internal_scope_channel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityInternalScopeChannelPrivate));
	G_OBJECT_CLASS (klass)->finalize = unity_internal_scope_channel_finalize;
	unity_internal_scope_channel_signals[UNITY_INTERNAL_SCOPE_CHANNEL_OWNER_LOST_SIGNAL] = g_signal_new ("owner-lost", UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void
unity_internal_scope_channel_instance_init (UnityInternalScopeChannel * self)
{
	UnityInternalUtilsDelegateWrapper** _tmp0_;
	self->priv = UNITY_INTERNAL_SCOPE_CHANNEL_GET_PRIVATE (self);
	_tmp0_ = g_new0 (UnityInternalUtilsDelegateWrapper*, 0 + 1);
	self->priv->callbacks = _tmp0_;
	self->priv->callbacks_length1 = 0;
	self->priv->_callbacks_size_ = self->priv->callbacks_length1;
	self->priv->pushed_models = NULL;
}


static void
unity_internal_scope_channel_finalize (GObject * obj)
{
	UnityInternalScopeChannel * self;
	UnityInternalScopeChannelOwnerWatcher* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannel);
	_tmp0_ = self->priv->watcher;
	if (_tmp0_ != NULL) {
		UnityInternalScopeChannelOwnerWatcher* _tmp1_;
		_tmp1_ = self->priv->watcher;
		unity_internal_scope_channel_owner_watcher_unwatch (_tmp1_);
	}
	_unity_internal_utils_async_mutex_unref0 (self->model_lock);
	_g_object_unref0 (self->transfer_model);
	_g_object_unref0 (self->backend_model);
	_g_object_unref0 (self->filters);
	_g_free0 (self->id);
	_g_object_unref0 (self->last_search);
	self->priv->callbacks = (_vala_array_free (self->priv->callbacks, self->priv->callbacks_length1, (GDestroyNotify) unity_internal_utils_delegate_wrapper_free), NULL);
	_g_free0 (self->priv->last_push_search_string);
	(self->priv->pushed_models == NULL) ? NULL : (self->priv->pushed_models = (_g_list_free__g_object_unref0_ (self->priv->pushed_models), NULL));
	_unity_internal_scope_channel_owner_watcher_unref0 (self->priv->watcher);
	G_OBJECT_CLASS (unity_internal_scope_channel_parent_class)->finalize (obj);
}


GType
unity_internal_scope_channel_get_type (void)
{
	static volatile gsize unity_internal_scope_channel_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_scope_channel_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityInternalScopeChannelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_internal_scope_channel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityInternalScopeChannel), 0, (GInstanceInitFunc) unity_internal_scope_channel_instance_init, NULL };
		GType unity_internal_scope_channel_type_id;
		unity_internal_scope_channel_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityInternalScopeChannel", &g_define_type_info, 0);
		g_once_init_leave (&unity_internal_scope_channel_type_id__volatile, unity_internal_scope_channel_type_id);
	}
	return unity_internal_scope_channel_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



