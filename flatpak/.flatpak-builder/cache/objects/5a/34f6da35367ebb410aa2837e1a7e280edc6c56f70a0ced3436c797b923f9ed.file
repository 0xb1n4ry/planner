/* debug.c generated by valac 0.40.11, the Vala compiler
 * generated from debug.vala, do not modify */

/*
 * Copyright (C) 2010 Collabora Ltd.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *       Philip Withnall <philip.withnall@collabora.co.uk>
 */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <stdio.h>
#include <stdarg.h>


#define FOLKS_TYPE_DEBUG (folks_debug_get_type ())
#define FOLKS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_DEBUG, FolksDebug))
#define FOLKS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_DEBUG, FolksDebugClass))
#define FOLKS_IS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_DEBUG))
#define FOLKS_IS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_DEBUG))
#define FOLKS_DEBUG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_DEBUG, FolksDebugClass))

typedef struct _FolksDebug FolksDebug;
typedef struct _FolksDebugClass FolksDebugClass;
typedef struct _FolksDebugPrivate FolksDebugPrivate;
enum  {
	FOLKS_DEBUG_0_PROPERTY,
	FOLKS_DEBUG_COLOUR_ENABLED_PROPERTY,
	FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED_PROPERTY,
	FOLKS_DEBUG_NUM_PROPERTIES
};
static GParamSpec* folks_debug_properties[FOLKS_DEBUG_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FOLKS_DEBUG_TYPE_DOMAINS (folks_debug_domains_get_type ())

#define FOLKS_DEBUG_TYPE_KEY_VALUE_PAIR (folks_debug_key_value_pair_get_type ())
typedef struct _FolksDebugKeyValuePair FolksDebugKeyValuePair;
enum  {
	FOLKS_DEBUG_PRINT_STATUS_SIGNAL,
	FOLKS_DEBUG_NUM_SIGNALS
};
static guint folks_debug_signals[FOLKS_DEBUG_NUM_SIGNALS] = {0};

struct _FolksDebug {
	GObject parent_instance;
	FolksDebugPrivate * priv;
};

struct _FolksDebugClass {
	GObjectClass parent_class;
};

struct _FolksDebugPrivate {
	GeeHashSet* _domains;
	gboolean _all;
	guint _indentation;
	gchar* _indentation_string;
	gboolean _colour_enabled;
	GeeHashSet* _domains_handled;
	gboolean _debug_output_enabled;
};

typedef enum  {
	FOLKS_DEBUG_DOMAINS_CORE = 1 << 0,
	FOLKS_DEBUG_DOMAINS_TELEPATHY_BACKEND = 1 << 1,
	FOLKS_DEBUG_DOMAINS_KEY_FILE_BACKEND = 1 << 2
} FolksDebugDomains;

struct _FolksDebugKeyValuePair {
	gchar* key;
	gchar* val;
};


static gpointer folks_debug_parent_class = NULL;
static FolksDebug* folks_debug__instance;
static FolksDebug* folks_debug__instance = NULL;

void g_log (const gchar* log_domain,
            GLogLevelFlags log_level,
            const gchar* format,
            ...) G_GNUC_PRINTF(3,4);
GType folks_debug_get_type (void) G_GNUC_CONST;
#define FOLKS_DEBUG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FOLKS_TYPE_DEBUG, FolksDebugPrivate))
static void _folks_debug_remove_handler (FolksDebug* self,
                                  const gchar* domain,
                                  gboolean keep_in_map);
static GType folks_debug_domains_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define FOLKS_DEBUG_STATUS_LOG_DOMAIN "folks-status"
static void _folks_debug_print_status_log_handler_cb (FolksDebug* self,
                                               const gchar* log_domain,
                                               GLogLevelFlags log_levels,
                                               const gchar* message);
static void _folks_debug_log_handler_cb (FolksDebug* self,
                                  const gchar* log_domain,
                                  GLogLevelFlags log_levels,
                                  const gchar* message);
gboolean folks_debug_get_debug_output_enabled (FolksDebug* self);
void _folks_debug_register_domain (FolksDebug* self,
                                   const gchar* domain);
static void _folks_debug_set_handler (FolksDebug* self,
                               const gchar* domain,
                               GLogLevelFlags flags,
                               GLogFunc log_func,
                               gpointer log_func_target);
static void __folks_debug_log_handler_cb_glog_func (const gchar* log_domain,
                                             GLogLevelFlags log_levels,
                                             const gchar* message,
                                             gpointer self);
static void __lambda65_ (FolksDebug* self,
                  const gchar* domain_arg,
                  GLogLevelFlags flags,
                  const gchar* message);
static void ___lambda65__glog_func (const gchar* log_domain,
                             GLogLevelFlags log_levels,
                             const gchar* message,
                             gpointer self);
FolksDebug* folks_debug_dup (void);
static FolksDebug* folks_debug_new (void);
static FolksDebug* folks_debug_construct (GType object_type);
FolksDebug* folks_debug_dup_with_flags (const gchar* debug_flags,
                                        gboolean colour_enabled);
void folks_debug_set_debug_output_enabled (FolksDebug* self,
                                           gboolean value);
void folks_debug_set_colour_enabled (FolksDebug* self,
                                     gboolean value);
void folks_debug_emit_print_status (FolksDebug* self);
void folks_debug_indent (FolksDebug* self);
void folks_debug_unindent (FolksDebug* self);
void folks_debug_print_line (FolksDebug* self,
                             const gchar* domain,
                             GLogLevelFlags level,
                             const gchar* format,
                             ...) G_GNUC_PRINTF(4,5);
void folks_debug_print_heading (FolksDebug* self,
                                const gchar* domain,
                                GLogLevelFlags level,
                                const gchar* format,
                                ...) G_GNUC_PRINTF(4,5);
gboolean folks_debug_get_colour_enabled (FolksDebug* self);
static gchar* _folks_debug_format_nullable_string (FolksDebug* self,
                                            const gchar* input);
void folks_debug_print_key_value_pairs (FolksDebug* self,
                                        const gchar* domain,
                                        GLogLevelFlags level,
                                        ...);
static GType folks_debug_key_value_pair_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static FolksDebugKeyValuePair* folks_debug_key_value_pair_dup (const FolksDebugKeyValuePair* self);
static void folks_debug_key_value_pair_free (FolksDebugKeyValuePair* self);
static void folks_debug_key_value_pair_copy (const FolksDebugKeyValuePair* self,
                                      FolksDebugKeyValuePair* dest);
static void folks_debug_key_value_pair_destroy (FolksDebugKeyValuePair* self);
static void _vala_array_add1 (FolksDebugKeyValuePair* * array,
                       int* length,
                       int* size,
                       const FolksDebugKeyValuePair* value);
static void _vala_FolksDebugKeyValuePair_array_free (FolksDebugKeyValuePair * array,
                                              gint array_length);
static GObject * folks_debug_constructor (GType type,
                                   guint n_construct_properties,
                                   GObjectConstructParam * construct_properties);
static void __folks_debug_print_status_log_handler_cb_glog_func (const gchar* log_domain,
                                                          GLogLevelFlags log_levels,
                                                          const gchar* message,
                                                          gpointer self);
static void folks_debug_finalize (GObject * obj);
static void _vala_folks_debug_get_property (GObject * object,
                                     guint property_id,
                                     GValue * value,
                                     GParamSpec * pspec);
static void _vala_folks_debug_set_property (GObject * object,
                                     guint property_id,
                                     const GValue * value,
                                     GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static GType
folks_debug_domains_get_type (void)
{
	static volatile gsize folks_debug_domains_type_id__volatile = 0;
	if (g_once_init_enter (&folks_debug_domains_type_id__volatile)) {
		static const GEnumValue values[] = {{FOLKS_DEBUG_DOMAINS_CORE, "FOLKS_DEBUG_DOMAINS_CORE", "core"}, {FOLKS_DEBUG_DOMAINS_TELEPATHY_BACKEND, "FOLKS_DEBUG_DOMAINS_TELEPATHY_BACKEND", "telepathy-backend"}, {FOLKS_DEBUG_DOMAINS_KEY_FILE_BACKEND, "FOLKS_DEBUG_DOMAINS_KEY_FILE_BACKEND", "key-file-backend"}, {0, NULL, NULL}};
		GType folks_debug_domains_type_id;
		folks_debug_domains_type_id = g_enum_register_static ("FolksDebugDomains", values);
		g_once_init_leave (&folks_debug_domains_type_id__volatile, folks_debug_domains_type_id);
	}
	return folks_debug_domains_type_id__volatile;
}


static void
_folks_debug_print_status_log_handler_cb (FolksDebug* self,
                                          const gchar* log_domain,
                                          GLogLevelFlags log_levels,
                                          const gchar* message)
{
	FILE* _tmp0_;
#line 132 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 132 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (message != NULL);
#line 137 "/run/build/folks/folks/debug.vala"
	_tmp0_ = stdout;
#line 137 "/run/build/folks/folks/debug.vala"
	fprintf (_tmp0_, "%s\n", message);
#line 234 "debug.c"
}


static void
_folks_debug_log_handler_cb (FolksDebug* self,
                             const gchar* log_domain,
                             GLogLevelFlags log_levels,
                             const gchar* message)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	GLogFunc _tmp2_;
	void* _tmp2__target;
#line 140 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 140 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (message != NULL);
#line 144 "/run/build/folks/folks/debug.vala"
	_tmp0_ = folks_debug_get_debug_output_enabled (self);
#line 144 "/run/build/folks/folks/debug.vala"
	_tmp1_ = _tmp0_;
#line 144 "/run/build/folks/folks/debug.vala"
	if (_tmp1_ == FALSE) {
#line 148 "/run/build/folks/folks/debug.vala"
		return;
#line 260 "debug.c"
	}
#line 152 "/run/build/folks/folks/debug.vala"
	_tmp2_ = g_log_default_handler;
#line 152 "/run/build/folks/folks/debug.vala"
	_tmp2__target = NULL;
#line 152 "/run/build/folks/folks/debug.vala"
	_tmp2_ (log_domain, log_levels, message, _tmp2__target);
#line 268 "debug.c"
}


static void
__folks_debug_log_handler_cb_glog_func (const gchar* log_domain,
                                        GLogLevelFlags log_levels,
                                        const gchar* message,
                                        gpointer self)
{
#line 161 "/run/build/folks/folks/debug.vala"
	_folks_debug_log_handler_cb ((FolksDebug*) self, log_domain, log_levels, message);
#line 280 "debug.c"
}


static void
__lambda65_ (FolksDebug* self,
             const gchar* domain_arg,
             GLogLevelFlags flags,
             const gchar* message)
{
#line 169 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (message != NULL);
#line 292 "debug.c"
}


static void
___lambda65__glog_func (const gchar* log_domain,
                        GLogLevelFlags log_levels,
                        const gchar* message,
                        gpointer self)
{
#line 168 "/run/build/folks/folks/debug.vala"
	__lambda65_ ((FolksDebug*) self, log_domain, log_levels, message);
#line 304 "debug.c"
}


void
_folks_debug_register_domain (FolksDebug* self,
                              const gchar* domain)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
#line 157 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 157 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (domain != NULL);
#line 159 "/run/build/folks/folks/debug.vala"
	_tmp1_ = self->priv->_all;
#line 159 "/run/build/folks/folks/debug.vala"
	if (_tmp1_) {
#line 159 "/run/build/folks/folks/debug.vala"
		_tmp0_ = TRUE;
#line 324 "debug.c"
	} else {
		GeeHashSet* _tmp2_;
		gchar* _tmp3_;
		gchar* _tmp4_;
#line 159 "/run/build/folks/folks/debug.vala"
		_tmp2_ = self->priv->_domains;
#line 159 "/run/build/folks/folks/debug.vala"
		_tmp3_ = g_utf8_strdown (domain, (gssize) -1);
#line 159 "/run/build/folks/folks/debug.vala"
		_tmp4_ = _tmp3_;
#line 159 "/run/build/folks/folks/debug.vala"
		_tmp0_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp2_, _tmp4_);
#line 159 "/run/build/folks/folks/debug.vala"
		_g_free0 (_tmp4_);
#line 339 "debug.c"
	}
#line 159 "/run/build/folks/folks/debug.vala"
	if (_tmp0_) {
#line 161 "/run/build/folks/folks/debug.vala"
		_folks_debug_set_handler (self, domain, G_LOG_LEVEL_MASK, __folks_debug_log_handler_cb_glog_func, self);
#line 163 "/run/build/folks/folks/debug.vala"
		return;
#line 347 "debug.c"
	}
#line 168 "/run/build/folks/folks/debug.vala"
	_folks_debug_set_handler (self, domain, G_LOG_LEVEL_DEBUG, ___lambda65__glog_func, self);
#line 351 "debug.c"
}


/**
   * Create or return the singleton {@link Folks.Debug} class instance.
   * If the instance doesn't exist already, it will be created with no debug
   * domains enabled.
   *
   * This function is thread-safe.
   *
   * @return  Singleton {@link Folks.Debug} instance
   * @since 0.5.1
   */
static gpointer
_g_object_ref0 (gpointer self)
{
#line 184 "/run/build/folks/folks/debug.vala"
	return self ? g_object_ref (self) : NULL;
#line 370 "debug.c"
}


FolksDebug*
folks_debug_dup (void)
{
	FolksDebug* result = NULL;
	FolksDebug* _retval = NULL;
	FolksDebug* _tmp0_;
	FolksDebug* _tmp1_;
	FolksDebug* retval = NULL;
	FolksDebug* _tmp2_;
#line 184 "/run/build/folks/folks/debug.vala"
	_tmp0_ = folks_debug__instance;
#line 184 "/run/build/folks/folks/debug.vala"
	_tmp1_ = _g_object_ref0 (_tmp0_);
#line 184 "/run/build/folks/folks/debug.vala"
	_retval = _tmp1_;
#line 187 "/run/build/folks/folks/debug.vala"
	_tmp2_ = _retval;
#line 187 "/run/build/folks/folks/debug.vala"
	if (_tmp2_ == NULL) {
#line 393 "debug.c"
		FolksDebug* _tmp3_;
		FolksDebug* _tmp4_;
#line 190 "/run/build/folks/folks/debug.vala"
		_tmp3_ = folks_debug_new ();
#line 190 "/run/build/folks/folks/debug.vala"
		_g_object_unref0 (retval);
#line 190 "/run/build/folks/folks/debug.vala"
		retval = _tmp3_;
#line 191 "/run/build/folks/folks/debug.vala"
		_tmp4_ = retval;
#line 191 "/run/build/folks/folks/debug.vala"
		folks_debug__instance = _tmp4_;
#line 406 "debug.c"
	} else {
		FolksDebug* _tmp5_;
		FolksDebug* _tmp6_;
#line 195 "/run/build/folks/folks/debug.vala"
		_tmp5_ = _retval;
#line 195 "/run/build/folks/folks/debug.vala"
		_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, FOLKS_TYPE_DEBUG, FolksDebug));
#line 195 "/run/build/folks/folks/debug.vala"
		_g_object_unref0 (retval);
#line 195 "/run/build/folks/folks/debug.vala"
		retval = _tmp6_;
#line 418 "debug.c"
	}
#line 198 "/run/build/folks/folks/debug.vala"
	result = retval;
#line 198 "/run/build/folks/folks/debug.vala"
	_g_object_unref0 (_retval);
#line 198 "/run/build/folks/folks/debug.vala"
	return result;
#line 426 "debug.c"
}


/**
   * Create or return the singleton {@link Folks.Debug} class instance.
   * If the instance doesn't exist already, it will be created with the given
   * set of debug domains enabled. Otherwise, the existing instance will have
   * its set of enabled domains changed to the provided set.
   *
   * @param debug_flags A comma-separated list of debug domains to enable, or
   * null to disable debug output
   * @param colour_enabled Whether debug output should be coloured using
   * terminal escape sequences
   * @return Singleton {@link Folks.Debug} instance
   * @since 0.5.1
   */
FolksDebug*
folks_debug_dup_with_flags (const gchar* debug_flags,
                            gboolean colour_enabled)
{
	FolksDebug* result = NULL;
	FolksDebug* retval = NULL;
	FolksDebug* _tmp0_;
	FolksDebug* _tmp1_;
	FolksDebug* _tmp2_;
	GeeHashSet* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp17_ = FALSE;
	FolksDebug* _tmp18_;
	gboolean _tmp19_;
	FolksDebug* _tmp24_;
	FolksDebug* _tmp25_;
#line 217 "/run/build/folks/folks/debug.vala"
	_tmp0_ = folks_debug_dup ();
#line 217 "/run/build/folks/folks/debug.vala"
	retval = _tmp0_;
#line 219 "/run/build/folks/folks/debug.vala"
	_tmp1_ = retval;
#line 219 "/run/build/folks/folks/debug.vala"
	_tmp1_->priv->_all = FALSE;
#line 220 "/run/build/folks/folks/debug.vala"
	_tmp2_ = retval;
#line 220 "/run/build/folks/folks/debug.vala"
	_tmp3_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL, NULL, NULL, NULL);
#line 220 "/run/build/folks/folks/debug.vala"
	_g_object_unref0 (_tmp2_->priv->_domains);
#line 220 "/run/build/folks/folks/debug.vala"
	_tmp2_->priv->_domains = _tmp3_;
#line 222 "/run/build/folks/folks/debug.vala"
	if (debug_flags != NULL) {
#line 222 "/run/build/folks/folks/debug.vala"
		_tmp4_ = g_strcmp0 (debug_flags, "") != 0;
#line 479 "debug.c"
	} else {
#line 222 "/run/build/folks/folks/debug.vala"
		_tmp4_ = FALSE;
#line 483 "debug.c"
	}
#line 222 "/run/build/folks/folks/debug.vala"
	if (_tmp4_) {
#line 487 "debug.c"
		gchar** domains_split = NULL;
		gchar** _tmp5_;
		gchar** _tmp6_;
		gint domains_split_length1;
		gint _domains_split_size_;
		gchar** _tmp7_;
		gint _tmp7__length1;
#line 224 "/run/build/folks/folks/debug.vala"
		_tmp6_ = _tmp5_ = g_strsplit ((const gchar*) debug_flags, ",", 0);
#line 224 "/run/build/folks/folks/debug.vala"
		domains_split = _tmp6_;
#line 224 "/run/build/folks/folks/debug.vala"
		domains_split_length1 = _vala_array_length (_tmp5_);
#line 224 "/run/build/folks/folks/debug.vala"
		_domains_split_size_ = domains_split_length1;
#line 225 "/run/build/folks/folks/debug.vala"
		_tmp7_ = domains_split;
#line 225 "/run/build/folks/folks/debug.vala"
		_tmp7__length1 = domains_split_length1;
#line 507 "debug.c"
		{
			gchar** domain_collection = NULL;
			gint domain_collection_length1 = 0;
			gint _domain_collection_size_ = 0;
			gint domain_it = 0;
#line 225 "/run/build/folks/folks/debug.vala"
			domain_collection = _tmp7_;
#line 225 "/run/build/folks/folks/debug.vala"
			domain_collection_length1 = _tmp7__length1;
#line 225 "/run/build/folks/folks/debug.vala"
			for (domain_it = 0; domain_it < _tmp7__length1; domain_it = domain_it + 1) {
#line 519 "debug.c"
				gchar* _tmp8_;
				gchar* domain = NULL;
#line 225 "/run/build/folks/folks/debug.vala"
				_tmp8_ = g_strdup (domain_collection[domain_it]);
#line 225 "/run/build/folks/folks/debug.vala"
				domain = _tmp8_;
#line 526 "debug.c"
				{
					gchar* domain_lower = NULL;
					const gchar* _tmp9_;
					gchar* _tmp10_;
					GCompareFunc _tmp11_;
					const gchar* _tmp12_;
#line 227 "/run/build/folks/folks/debug.vala"
					_tmp9_ = domain;
#line 227 "/run/build/folks/folks/debug.vala"
					_tmp10_ = g_utf8_strdown (_tmp9_, (gssize) -1);
#line 227 "/run/build/folks/folks/debug.vala"
					domain_lower = _tmp10_;
#line 229 "/run/build/folks/folks/debug.vala"
					_tmp11_ = g_strcmp0;
#line 229 "/run/build/folks/folks/debug.vala"
					_tmp12_ = domain_lower;
#line 229 "/run/build/folks/folks/debug.vala"
					if (_tmp11_ (_tmp12_, "all") == 0) {
#line 545 "debug.c"
						FolksDebug* _tmp13_;
#line 230 "/run/build/folks/folks/debug.vala"
						_tmp13_ = retval;
#line 230 "/run/build/folks/folks/debug.vala"
						_tmp13_->priv->_all = TRUE;
#line 551 "debug.c"
					} else {
						FolksDebug* _tmp14_;
						GeeHashSet* _tmp15_;
						const gchar* _tmp16_;
#line 232 "/run/build/folks/folks/debug.vala"
						_tmp14_ = retval;
#line 232 "/run/build/folks/folks/debug.vala"
						_tmp15_ = _tmp14_->priv->_domains;
#line 232 "/run/build/folks/folks/debug.vala"
						_tmp16_ = domain_lower;
#line 232 "/run/build/folks/folks/debug.vala"
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, _tmp16_);
#line 564 "debug.c"
					}
#line 225 "/run/build/folks/folks/debug.vala"
					_g_free0 (domain_lower);
#line 225 "/run/build/folks/folks/debug.vala"
					_g_free0 (domain);
#line 570 "debug.c"
				}
			}
		}
#line 222 "/run/build/folks/folks/debug.vala"
		domains_split = (_vala_array_free (domains_split, domains_split_length1, (GDestroyNotify) g_free), NULL);
#line 576 "debug.c"
	}
#line 236 "/run/build/folks/folks/debug.vala"
	_tmp18_ = retval;
#line 236 "/run/build/folks/folks/debug.vala"
	_tmp19_ = _tmp18_->priv->_all;
#line 236 "/run/build/folks/folks/debug.vala"
	if (_tmp19_) {
#line 236 "/run/build/folks/folks/debug.vala"
		_tmp17_ = TRUE;
#line 586 "debug.c"
	} else {
		FolksDebug* _tmp20_;
		GeeHashSet* _tmp21_;
		gboolean _tmp22_;
		gboolean _tmp23_;
#line 236 "/run/build/folks/folks/debug.vala"
		_tmp20_ = retval;
#line 236 "/run/build/folks/folks/debug.vala"
		_tmp21_ = _tmp20_->priv->_domains;
#line 236 "/run/build/folks/folks/debug.vala"
		_tmp22_ = gee_collection_get_is_empty ((GeeCollection*) _tmp21_);
#line 236 "/run/build/folks/folks/debug.vala"
		_tmp23_ = _tmp22_;
#line 236 "/run/build/folks/folks/debug.vala"
		_tmp17_ = !_tmp23_;
#line 602 "debug.c"
	}
#line 236 "/run/build/folks/folks/debug.vala"
	_tmp24_ = retval;
#line 236 "/run/build/folks/folks/debug.vala"
	folks_debug_set_debug_output_enabled (_tmp24_, _tmp17_);
#line 237 "/run/build/folks/folks/debug.vala"
	_tmp25_ = retval;
#line 237 "/run/build/folks/folks/debug.vala"
	folks_debug_set_colour_enabled (_tmp25_, colour_enabled);
#line 239 "/run/build/folks/folks/debug.vala"
	result = retval;
#line 239 "/run/build/folks/folks/debug.vala"
	return result;
#line 616 "debug.c"
}


static FolksDebug*
folks_debug_construct (GType object_type)
{
	FolksDebug * self = NULL;
#line 245 "/run/build/folks/folks/debug.vala"
	self = (FolksDebug*) g_object_new (object_type, NULL);
#line 242 "/run/build/folks/folks/debug.vala"
	return self;
#line 628 "debug.c"
}


static FolksDebug*
folks_debug_new (void)
{
#line 242 "/run/build/folks/folks/debug.vala"
	return folks_debug_construct (FOLKS_TYPE_DEBUG);
#line 637 "debug.c"
}


static void
_folks_debug_set_handler (FolksDebug* self,
                          const gchar* domain,
                          GLogLevelFlags flags,
                          GLogFunc log_func,
                          gpointer log_func_target)
{
	GeeHashSet* _tmp0_;
#line 269 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 269 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (domain != NULL);
#line 274 "/run/build/folks/folks/debug.vala"
	_folks_debug_remove_handler (self, domain, FALSE);
#line 275 "/run/build/folks/folks/debug.vala"
	g_log_set_handler (domain, flags, log_func, log_func_target);
#line 276 "/run/build/folks/folks/debug.vala"
	_tmp0_ = self->priv->_domains_handled;
#line 276 "/run/build/folks/folks/debug.vala"
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, domain);
#line 661 "debug.c"
}


static void
_folks_debug_remove_handler (FolksDebug* self,
                             const gchar* domain,
                             gboolean keep_in_map)
{
	GeeHashSet* _tmp0_;
#line 279 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 279 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (domain != NULL);
#line 281 "/run/build/folks/folks/debug.vala"
	_tmp0_ = self->priv->_domains_handled;
#line 281 "/run/build/folks/folks/debug.vala"
	if (gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp0_, domain)) {
#line 679 "debug.c"
		GLogFunc _tmp1_;
		void* _tmp1__target;
#line 283 "/run/build/folks/folks/debug.vala"
		_tmp1_ = g_log_default_handler;
#line 283 "/run/build/folks/folks/debug.vala"
		_tmp1__target = NULL;
#line 283 "/run/build/folks/folks/debug.vala"
		g_log_set_handler (domain, (G_LOG_LEVEL_MASK | G_LOG_FLAG_RECURSION) | G_LOG_FLAG_FATAL, _tmp1_, _tmp1__target);
#line 288 "/run/build/folks/folks/debug.vala"
		if (!keep_in_map) {
#line 690 "debug.c"
			GeeHashSet* _tmp2_;
#line 289 "/run/build/folks/folks/debug.vala"
			_tmp2_ = self->priv->_domains_handled;
#line 289 "/run/build/folks/folks/debug.vala"
			gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp2_, domain);
#line 696 "debug.c"
		}
	}
}


/**
   * Causes all significant objects in the library to print their current
   * status to standard output, obeying the options set on this
   * {@link Folks.Debug} instance for colouring and other formatting.
   *
   * @since 0.5.1
   */
void
folks_debug_emit_print_status (FolksDebug* self)
{
#line 300 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 302 "/run/build/folks/folks/debug.vala"
	g_print ("Dumping status information…\n");
#line 303 "/run/build/folks/folks/debug.vala"
	g_signal_emit (self, folks_debug_signals[FOLKS_DEBUG_PRINT_STATUS_SIGNAL], 0);
#line 718 "debug.c"
}


/**
   * Increment the indentation level used when printing output through the
   * object.
   *
   * This is intended to be used by backend libraries only.
   *
   * @since 0.5.1
   */
void
folks_debug_indent (FolksDebug* self)
{
	guint _tmp0_;
	guint _tmp1_;
	gchar* _tmp2_;
#line 314 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 317 "/run/build/folks/folks/debug.vala"
	_tmp0_ = self->priv->_indentation;
#line 317 "/run/build/folks/folks/debug.vala"
	self->priv->_indentation = _tmp0_ + 1;
#line 318 "/run/build/folks/folks/debug.vala"
	_tmp1_ = self->priv->_indentation;
#line 318 "/run/build/folks/folks/debug.vala"
	_tmp2_ = g_strnfill ((gsize) (_tmp1_ * 2), ' ');
#line 318 "/run/build/folks/folks/debug.vala"
	_g_free0 (self->priv->_indentation_string);
#line 318 "/run/build/folks/folks/debug.vala"
	self->priv->_indentation_string = _tmp2_;
#line 750 "debug.c"
}


/**
   * Decrement the indentation level used when printing output through the
   * object.
   *
   * This is intended to be used by backend libraries only.
   *
   * @since 0.5.1
   */
void
folks_debug_unindent (FolksDebug* self)
{
	guint _tmp0_;
	guint _tmp1_;
	gchar* _tmp2_;
#line 329 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 331 "/run/build/folks/folks/debug.vala"
	_tmp0_ = self->priv->_indentation;
#line 331 "/run/build/folks/folks/debug.vala"
	self->priv->_indentation = _tmp0_ - 1;
#line 332 "/run/build/folks/folks/debug.vala"
	_tmp1_ = self->priv->_indentation;
#line 332 "/run/build/folks/folks/debug.vala"
	_tmp2_ = g_strnfill ((gsize) (_tmp1_ * 2), ' ');
#line 332 "/run/build/folks/folks/debug.vala"
	_g_free0 (self->priv->_indentation_string);
#line 332 "/run/build/folks/folks/debug.vala"
	self->priv->_indentation_string = _tmp2_;
#line 782 "debug.c"
}


/**
   * Print a debug line with the current indentation level for the specified
   * debug domain.
   *
   * This is intended to be used by backend libraries only.
   *
   * @param domain The debug domain name
   * @param level A set of log level flags for the message
   * @param format A printf-style format string for the heading
   * @param ... Arguments for the format string
   * @since 0.5.1
   */
void
folks_debug_print_line (FolksDebug* self,
                        const gchar* domain,
                        GLogLevelFlags level,
                        const gchar* format,
                        ...)
{
	va_list valist = {0};
	gchar* output = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
#line 348 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 348 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (domain != NULL);
#line 348 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (format != NULL);
#line 354 "/run/build/folks/folks/debug.vala"
	va_start (valist, format);
#line 355 "/run/build/folks/folks/debug.vala"
	_tmp0_ = g_strdup_vprintf (format, valist);
#line 355 "/run/build/folks/folks/debug.vala"
	output = _tmp0_;
#line 356 "/run/build/folks/folks/debug.vala"
	_tmp1_ = self->priv->_indentation_string;
#line 356 "/run/build/folks/folks/debug.vala"
	g_log (domain, level, "%s%s", _tmp1_, output);
#line 348 "/run/build/folks/folks/debug.vala"
	_g_free0 (output);
#line 348 "/run/build/folks/folks/debug.vala"
	va_end (valist);
#line 829 "debug.c"
}


/**
   * Print a debug line as a heading. It will be coloured according to the
   * current indentation level so that different levels of headings stand out.
   *
   * This is intended to be used by backend libraries only.
   *
   * @param domain The debug domain name
   * @param level A set of log level flags for the message
   * @param format A printf-style format string for the heading
   * @param ... Arguments for the format string
   * @since 0.5.1
   */
void
folks_debug_print_heading (FolksDebug* self,
                           const gchar* domain,
                           GLogLevelFlags level,
                           const gchar* format,
                           ...)
{
#line 379 "/run/build/folks/folks/debug.vala"
	static const gint heading_colours[3] = {31, 32, 34};
#line 854 "debug.c"
	gchar* wrapper_format = NULL;
	gchar* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	va_list valist = {0};
	gchar* output = NULL;
	gchar* _tmp7_;
	const gchar* _tmp8_;
#line 372 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 372 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (domain != NULL);
#line 372 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (format != NULL);
#line 386 "/run/build/folks/folks/debug.vala"
	_tmp0_ = g_strdup ("%s");
#line 386 "/run/build/folks/folks/debug.vala"
	wrapper_format = _tmp0_;
#line 387 "/run/build/folks/folks/debug.vala"
	_tmp1_ = folks_debug_get_colour_enabled (self);
#line 387 "/run/build/folks/folks/debug.vala"
	_tmp2_ = _tmp1_;
#line 387 "/run/build/folks/folks/debug.vala"
	if (_tmp2_ == TRUE) {
#line 879 "debug.c"
		guint indentation = 0U;
		guint _tmp3_;
		guint _tmp4_;
		gint _tmp5_;
		gchar* _tmp6_;
#line 389 "/run/build/folks/folks/debug.vala"
		_tmp3_ = self->priv->_indentation;
#line 389 "/run/build/folks/folks/debug.vala"
		indentation = CLAMP (_tmp3_, (guint) 0, (guint) (G_N_ELEMENTS (heading_colours) - 1));
#line 391 "/run/build/folks/folks/debug.vala"
		_tmp4_ = indentation;
#line 391 "/run/build/folks/folks/debug.vala"
		_tmp5_ = heading_colours[_tmp4_];
#line 391 "/run/build/folks/folks/debug.vala"
		_tmp6_ = g_strdup_printf ("\033[1;%im%%s\033[0m", _tmp5_);
#line 391 "/run/build/folks/folks/debug.vala"
		_g_free0 (wrapper_format);
#line 391 "/run/build/folks/folks/debug.vala"
		wrapper_format = _tmp6_;
#line 899 "debug.c"
	}
#line 396 "/run/build/folks/folks/debug.vala"
	va_start (valist, format);
#line 397 "/run/build/folks/folks/debug.vala"
	_tmp7_ = g_strdup_vprintf (format, valist);
#line 397 "/run/build/folks/folks/debug.vala"
	output = _tmp7_;
#line 398 "/run/build/folks/folks/debug.vala"
	_tmp8_ = wrapper_format;
#line 398 "/run/build/folks/folks/debug.vala"
	folks_debug_print_line (self, domain, level, _tmp8_, output);
#line 372 "/run/build/folks/folks/debug.vala"
	_g_free0 (output);
#line 372 "/run/build/folks/folks/debug.vala"
	va_end (valist);
#line 372 "/run/build/folks/folks/debug.vala"
	_g_free0 (wrapper_format);
#line 917 "debug.c"
}


static gchar*
_folks_debug_format_nullable_string (FolksDebug* self,
                                     const gchar* input)
{
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gchar* _tmp5_;
#line 405 "/run/build/folks/folks/debug.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 407 "/run/build/folks/folks/debug.vala"
	_tmp1_ = folks_debug_get_colour_enabled (self);
#line 407 "/run/build/folks/folks/debug.vala"
	_tmp2_ = _tmp1_;
#line 407 "/run/build/folks/folks/debug.vala"
	if (_tmp2_ == TRUE) {
#line 407 "/run/build/folks/folks/debug.vala"
		_tmp0_ = input == NULL;
#line 940 "debug.c"
	} else {
#line 407 "/run/build/folks/folks/debug.vala"
		_tmp0_ = FALSE;
#line 944 "debug.c"
	}
#line 407 "/run/build/folks/folks/debug.vala"
	if (_tmp0_) {
#line 948 "debug.c"
		gchar* _tmp3_;
#line 409 "/run/build/folks/folks/debug.vala"
		_tmp3_ = g_strdup ("\033[1;36m(null)\033[0m");
#line 409 "/run/build/folks/folks/debug.vala"
		result = _tmp3_;
#line 409 "/run/build/folks/folks/debug.vala"
		return result;
#line 956 "debug.c"
	} else {
#line 411 "/run/build/folks/folks/debug.vala"
		if (input == NULL) {
#line 960 "debug.c"
			gchar* _tmp4_;
#line 413 "/run/build/folks/folks/debug.vala"
			_tmp4_ = g_strdup ("(null)");
#line 413 "/run/build/folks/folks/debug.vala"
			result = _tmp4_;
#line 413 "/run/build/folks/folks/debug.vala"
			return result;
#line 968 "debug.c"
		}
	}
#line 416 "/run/build/folks/folks/debug.vala"
	_tmp5_ = g_strdup ((const gchar*) input);
#line 416 "/run/build/folks/folks/debug.vala"
	result = _tmp5_;
#line 416 "/run/build/folks/folks/debug.vala"
	return result;
#line 977 "debug.c"
}


/**
   * Print a set of key–value pairs in a table. The width of the key column is
   * automatically set to the width of the longest key. The keys and values
   * must be provided as a null-delimited list of alternating key–value varargs.
   * Values may be null but keys may not.
   *
   * This is intended to be used by backend libraries only.
   *
   * The table will be printed at the current indentation level plus one.
   *
   * @param domain The debug domain name
   * @param level A set of log level flags for the message
   * @param ... Alternating keys and values, terminated with null
   * @since 0.5.1
   */
static void
_vala_array_add1 (FolksDebugKeyValuePair* * array,
                  int* length,
                  int* size,
                  const FolksDebugKeyValuePair* value)
{
#line 464 "/run/build/folks/folks/debug.vala"
	if ((*length) == (*size)) {
#line 464 "/run/build/folks/folks/debug.vala"
		*size = (*size) ? (2 * (*size)) : 4;
#line 464 "/run/build/folks/folks/debug.vala"
		*array = g_renew (FolksDebugKeyValuePair, *array, *size);
#line 1008 "debug.c"
	}
#line 464 "/run/build/folks/folks/debug.vala"
	(*array)[(*length)++] = *value;
#line 1012 "debug.c"
}


static void
_vala_FolksDebugKeyValuePair_array_free (FolksDebugKeyValuePair * array,
                                         gint array_length)
{
#line 440 "/run/build/folks/folks/debug.vala"
	if (array != NULL) {
#line 1022 "debug.c"
		int i;
#line 440 "/run/build/folks/folks/debug.vala"
		for (i = 0; i < array_length; i = i + 1) {
#line 440 "/run/build/folks/folks/debug.vala"
			folks_debug_key_value_pair_destroy (&array[i]);
#line 1028 "debug.c"
		}
	}
#line 440 "/run/build/folks/folks/debug.vala"
	g_free (array);
#line 1033 "debug.c"
}


void
folks_debug_print_key_value_pairs (FolksDebug* self,
                                   const gchar* domain,
                                   GLogLevelFlags level,
                                   ...)
{
	va_list valist = {0};
	FolksDebugKeyValuePair* lines = NULL;
	FolksDebugKeyValuePair* _tmp0_;
	gint lines_length1;
	gint _lines_size_;
	guint max_key_length = 0U;
	FolksDebugKeyValuePair* _tmp18_;
	gint _tmp18__length1;
#line 440 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 440 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (domain != NULL);
#line 444 "/run/build/folks/folks/debug.vala"
	va_start (valist, level);
#line 445 "/run/build/folks/folks/debug.vala"
	_tmp0_ = g_new0 (FolksDebugKeyValuePair, 0);
#line 445 "/run/build/folks/folks/debug.vala"
	lines = _tmp0_;
#line 445 "/run/build/folks/folks/debug.vala"
	lines_length1 = 0;
#line 445 "/run/build/folks/folks/debug.vala"
	_lines_size_ = lines_length1;
#line 446 "/run/build/folks/folks/debug.vala"
	max_key_length = (guint) 0;
#line 450 "/run/build/folks/folks/debug.vala"
	while (TRUE) {
#line 1069 "debug.c"
		gchar* _key = NULL;
		const gchar* _tmp1_;
		gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* key = NULL;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* val = NULL;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		const gchar* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		guint _tmp11_;
		FolksDebugKeyValuePair* _tmp12_;
		gint _tmp12__length1;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		const gchar* _tmp15_;
		gchar* _tmp16_;
		FolksDebugKeyValuePair _tmp17_ = {0};
#line 452 "/run/build/folks/folks/debug.vala"
		_tmp1_ = va_arg (valist, gchar*);
#line 452 "/run/build/folks/folks/debug.vala"
		_tmp2_ = g_strdup (_tmp1_);
#line 452 "/run/build/folks/folks/debug.vala"
		_key = _tmp2_;
#line 453 "/run/build/folks/folks/debug.vala"
		_tmp3_ = _key;
#line 453 "/run/build/folks/folks/debug.vala"
		if (_tmp3_ == NULL) {
#line 455 "/run/build/folks/folks/debug.vala"
			_g_free0 (_key);
#line 455 "/run/build/folks/folks/debug.vala"
			break;
#line 1105 "debug.c"
		}
#line 457 "/run/build/folks/folks/debug.vala"
		_tmp4_ = _key;
#line 457 "/run/build/folks/folks/debug.vala"
		_tmp5_ = g_strdup ((const gchar*) _tmp4_);
#line 457 "/run/build/folks/folks/debug.vala"
		key = _tmp5_;
#line 459 "/run/build/folks/folks/debug.vala"
		_tmp6_ = va_arg (valist, gchar*);
#line 459 "/run/build/folks/folks/debug.vala"
		_tmp7_ = g_strdup (_tmp6_);
#line 459 "/run/build/folks/folks/debug.vala"
		val = _tmp7_;
#line 462 "/run/build/folks/folks/debug.vala"
		_tmp8_ = key;
#line 462 "/run/build/folks/folks/debug.vala"
		_tmp9_ = strlen (_tmp8_);
#line 462 "/run/build/folks/folks/debug.vala"
		_tmp10_ = _tmp9_;
#line 462 "/run/build/folks/folks/debug.vala"
		_tmp11_ = max_key_length;
#line 462 "/run/build/folks/folks/debug.vala"
		max_key_length = MAX ((guint) _tmp10_, _tmp11_);
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp12_ = lines;
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp12__length1 = lines_length1;
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp13_ = key;
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp14_ = g_strdup (_tmp13_);
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp15_ = val;
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp16_ = g_strdup (_tmp15_);
#line 464 "/run/build/folks/folks/debug.vala"
		memset (&_tmp17_, 0, sizeof (FolksDebugKeyValuePair));
#line 464 "/run/build/folks/folks/debug.vala"
		_g_free0 (_tmp17_.key);
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp17_.key = _tmp14_;
#line 464 "/run/build/folks/folks/debug.vala"
		_g_free0 (_tmp17_.val);
#line 464 "/run/build/folks/folks/debug.vala"
		_tmp17_.val = _tmp16_;
#line 464 "/run/build/folks/folks/debug.vala"
		_vala_array_add1 (&lines, &lines_length1, &_lines_size_, &_tmp17_);
#line 450 "/run/build/folks/folks/debug.vala"
		_g_free0 (val);
#line 450 "/run/build/folks/folks/debug.vala"
		_g_free0 (key);
#line 450 "/run/build/folks/folks/debug.vala"
		_g_free0 (_key);
#line 1159 "debug.c"
	}
#line 471 "/run/build/folks/folks/debug.vala"
	folks_debug_indent (self);
#line 474 "/run/build/folks/folks/debug.vala"
	_tmp18_ = lines;
#line 474 "/run/build/folks/folks/debug.vala"
	_tmp18__length1 = lines_length1;
#line 1167 "debug.c"
	{
		FolksDebugKeyValuePair* line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
#line 474 "/run/build/folks/folks/debug.vala"
		line_collection = _tmp18_;
#line 474 "/run/build/folks/folks/debug.vala"
		line_collection_length1 = _tmp18__length1;
#line 474 "/run/build/folks/folks/debug.vala"
		for (line_it = 0; line_it < _tmp18__length1; line_it = line_it + 1) {
#line 1179 "debug.c"
			FolksDebugKeyValuePair _tmp19_ = {0};
			FolksDebugKeyValuePair line = {0};
#line 474 "/run/build/folks/folks/debug.vala"
			folks_debug_key_value_pair_copy (&line_collection[line_it], &_tmp19_);
#line 474 "/run/build/folks/folks/debug.vala"
			line = _tmp19_;
#line 1186 "debug.c"
			{
				gchar* padding = NULL;
				guint _tmp20_;
				FolksDebugKeyValuePair _tmp21_;
				const gchar* _tmp22_;
				gint _tmp23_;
				gint _tmp24_;
				gchar* _tmp25_;
				FolksDebugKeyValuePair _tmp26_;
				const gchar* _tmp27_;
				const gchar* _tmp28_;
				FolksDebugKeyValuePair _tmp29_;
				const gchar* _tmp30_;
				gchar* _tmp31_;
				gchar* _tmp32_;
#line 476 "/run/build/folks/folks/debug.vala"
				_tmp20_ = max_key_length;
#line 476 "/run/build/folks/folks/debug.vala"
				_tmp21_ = line;
#line 476 "/run/build/folks/folks/debug.vala"
				_tmp22_ = _tmp21_.key;
#line 476 "/run/build/folks/folks/debug.vala"
				_tmp23_ = strlen (_tmp22_);
#line 476 "/run/build/folks/folks/debug.vala"
				_tmp24_ = _tmp23_;
#line 476 "/run/build/folks/folks/debug.vala"
				_tmp25_ = g_strnfill ((gsize) (_tmp20_ - _tmp24_), ' ');
#line 476 "/run/build/folks/folks/debug.vala"
				padding = _tmp25_;
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp26_ = line;
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp27_ = _tmp26_.key;
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp28_ = padding;
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp29_ = line;
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp30_ = _tmp29_.val;
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp31_ = _folks_debug_format_nullable_string (self, _tmp30_);
#line 477 "/run/build/folks/folks/debug.vala"
				_tmp32_ = _tmp31_;
#line 477 "/run/build/folks/folks/debug.vala"
				folks_debug_print_line (self, domain, level, "%s: %s%s", _tmp27_, _tmp28_, _tmp32_);
#line 477 "/run/build/folks/folks/debug.vala"
				_g_free0 (_tmp32_);
#line 474 "/run/build/folks/folks/debug.vala"
				_g_free0 (padding);
#line 474 "/run/build/folks/folks/debug.vala"
				folks_debug_key_value_pair_destroy (&line);
#line 1238 "debug.c"
			}
		}
	}
#line 481 "/run/build/folks/folks/debug.vala"
	folks_debug_unindent (self);
#line 440 "/run/build/folks/folks/debug.vala"
	lines = (_vala_FolksDebugKeyValuePair_array_free (lines, lines_length1), NULL);
#line 440 "/run/build/folks/folks/debug.vala"
	va_end (valist);
#line 1248 "debug.c"
}


gboolean
folks_debug_get_colour_enabled (FolksDebug* self)
{
	gboolean result;
	gboolean _tmp0_;
#line 75 "/run/build/folks/folks/debug.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 77 "/run/build/folks/folks/debug.vala"
	_tmp0_ = self->priv->_colour_enabled;
#line 77 "/run/build/folks/folks/debug.vala"
	result = _tmp0_;
#line 77 "/run/build/folks/folks/debug.vala"
	return result;
#line 1265 "debug.c"
}


void
folks_debug_set_colour_enabled (FolksDebug* self,
                                gboolean value)
{
#line 80 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 82 "/run/build/folks/folks/debug.vala"
	self->priv->_colour_enabled = value;
#line 80 "/run/build/folks/folks/debug.vala"
	g_object_notify_by_pspec ((GObject *) self, folks_debug_properties[FOLKS_DEBUG_COLOUR_ENABLED_PROPERTY]);
#line 1279 "debug.c"
}


gboolean
folks_debug_get_debug_output_enabled (FolksDebug* self)
{
	gboolean result;
	gboolean _tmp0_;
#line 97 "/run/build/folks/folks/debug.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 99 "/run/build/folks/folks/debug.vala"
	_tmp0_ = self->priv->_debug_output_enabled;
#line 99 "/run/build/folks/folks/debug.vala"
	result = _tmp0_;
#line 99 "/run/build/folks/folks/debug.vala"
	return result;
#line 1296 "debug.c"
}


void
folks_debug_set_debug_output_enabled (FolksDebug* self,
                                      gboolean value)
{
#line 102 "/run/build/folks/folks/debug.vala"
	g_return_if_fail (self != NULL);
#line 104 "/run/build/folks/folks/debug.vala"
	self->priv->_debug_output_enabled = value;
#line 102 "/run/build/folks/folks/debug.vala"
	g_object_notify_by_pspec ((GObject *) self, folks_debug_properties[FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED_PROPERTY]);
#line 1310 "debug.c"
}


static void
__folks_debug_print_status_log_handler_cb_glog_func (const gchar* log_domain,
                                                     GLogLevelFlags log_levels,
                                                     const gchar* message,
                                                     gpointer self)
{
#line 254 "/run/build/folks/folks/debug.vala"
	_folks_debug_print_status_log_handler_cb ((FolksDebug*) self, log_domain, log_levels, message);
#line 1322 "debug.c"
}


static GObject *
folks_debug_constructor (GType type,
                         guint n_construct_properties,
                         GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	FolksDebug * self;
	GeeHashSet* _tmp0_;
#line 248 "/run/build/folks/folks/debug.vala"
	parent_class = G_OBJECT_CLASS (folks_debug_parent_class);
#line 248 "/run/build/folks/folks/debug.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 248 "/run/build/folks/folks/debug.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_DEBUG, FolksDebug);
#line 250 "/run/build/folks/folks/debug.vala"
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL, NULL, NULL, NULL);
#line 250 "/run/build/folks/folks/debug.vala"
	_g_object_unref0 (self->priv->_domains_handled);
#line 250 "/run/build/folks/folks/debug.vala"
	self->priv->_domains_handled = _tmp0_;
#line 254 "/run/build/folks/folks/debug.vala"
	_folks_debug_set_handler (self, FOLKS_DEBUG_STATUS_LOG_DOMAIN, G_LOG_LEVEL_MASK, __folks_debug_print_status_log_handler_cb_glog_func, self);
#line 248 "/run/build/folks/folks/debug.vala"
	return obj;
#line 1351 "debug.c"
}


static void
folks_debug_key_value_pair_copy (const FolksDebugKeyValuePair* self,
                                 FolksDebugKeyValuePair* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
#line 419 "/run/build/folks/folks/debug.vala"
	_tmp0_ = (*self).key;
#line 419 "/run/build/folks/folks/debug.vala"
	_tmp1_ = g_strdup (_tmp0_);
#line 419 "/run/build/folks/folks/debug.vala"
	_g_free0 ((*dest).key);
#line 419 "/run/build/folks/folks/debug.vala"
	(*dest).key = _tmp1_;
#line 419 "/run/build/folks/folks/debug.vala"
	_tmp2_ = (*self).val;
#line 419 "/run/build/folks/folks/debug.vala"
	_tmp3_ = g_strdup (_tmp2_);
#line 419 "/run/build/folks/folks/debug.vala"
	_g_free0 ((*dest).val);
#line 419 "/run/build/folks/folks/debug.vala"
	(*dest).val = _tmp3_;
#line 1379 "debug.c"
}


static void
folks_debug_key_value_pair_destroy (FolksDebugKeyValuePair* self)
{
#line 421 "/run/build/folks/folks/debug.vala"
	_g_free0 ((*self).key);
#line 422 "/run/build/folks/folks/debug.vala"
	_g_free0 ((*self).val);
#line 1390 "debug.c"
}


static FolksDebugKeyValuePair*
folks_debug_key_value_pair_dup (const FolksDebugKeyValuePair* self)
{
	FolksDebugKeyValuePair* dup;
#line 419 "/run/build/folks/folks/debug.vala"
	dup = g_new0 (FolksDebugKeyValuePair, 1);
#line 419 "/run/build/folks/folks/debug.vala"
	folks_debug_key_value_pair_copy (self, dup);
#line 419 "/run/build/folks/folks/debug.vala"
	return dup;
#line 1404 "debug.c"
}


static void
folks_debug_key_value_pair_free (FolksDebugKeyValuePair* self)
{
#line 419 "/run/build/folks/folks/debug.vala"
	folks_debug_key_value_pair_destroy (self);
#line 419 "/run/build/folks/folks/debug.vala"
	g_free (self);
#line 1415 "debug.c"
}


static GType
folks_debug_key_value_pair_get_type (void)
{
	static volatile gsize folks_debug_key_value_pair_type_id__volatile = 0;
	if (g_once_init_enter (&folks_debug_key_value_pair_type_id__volatile)) {
		GType folks_debug_key_value_pair_type_id;
		folks_debug_key_value_pair_type_id = g_boxed_type_register_static ("FolksDebugKeyValuePair", (GBoxedCopyFunc) folks_debug_key_value_pair_dup, (GBoxedFreeFunc) folks_debug_key_value_pair_free);
		g_once_init_leave (&folks_debug_key_value_pair_type_id__volatile, folks_debug_key_value_pair_type_id);
	}
	return folks_debug_key_value_pair_type_id__volatile;
}


static void
folks_debug_class_init (FolksDebugClass * klass)
{
#line 43 "/run/build/folks/folks/debug.vala"
	folks_debug_parent_class = g_type_class_peek_parent (klass);
#line 43 "/run/build/folks/folks/debug.vala"
	g_type_class_add_private (klass, sizeof (FolksDebugPrivate));
#line 43 "/run/build/folks/folks/debug.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_folks_debug_get_property;
#line 43 "/run/build/folks/folks/debug.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_folks_debug_set_property;
#line 43 "/run/build/folks/folks/debug.vala"
	G_OBJECT_CLASS (klass)->constructor = folks_debug_constructor;
#line 43 "/run/build/folks/folks/debug.vala"
	G_OBJECT_CLASS (klass)->finalize = folks_debug_finalize;
#line 43 "/run/build/folks/folks/debug.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_DEBUG_COLOUR_ENABLED_PROPERTY, folks_debug_properties[FOLKS_DEBUG_COLOUR_ENABLED_PROPERTY] = g_param_spec_boolean ("colour-enabled", "colour-enabled", "colour-enabled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1449 "debug.c"
	/**
	   * Whether debug output is enabled. This is orthogonal to the set of enabled
	   * debug domains; filtering of debug output as a whole is done after filtering
	   * by enabled domains.
	   *
	   * @since 0.5.1
	   */
#line 43 "/run/build/folks/folks/debug.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED_PROPERTY, folks_debug_properties[FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED_PROPERTY] = g_param_spec_boolean ("debug-output-enabled", "debug-output-enabled", "debug-output-enabled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1459 "debug.c"
	/**
	   * Signal emitted in the main thread whenever objects should print their
	   * current status. All significant objects in the library should connect
	   * to this and print their current status in some suitable format when it's
	   * emitted.
	   *
	   * Client processes should emit this signal by calling
	   * {@link Debug.emit_print_status}.
	   *
	   * @since 0.5.1
	   */
#line 43 "/run/build/folks/folks/debug.vala"
	folks_debug_signals[FOLKS_DEBUG_PRINT_STATUS_SIGNAL] = g_signal_new ("print-status", FOLKS_TYPE_DEBUG, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
#line 1473 "debug.c"
}


static void
folks_debug_instance_init (FolksDebug * self)
{
	gchar* _tmp0_;
#line 43 "/run/build/folks/folks/debug.vala"
	self->priv = FOLKS_DEBUG_GET_PRIVATE (self);
#line 55 "/run/build/folks/folks/debug.vala"
	self->priv->_all = FALSE;
#line 58 "/run/build/folks/folks/debug.vala"
	self->priv->_indentation = (guint) 0;
#line 59 "/run/build/folks/folks/debug.vala"
	_tmp0_ = g_strdup ("");
#line 59 "/run/build/folks/folks/debug.vala"
	self->priv->_indentation_string = _tmp0_;
#line 61 "/run/build/folks/folks/debug.vala"
	self->priv->_colour_enabled = TRUE;
#line 86 "/run/build/folks/folks/debug.vala"
	self->priv->_debug_output_enabled = FALSE;
#line 1495 "debug.c"
}


static void
folks_debug_finalize (GObject * obj)
{
	FolksDebug * self;
	GeeHashSet* _tmp6_;
#line 43 "/run/build/folks/folks/debug.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_DEBUG, FolksDebug);
#line 1506 "debug.c"
	{
		GeeIterator* _domain_it = NULL;
		GeeHashSet* _tmp0_;
		GeeIterator* _tmp1_;
#line 261 "/run/build/folks/folks/debug.vala"
		_tmp0_ = self->priv->_domains_handled;
#line 261 "/run/build/folks/folks/debug.vala"
		_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp0_);
#line 261 "/run/build/folks/folks/debug.vala"
		_domain_it = _tmp1_;
#line 261 "/run/build/folks/folks/debug.vala"
		while (TRUE) {
#line 1519 "debug.c"
			GeeIterator* _tmp2_;
			gchar* domain = NULL;
			GeeIterator* _tmp3_;
			gpointer _tmp4_;
			const gchar* _tmp5_;
#line 261 "/run/build/folks/folks/debug.vala"
			_tmp2_ = _domain_it;
#line 261 "/run/build/folks/folks/debug.vala"
			if (!gee_iterator_next (_tmp2_)) {
#line 261 "/run/build/folks/folks/debug.vala"
				break;
#line 1531 "debug.c"
			}
#line 261 "/run/build/folks/folks/debug.vala"
			_tmp3_ = _domain_it;
#line 261 "/run/build/folks/folks/debug.vala"
			_tmp4_ = gee_iterator_get (_tmp3_);
#line 261 "/run/build/folks/folks/debug.vala"
			domain = (gchar*) _tmp4_;
#line 262 "/run/build/folks/folks/debug.vala"
			_tmp5_ = domain;
#line 262 "/run/build/folks/folks/debug.vala"
			_folks_debug_remove_handler (self, _tmp5_, TRUE);
#line 261 "/run/build/folks/folks/debug.vala"
			_g_free0 (domain);
#line 1545 "debug.c"
		}
#line 261 "/run/build/folks/folks/debug.vala"
		_g_object_unref0 (_domain_it);
#line 1549 "debug.c"
	}
#line 263 "/run/build/folks/folks/debug.vala"
	_tmp6_ = self->priv->_domains_handled;
#line 263 "/run/build/folks/folks/debug.vala"
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp6_);
#line 266 "/run/build/folks/folks/debug.vala"
	folks_debug__instance = NULL;
#line 54 "/run/build/folks/folks/debug.vala"
	_g_object_unref0 (self->priv->_domains);
#line 59 "/run/build/folks/folks/debug.vala"
	_g_free0 (self->priv->_indentation_string);
#line 62 "/run/build/folks/folks/debug.vala"
	_g_object_unref0 (self->priv->_domains_handled);
#line 43 "/run/build/folks/folks/debug.vala"
	G_OBJECT_CLASS (folks_debug_parent_class)->finalize (obj);
#line 1565 "debug.c"
}


/**
 * Manages debug output and status reporting for all folks objects.
 *
 * All GLib debug logging calls are passed through a log handler in this class,
 * which allows debug domains to be outputted according to whether they've been
 * enabled by being passed to {@link Debug.dup}.
 *
 * @since 0.5.1
 */
GType
folks_debug_get_type (void)
{
	static volatile gsize folks_debug_type_id__volatile = 0;
	if (g_once_init_enter (&folks_debug_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolksDebugClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folks_debug_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolksDebug), 0, (GInstanceInitFunc) folks_debug_instance_init, NULL };
		GType folks_debug_type_id;
		folks_debug_type_id = g_type_register_static (G_TYPE_OBJECT, "FolksDebug", &g_define_type_info, 0);
		g_once_init_leave (&folks_debug_type_id__volatile, folks_debug_type_id);
	}
	return folks_debug_type_id__volatile;
}


static void
_vala_folks_debug_get_property (GObject * object,
                                guint property_id,
                                GValue * value,
                                GParamSpec * pspec)
{
	FolksDebug * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_DEBUG, FolksDebug);
#line 43 "/run/build/folks/folks/debug.vala"
	switch (property_id) {
#line 43 "/run/build/folks/folks/debug.vala"
		case FOLKS_DEBUG_COLOUR_ENABLED_PROPERTY:
#line 43 "/run/build/folks/folks/debug.vala"
		g_value_set_boolean (value, folks_debug_get_colour_enabled (self));
#line 43 "/run/build/folks/folks/debug.vala"
		break;
#line 43 "/run/build/folks/folks/debug.vala"
		case FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED_PROPERTY:
#line 43 "/run/build/folks/folks/debug.vala"
		g_value_set_boolean (value, folks_debug_get_debug_output_enabled (self));
#line 43 "/run/build/folks/folks/debug.vala"
		break;
#line 1614 "debug.c"
		default:
#line 43 "/run/build/folks/folks/debug.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 43 "/run/build/folks/folks/debug.vala"
		break;
#line 1620 "debug.c"
	}
}


static void
_vala_folks_debug_set_property (GObject * object,
                                guint property_id,
                                const GValue * value,
                                GParamSpec * pspec)
{
	FolksDebug * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_DEBUG, FolksDebug);
#line 43 "/run/build/folks/folks/debug.vala"
	switch (property_id) {
#line 43 "/run/build/folks/folks/debug.vala"
		case FOLKS_DEBUG_COLOUR_ENABLED_PROPERTY:
#line 43 "/run/build/folks/folks/debug.vala"
		folks_debug_set_colour_enabled (self, g_value_get_boolean (value));
#line 43 "/run/build/folks/folks/debug.vala"
		break;
#line 43 "/run/build/folks/folks/debug.vala"
		case FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED_PROPERTY:
#line 43 "/run/build/folks/folks/debug.vala"
		folks_debug_set_debug_output_enabled (self, g_value_get_boolean (value));
#line 43 "/run/build/folks/folks/debug.vala"
		break;
#line 1647 "debug.c"
		default:
#line 43 "/run/build/folks/folks/debug.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 43 "/run/build/folks/folks/debug.vala"
		break;
#line 1653 "debug.c"
	}
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint
_vala_array_length (gpointer array)
{
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



