/* unity-scope-tracker.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-scope-tracker.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Neil Jagdish Patel <neil.patel@canonical.com>
 *             Michal Hruby <michal.hruby@canonical.com>
 *
 */


#include <glib.h>
#include <glib-object.h>
#include <unity-protocol.h>
#include <stdlib.h>
#include <string.h>
#include <dee.h>
#include "unity.h"
#include <gio/gio.h>


#define UNITY_INTERNAL_TYPE_CHANNEL_UPDATE_FLAGS (unity_internal_channel_update_flags_get_type ())

#define UNITY_INTERNAL_TYPE_SCOPE_TRACKER (unity_internal_scope_tracker_get_type ())
#define UNITY_INTERNAL_SCOPE_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_SCOPE_TRACKER, UnityInternalScopeTracker))
#define UNITY_INTERNAL_SCOPE_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_SCOPE_TRACKER, UnityInternalScopeTrackerClass))
#define UNITY_INTERNAL_IS_SCOPE_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_SCOPE_TRACKER))
#define UNITY_INTERNAL_IS_SCOPE_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_SCOPE_TRACKER))
#define UNITY_INTERNAL_SCOPE_TRACKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_SCOPE_TRACKER, UnityInternalScopeTrackerClass))

typedef struct _UnityInternalScopeTracker UnityInternalScopeTracker;
typedef struct _UnityInternalScopeTrackerClass UnityInternalScopeTrackerClass;
typedef struct _UnityInternalScopeTrackerPrivate UnityInternalScopeTrackerPrivate;

#define UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE (unity_internal_utils_async_once_get_type ())
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnce))
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnceClass))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE))
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnceClass))

typedef struct _UnityInternalUtilsAsyncOnce UnityInternalUtilsAsyncOnce;
typedef struct _UnityInternalUtilsAsyncOnceClass UnityInternalUtilsAsyncOnceClass;

#define UNITY_INTERNAL_TYPE_RESULTS_SYNCHRONIZER (unity_internal_results_synchronizer_get_type ())
#define UNITY_INTERNAL_RESULTS_SYNCHRONIZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_RESULTS_SYNCHRONIZER, UnityInternalResultsSynchronizer))
#define UNITY_INTERNAL_RESULTS_SYNCHRONIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_RESULTS_SYNCHRONIZER, UnityInternalResultsSynchronizerClass))
#define UNITY_INTERNAL_IS_RESULTS_SYNCHRONIZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_RESULTS_SYNCHRONIZER))
#define UNITY_INTERNAL_IS_RESULTS_SYNCHRONIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_RESULTS_SYNCHRONIZER))
#define UNITY_INTERNAL_RESULTS_SYNCHRONIZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_RESULTS_SYNCHRONIZER, UnityInternalResultsSynchronizerClass))

typedef struct _UnityInternalResultsSynchronizer UnityInternalResultsSynchronizer;
typedef struct _UnityInternalResultsSynchronizerClass UnityInternalResultsSynchronizerClass;
enum  {
	UNITY_INTERNAL_SCOPE_TRACKER_0_PROPERTY,
	UNITY_INTERNAL_SCOPE_TRACKER_NUM_PROPERTIES
};
static GParamSpec* unity_internal_scope_tracker_properties[UNITY_INTERNAL_SCOPE_TRACKER_NUM_PROPERTIES];
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _unity_internal_utils_async_once_unref0(var) ((var == NULL) ? NULL : (var = (unity_internal_utils_async_once_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _unity_protocol_scope_registry_scope_metadata_unref0(var) ((var == NULL) ? NULL : (var = (unity_protocol_scope_registry_scope_metadata_unref (var), NULL)))
typedef struct _UnityInternalScopeTrackerCreateProxyData UnityInternalScopeTrackerCreateProxyData;

#define UNITY_INTERNAL_TYPE_MERGE_STRATEGY (unity_internal_merge_strategy_get_type ())
#define UNITY_INTERNAL_MERGE_STRATEGY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_MERGE_STRATEGY, UnityInternalMergeStrategy))
#define UNITY_INTERNAL_IS_MERGE_STRATEGY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_MERGE_STRATEGY))
#define UNITY_INTERNAL_MERGE_STRATEGY_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), UNITY_INTERNAL_TYPE_MERGE_STRATEGY, UnityInternalMergeStrategyIface))

typedef struct _UnityInternalMergeStrategy UnityInternalMergeStrategy;
typedef struct _UnityInternalMergeStrategyIface UnityInternalMergeStrategyIface;
typedef struct _Block25Data Block25Data;
typedef struct _UnityInternalScopeTrackerWaitForSeqnumData UnityInternalScopeTrackerWaitForSeqnumData;

#define UNITY_INTERNAL_TYPE_SCOPE_CHANNEL (unity_internal_scope_channel_get_type ())
#define UNITY_INTERNAL_SCOPE_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannel))
#define UNITY_INTERNAL_SCOPE_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannelClass))
#define UNITY_INTERNAL_IS_SCOPE_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL))
#define UNITY_INTERNAL_IS_SCOPE_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL))
#define UNITY_INTERNAL_SCOPE_CHANNEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_SCOPE_CHANNEL, UnityInternalScopeChannelClass))

typedef struct _UnityInternalScopeChannel UnityInternalScopeChannel;
typedef struct _UnityInternalScopeChannelClass UnityInternalScopeChannelClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _UnityInternalScopeChannelPrivate UnityInternalScopeChannelPrivate;

#define UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX (unity_internal_utils_async_mutex_get_type ())
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutex))
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexClass))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_MUTEX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_MUTEX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX))
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexClass))

typedef struct _UnityInternalUtilsAsyncMutex UnityInternalUtilsAsyncMutex;
typedef struct _UnityInternalUtilsAsyncMutexClass UnityInternalUtilsAsyncMutexClass;
typedef struct _UnityInternalScopeTrackerInitChannelData UnityInternalScopeTrackerInitChannelData;
typedef struct _UnityInternalScopeTrackerActivateWrapperData UnityInternalScopeTrackerActivateWrapperData;
typedef struct _UnityInternalScopeTrackerSearchWrapperData UnityInternalScopeTrackerSearchWrapperData;
typedef struct _UnityInternalScopeTrackerPushWrapperData UnityInternalScopeTrackerPushWrapperData;
enum  {
	UNITY_INTERNAL_SCOPE_TRACKER_RESULTS_INVALIDATED_SIGNAL,
	UNITY_INTERNAL_SCOPE_TRACKER_PROXY_CATEGORY_MODEL_CHANGED_SIGNAL,
	UNITY_INTERNAL_SCOPE_TRACKER_NUM_SIGNALS
};
static guint unity_internal_scope_tracker_signals[UNITY_INTERNAL_SCOPE_TRACKER_NUM_SIGNALS] = {0};

typedef enum  {
	UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_NONE = 0,
	UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_DEFAULT = 1 << 0,
	UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_GLOBAL = 1 << 1
} UnityInternalChannelUpdateFlags;

struct _UnityInternalScopeTracker {
	GObject parent_instance;
	UnityInternalScopeTrackerPrivate * priv;
};

struct _UnityInternalScopeTrackerClass {
	GObjectClass parent_class;
};

struct _UnityInternalScopeTrackerPrivate {
	GPtrArray* scope_proxy_arr;
	GHashTable* scope_proxies;
	GHashTable* scope_channel_ids;
	GHashTable* scope_models;
	GHashTable* synchronizers;
	GHashTable* master_update_flags;
	GHashTable* scope_metadata;
	GHashTable* binary_present;
};

struct _UnityInternalScopeTrackerCreateProxyData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeTracker* self;
	UnityProtocolScopeRegistryScopeMetadata* metadata;
	UnityProtocolScopeProxy* result;
	UnityProtocolScopeProxy* proxy;
	UnityProtocolScopeProxy* _tmp0_;
	UnityProtocolScopeProxy* remote_proxy;
	UnityProtocolScopeProxy* _tmp1_;
	UnityProtocolScopeProxy* _tmp2_;
	UnityProtocolScopeProxy* _tmp3_;
	UnityProtocolScopeProxy* _tmp4_;
	GPtrArray* _tmp5_;
	UnityProtocolScopeProxy* _tmp6_;
	UnityProtocolScopeProxy* _tmp7_;
	UnityProtocolScopeProxy* _tmp8_;
	UnityProtocolScopeProxy* _tmp9_;
	GError * _inner_error_;
};

struct _UnityInternalMergeStrategyIface {
	GTypeInterface parent_iface;
	DeeModelIter* (*merge_result) (UnityInternalMergeStrategy* self, const gchar* source_scope_id, DeeModel* target, GVariant** row, int row_length1);
};

struct _Block25Data {
	int _ref_count_;
	UnityInternalScopeTracker* self;
	guint src_id;
	guint64 seqnum;
	gpointer _async_data_;
};

struct _UnityInternalScopeTrackerWaitForSeqnumData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeTracker* self;
	DeeSharedModel* model;
	guint64 seqnum;
	Block25Data* _data25_;
	gulong update_sig_id;
	gulong _tmp0_;
	gulong _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	GError* _tmp4_;
	GError * _inner_error_;
};

struct _UnityInternalScopeChannel {
	GObject parent_instance;
	UnityInternalScopeChannelPrivate * priv;
	UnityInternalUtilsAsyncMutex* model_lock;
	DeeSharedModel* transfer_model;
	DeeSerializableModel* backend_model;
	UnityFilterSet* filters;
	UnityProtocolChannelType channel_type;
	gchar* id;
	UnityScopeSearchBase* last_search;
	guint last_search_tag;
};

struct _UnityInternalScopeChannelClass {
	GObjectClass parent_class;
};

struct _UnityInternalScopeTrackerInitChannelData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeTracker* self;
	UnityInternalScopeChannel* master_channel;
	gchar* scope_id;
	UnityProtocolChannelType channel_type;
	UnityProtocolScopeProxy* proxy;
	const gchar* result;
	UnityInternalUtilsAsyncOnce* proxy_once;
	UnityInternalUtilsAsyncOnce* _tmp0_;
	GError* failure;
	GHashTable* _tmp1_;
	GHashTable* _tmp2_;
	gconstpointer _tmp3_;
	UnityInternalUtilsAsyncOnce* _tmp4_;
	UnityInternalUtilsAsyncOnce* _tmp5_;
	UnityProtocolScopeProxy* actual_proxy;
	GHashTable* _tmp6_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp7_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp8_;
	GHashTable* _tmp9_;
	gchar* _tmp10_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp11_;
	UnityProtocolScopeRegistryScopeMetadata* metadata;
	GHashTable* _tmp12_;
	gconstpointer _tmp13_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp14_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp15_;
	UnityProtocolScopeProxy* _tmp16_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp17_;
	UnityProtocolScopeProxy* _tmp18_;
	UnityProtocolScopeProxy* _tmp19_;
	UnityProtocolScopeProxy* _tmp20_;
	DeeSerializableModel* _tmp21_;
	DeeSerializableModel* _tmp22_;
	UnityProtocolScopeProxy* _tmp23_;
	UnityProtocolScopeProxy* _tmp24_;
	GError* e;
	GError* _tmp25_;
	GError* _tmp26_;
	UnityInternalUtilsAsyncOnce* _tmp27_;
	UnityProtocolScopeProxy* _tmp28_;
	UnityInternalUtilsAsyncOnce* _tmp29_;
	gconstpointer _tmp30_;
	UnityProtocolScopeProxy* _tmp31_;
	UnityProtocolScopeProxy* _tmp32_;
	gboolean _tmp33_;
	GError* _tmp34_;
	GError* _tmp35_;
	UnityInternalUtilsAsyncOnce* _tmp36_;
	GError* _tmp37_;
	GError* _tmp38_;
	const gchar* _tmp39_;
	GError* _tmp40_;
	GError* _tmp41_;
	const gchar* _tmp42_;
	gchar* msg;
	gchar* _tmp43_;
	const gchar* _tmp44_;
	GError* _tmp45_;
	gchar* channel_key;
	const gchar* _tmp46_;
	UnityProtocolScopeProxy* _tmp47_;
	gchar* _tmp48_;
	UnityInternalUtilsAsyncOnce* channel_id_once;
	const gchar* _tmp49_;
	UnityInternalUtilsAsyncOnce* _tmp50_;
	UnityInternalUtilsAsyncOnce* _tmp51_;
	UnityInternalUtilsAsyncOnce* _tmp52_;
	DeeSerializableModel* model;
	gchar* chan_id;
	gchar* _tmp53_;
	UnityProtocolScopeProxy* _tmp54_;
	DeeSerializableModel* _tmp55_;
	gchar* _tmp56_;
	gchar* _tmp57_;
	GHashTable* _tmp58_;
	const gchar* _tmp59_;
	gchar* _tmp60_;
	DeeSerializableModel* _tmp61_;
	DeeSerializableModel* _tmp62_;
	UnityInternalResultsSynchronizer* synchronizer;
	GHashTable* _tmp63_;
	const gchar* _tmp64_;
	gconstpointer _tmp65_;
	UnityInternalResultsSynchronizer* _tmp66_;
	UnityInternalResultsSynchronizer* _tmp67_;
	UnityInternalResultsSynchronizer* _tmp68_;
	DeeSerializableModel* _tmp69_;
	const gchar* _tmp70_;
	UnityInternalChannelUpdateFlags _tmp71_;
	UnityProtocolChannelType _tmp72_;
	UnityInternalChannelUpdateFlags flag;
	GHashTable* _tmp73_;
	UnityProtocolScopeProxy* _tmp74_;
	gchar* _tmp75_;
	UnityInternalChannelUpdateFlags _tmp76_;
	UnityInternalUtilsAsyncOnce* _tmp77_;
	const gchar* _tmp78_;
	const gchar* scope_channel_id;
	UnityInternalUtilsAsyncOnce* _tmp79_;
	gconstpointer _tmp80_;
	const gchar* _tmp81_;
	UnityInternalUtilsAsyncOnce* _tmp82_;
	const gchar* _tmp83_;
	GError * _inner_error_;
};

struct _UnityInternalScopeTrackerActivateWrapperData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeTracker* self;
	UnityInternalScopeChannel* master_channel;
	gchar* scope_id;
	GVariant** result_arr;
	gint result_arr_length1;
	guint action_type;
	GHashTable* hints;
	GCancellable* cancellable;
	UnityProtocolActivationReplyRaw result;
	UnityProtocolScopeProxy* proxy;
	const gchar* scope_channel_id;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	UnityProtocolScopeProxy* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	UnityProtocolChannelType _tmp6_;
	UnityProtocolScopeProxy* _tmp7_;
	const gchar* _tmp8_;
	UnityProtocolActionType action;
	UnityProtocolActivationReplyRaw _tmp9_;
	UnityProtocolScopeProxy* _tmp10_;
	const gchar* _tmp11_;
	UnityProtocolActionType _tmp12_;
	UnityProtocolActivationReplyRaw _tmp13_;
	UnityProtocolActivationReplyRaw _tmp14_;
	GError * _inner_error_;
};

struct _UnityInternalScopeTrackerSearchWrapperData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeTracker* self;
	UnityInternalScopeChannel* master_channel;
	UnityProtocolChannelType channel_type;
	gchar* search_string;
	GHashTable* hints;
	gchar* scope_id;
	GCancellable* cancellable;
	GHashTable* result;
	UnityProtocolScopeProxy* proxy;
	const gchar* scope_channel_id;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	UnityProtocolScopeProxy* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	UnityProtocolScopeProxy* _tmp6_;
	const gchar* _tmp7_;
	GHashTable* reply_hints;
	GHashFunc _tmp8_;
	GEqualFunc _tmp9_;
	GHashTable* _tmp10_;
	gboolean _tmp11_;
	GHashTable* _tmp12_;
	gconstpointer _tmp13_;
	const gchar* _tmp14_;
	gchar* channel_key;
	const gchar* _tmp15_;
	UnityProtocolScopeProxy* _tmp16_;
	gchar* _tmp17_;
	guint64 last_seq_num;
	GHashTable* _tmp18_;
	const gchar* _tmp19_;
	gconstpointer _tmp20_;
	UnityInternalResultsSynchronizer* sync;
	GHashTable* _tmp21_;
	const gchar* _tmp22_;
	gconstpointer _tmp23_;
	UnityInternalResultsSynchronizer* _tmp24_;
	UnityInternalResultsSynchronizer* _tmp25_;
	GHashTable* reply_dict;
	UnityProtocolScopeProxy* _tmp26_;
	const gchar* _tmp27_;
	GHashTable* _tmp28_;
	GHashTableIter iter;
	GHashTable* _tmp29_;
	const gchar* key;
	GVariant* variant;
	gconstpointer _tmp30_;
	gconstpointer _tmp31_;
	gboolean _tmp32_;
	const gchar* _tmp33_;
	guint64 seqnum;
	GVariant* _tmp34_;
	DeeSerializableModel* model;
	GHashTable* _tmp35_;
	const gchar* _tmp36_;
	gconstpointer _tmp37_;
	DeeSerializableModel* _tmp38_;
	DeeSerializableModel* _tmp39_;
	guint64 _tmp40_;
	DeeSerializableModel* _tmp41_;
	guint64 _tmp42_;
	GHashTable* _tmp43_;
	const gchar* _tmp44_;
	gconstpointer _tmp45_;
	DeeSerializableModel* _tmp46_;
	guint64 _tmp47_;
	guint64 _tmp48_;
	const gchar* _tmp49_;
	UnityInternalResultsSynchronizer* synchronizer;
	const gchar* _tmp50_;
	UnityInternalResultsSynchronizer* _tmp51_;
	UnityInternalResultsSynchronizer* _tmp52_;
	UnityInternalResultsSynchronizer* _tmp53_;
	UnityInternalResultsSynchronizer* _tmp54_;
	DeeSerializableModel* _tmp55_;
	const gchar* _tmp56_;
	const gchar* _tmp57_;
	GHashTable* _tmp58_;
	gchar* _tmp59_;
	GVariant* _tmp60_;
	GVariant* _tmp61_;
	GHashTable* _tmp62_;
	const gchar* _tmp63_;
	gchar* _tmp64_;
	GVariant* _tmp65_;
	GVariant* _tmp66_;
	UnityInternalResultsSynchronizer* _tmp67_;
	GError * _inner_error_;
};

struct _UnityInternalScopeTrackerPushWrapperData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalScopeTracker* self;
	UnityInternalScopeChannel* parent_channel;
	gchar* search_string;
	UnityProtocolChannelType channel_type;
	gchar* master_scope_id;
	gchar* scope_id;
	DeeSerializableModel* results_model;
	gchar** categories;
	gint categories_length1;
	GCancellable* cancellable;
	UnityProtocolScopeProxy* proxy;
	const gchar* scope_channel_id;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	UnityProtocolScopeProxy* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	UnityProtocolScopeProxy* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* channel_key;
	const gchar* _tmp9_;
	UnityProtocolScopeProxy* _tmp10_;
	gchar* _tmp11_;
	UnityInternalResultsSynchronizer* sync;
	GHashTable* _tmp12_;
	const gchar* _tmp13_;
	gconstpointer _tmp14_;
	UnityInternalResultsSynchronizer* _tmp15_;
	UnityInternalResultsSynchronizer* _tmp16_;
	GHashTable* reply_dict;
	UnityProtocolScopeProxy* _tmp17_;
	const gchar* _tmp18_;
	GHashTable* _tmp19_;
	GHashTableIter iter;
	GHashTable* _tmp20_;
	const gchar* key;
	GVariant* variant;
	gconstpointer _tmp21_;
	gconstpointer _tmp22_;
	gboolean _tmp23_;
	const gchar* _tmp24_;
	guint64 seqnum;
	GVariant* _tmp25_;
	DeeSerializableModel* model;
	GHashTable* _tmp26_;
	const gchar* _tmp27_;
	gconstpointer _tmp28_;
	DeeSerializableModel* _tmp29_;
	DeeSerializableModel* _tmp30_;
	guint64 _tmp31_;
	DeeSerializableModel* _tmp32_;
	guint64 _tmp33_;
	UnityInternalResultsSynchronizer* _tmp34_;
	GError * _inner_error_;
};


static gpointer unity_internal_scope_tracker_parent_class = NULL;
extern GQuark unity_internal_scope_tracker_DEDUP_MODEL_QUARK;
GQuark unity_internal_scope_tracker_DEDUP_MODEL_QUARK = 0U;

GType unity_internal_channel_update_flags_get_type (void) G_GNUC_CONST;
GType unity_internal_scope_tracker_get_type (void) G_GNUC_CONST;
gpointer unity_internal_utils_async_once_ref (gpointer instance);
void unity_internal_utils_async_once_unref (gpointer instance);
GParamSpec* unity_internal_utils_param_spec_async_once (const gchar* name,
                                                        const gchar* nick,
                                                        const gchar* blurb,
                                                        GType object_type,
                                                        GParamFlags flags);
void unity_internal_utils_value_set_async_once (GValue* value,
                                                gpointer v_object);
void unity_internal_utils_value_take_async_once (GValue* value,
                                                 gpointer v_object);
gpointer unity_internal_utils_value_get_async_once (const GValue* value);
GType unity_internal_utils_async_once_get_type (void) G_GNUC_CONST;
GType unity_internal_results_synchronizer_get_type (void) G_GNUC_CONST;
#define UNITY_INTERNAL_SCOPE_TRACKER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_INTERNAL_TYPE_SCOPE_TRACKER, UnityInternalScopeTrackerPrivate))
#define UNITY_INTERNAL_SCOPE_TRACKER_MODEL_UPDATE_TIMEOUT_SECS 30
UnityInternalScopeTracker* unity_internal_scope_tracker_new (void);
UnityInternalScopeTracker* unity_internal_scope_tracker_construct (GType object_type);
static void _g_object_unref0_ (gpointer var);
static void _g_free0_ (gpointer var);
static void _unity_internal_utils_async_once_unref0_ (gpointer var);
static void _unity_protocol_scope_registry_scope_metadata_unref0_ (gpointer var);
GList* unity_internal_scope_tracker_scope_ids_for_proxies (UnityInternalScopeTracker* self);
UnityProtocolScopeProxy* unity_internal_scope_tracker_get_proxy_for_scope_id (UnityInternalScopeTracker* self,
                                                                              const gchar* scope_id);
static UnityInternalUtilsAsyncOnce* unity_internal_scope_tracker_get_proxy_once (UnityInternalScopeTracker* self,
                                                                          const gchar* scope_id);
gboolean unity_internal_utils_async_once_is_initialized (UnityInternalUtilsAsyncOnce* self);
gconstpointer unity_internal_utils_async_once_get_data (UnityInternalUtilsAsyncOnce* self);
gchar* unity_internal_scope_tracker_get_scope_id_for_proxy (UnityInternalScopeTracker* self,
                                                            UnityProtocolScopeProxy* proxy);
UnityInternalResultsSynchronizer* unity_internal_scope_tracker_get_synchronizer (UnityInternalScopeTracker* self,
                                                                                 const gchar* channel_id);
static gboolean unity_internal_scope_tracker_content_enabled (UnityInternalScopeTracker* self,
                                                       UnityProtocolScopeRegistryScopeMetadata* metadata);
static void unity_internal_scope_tracker_perform_checks (UnityInternalScopeTracker* self,
                                                  UnityProtocolScopeRegistryScopeMetadata* metadata,
                                                  UnityProtocolChannelType requested_channel_type,
                                                  GError** error);
static void unity_internal_scope_tracker_create_proxy_data_free (gpointer _data);
static void unity_internal_scope_tracker_create_proxy_async_ready_wrapper (GObject *source_object,
                                                                    GAsyncResult *res,
                                                                    void *user_data);
void unity_internal_scope_tracker_create_proxy (UnityInternalScopeTracker* self,
                                                UnityProtocolScopeRegistryScopeMetadata* metadata,
                                                GAsyncReadyCallback _callback_,
                                                gpointer _user_data_);
UnityProtocolScopeProxy* unity_internal_scope_tracker_create_proxy_finish (UnityInternalScopeTracker* self,
                                                                           GAsyncResult* _res_,
                                                                           GError** error);
static gboolean unity_internal_scope_tracker_create_proxy_co (UnityInternalScopeTrackerCreateProxyData* _data_);
static void unity_internal_scope_tracker_create_proxy_ready (GObject* source_object,
                                                      GAsyncResult* _res_,
                                                      gpointer _user_data_);
static inline void _dynamic_set_auto_reconnect0 (UnityProtocolScopeProxy* obj,
                                   gboolean value);
static void unity_internal_scope_tracker_check_proxy_vs_metadata (UnityInternalScopeTracker* self,
                                                           UnityProtocolScopeProxy* proxy,
                                                           UnityProtocolScopeRegistryScopeMetadata* metadata,
                                                           GError** error);
static void unity_internal_scope_tracker_channels_invalidated (UnityInternalScopeTracker* self,
                                                        UnityProtocolScopeProxy* proxy);
static void _unity_internal_scope_tracker_channels_invalidated_unity_protocol_scope_proxy_channels_invalidated (UnityProtocolScopeProxy* _sender,
                                                                                                         gpointer self);
static void unity_internal_scope_tracker_on_results_invalidated (UnityInternalScopeTracker* self,
                                                          UnityProtocolScopeProxy* proxy,
                                                          UnityProtocolChannelType channel_type);
static void _unity_internal_scope_tracker_on_results_invalidated_unity_protocol_scope_proxy_results_invalidated (UnityProtocolScopeProxy* _sender,
                                                                                                          UnityProtocolChannelType channel_type,
                                                                                                          gpointer self);
static void _vala_array_add12 (gchar** * array,
                        int* length,
                        int* size,
                        gchar* value);
static gchar* unity_internal_scope_tracker_get_update_key (UnityInternalScopeTracker* self,
                                                    UnityProtocolScopeProxy* proxy,
                                                    UnityProtocolChannelType channel_type);
static gchar* unity_internal_scope_tracker_get_channel_key (UnityInternalScopeTracker* self,
                                                     const gchar* master_channel_id,
                                                     UnityProtocolScopeProxy* proxy);
GType unity_internal_merge_strategy_get_type (void) G_GNUC_CONST;
void unity_internal_scope_tracker_register_channel (UnityInternalScopeTracker* self,
                                                    const gchar* owner_scope_id,
                                                    const gchar* master_channel_id,
                                                    DeeSerializableModel* model,
                                                    UnityInternalMergeStrategy* merge_strategy);
UnityInternalResultsSynchronizer* unity_internal_results_synchronizer_new (DeeModel* receiver,
                                                                           const gchar* scope_id);
UnityInternalResultsSynchronizer* unity_internal_results_synchronizer_construct (GType object_type,
                                                                                 DeeModel* receiver,
                                                                                 const gchar* scope_id);
void unity_internal_results_synchronizer_set_merge_strategy (UnityInternalResultsSynchronizer* self,
                                                             UnityInternalMergeStrategy* value);
void unity_internal_scope_tracker_unregister_channel (UnityInternalScopeTracker* self,
                                                      const gchar* master_channel_id);
DeeModel* unity_internal_results_synchronizer_get_receiver (UnityInternalResultsSynchronizer* self);
static void unity_internal_scope_tracker_wait_for_seqnum_data_free (gpointer _data);
static void unity_internal_scope_tracker_wait_for_seqnum_async_ready_wrapper (GObject *source_object,
                                                                       GAsyncResult *res,
                                                                       void *user_data);
static void unity_internal_scope_tracker_wait_for_seqnum (UnityInternalScopeTracker* self,
                                                   DeeSharedModel* model,
                                                   guint64 seqnum,
                                                   GAsyncReadyCallback _callback_,
                                                   gpointer _user_data_);
static void unity_internal_scope_tracker_wait_for_seqnum_finish (UnityInternalScopeTracker* self,
                                                          GAsyncResult* _res_,
                                                          GError** error);
static gboolean unity_internal_scope_tracker_wait_for_seqnum_co (UnityInternalScopeTrackerWaitForSeqnumData* _data_);
static Block25Data* block25_data_ref (Block25Data* _data25_);
static void block25_data_unref (void * _userdata_);
static void __lambda20_ (Block25Data* _data25_,
                  DeeSharedModel* m,
                  guint64 begin_seqnum,
                  guint64 end_seqnum);
static void ___lambda20__dee_shared_model_end_transaction (DeeSharedModel* _sender,
                                                    guint64 begin_seqnum,
                                                    guint64 end_seqnum,
                                                    gpointer self);
static gboolean __lambda21_ (Block25Data* _data25_);
static gboolean ___lambda21__gsource_func (gpointer self);
UnityInternalUtilsAsyncOnce* unity_internal_utils_async_once_new (GType g_type,
                                                                  GBoxedCopyFunc g_dup_func,
                                                                  GDestroyNotify g_destroy_func);
UnityInternalUtilsAsyncOnce* unity_internal_utils_async_once_construct (GType object_type,
                                                                        GType g_type,
                                                                        GBoxedCopyFunc g_dup_func,
                                                                        GDestroyNotify g_destroy_func);
static UnityInternalUtilsAsyncOnce* unity_internal_scope_tracker_get_channel_id_once (UnityInternalScopeTracker* self,
                                                                               const gchar* channel_key);
static const gchar* unity_internal_scope_tracker_get_channel_id (UnityInternalScopeTracker* self,
                                                          const gchar* master_channel_id,
                                                          const gchar* scope_id,
                                                          UnityProtocolScopeProxy* * proxy,
                                                          GError** error);
static void unity_internal_scope_tracker_init_channel_data_free (gpointer _data);
static void unity_internal_scope_tracker_init_channel_async_ready_wrapper (GObject *source_object,
                                                                    GAsyncResult *res,
                                                                    void *user_data);
GType unity_internal_scope_channel_get_type (void) G_GNUC_CONST;
static void unity_internal_scope_tracker_init_channel (UnityInternalScopeTracker* self,
                                                UnityInternalScopeChannel* master_channel,
                                                const gchar* scope_id,
                                                UnityProtocolChannelType channel_type,
                                                GAsyncReadyCallback _callback_,
                                                gpointer _user_data_);
static const gchar* unity_internal_scope_tracker_init_channel_finish (UnityInternalScopeTracker* self,
                                                               GAsyncResult* _res_,
                                                               UnityProtocolScopeProxy* * proxy,
                                                               GError** error);
static gboolean unity_internal_scope_tracker_init_channel_co (UnityInternalScopeTrackerInitChannelData* _data_);
void unity_internal_utils_async_once_enter (UnityInternalUtilsAsyncOnce* self,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_);
gboolean unity_internal_utils_async_once_enter_finish (UnityInternalUtilsAsyncOnce* self,
                                                       GAsyncResult* _res_);
static void unity_internal_scope_tracker_init_channel_ready (GObject* source_object,
                                                      GAsyncResult* _res_,
                                                      gpointer _user_data_);
static void _____lambda22_ (UnityInternalScopeTracker* self,
                     GObject* obj,
                     GParamSpec* pspec);
static void ______lambda22__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
void unity_internal_utils_async_once_leave (UnityInternalUtilsAsyncOnce* self,
                                            gconstpointer _result_);
void unity_internal_utils_async_once_reset (UnityInternalUtilsAsyncOnce* self);
gpointer unity_internal_utils_async_mutex_ref (gpointer instance);
void unity_internal_utils_async_mutex_unref (gpointer instance);
GParamSpec* unity_internal_utils_param_spec_async_mutex (const gchar* name,
                                                         const gchar* nick,
                                                         const gchar* blurb,
                                                         GType object_type,
                                                         GParamFlags flags);
void unity_internal_utils_value_set_async_mutex (GValue* value,
                                                 gpointer v_object);
void unity_internal_utils_value_take_async_mutex (GValue* value,
                                                  gpointer v_object);
gpointer unity_internal_utils_value_get_async_mutex (const GValue* value);
GType unity_internal_utils_async_mutex_get_type (void) G_GNUC_CONST;
void unity_internal_results_synchronizer_add_provider (UnityInternalResultsSynchronizer* self,
                                                       DeeModel* provider,
                                                       const gchar* scope_id);
static void unity_internal_scope_tracker_activate_wrapper_data_free (gpointer _data);
static void unity_internal_scope_tracker_activate_wrapper_async_ready_wrapper (GObject *source_object,
                                                                        GAsyncResult *res,
                                                                        void *user_data);
void unity_internal_scope_tracker_activate_wrapper (UnityInternalScopeTracker* self,
                                                    UnityInternalScopeChannel* master_channel,
                                                    const gchar* scope_id,
                                                    GVariant** result_arr,
                                                    int result_arr_length1,
                                                    guint action_type,
                                                    GHashTable* hints,
                                                    GCancellable* cancellable,
                                                    GAsyncReadyCallback _callback_,
                                                    gpointer _user_data_);
void unity_internal_scope_tracker_activate_wrapper_finish (UnityInternalScopeTracker* self,
                                                           GAsyncResult* _res_,
                                                           UnityProtocolActivationReplyRaw* result,
                                                           GError** error);
static gboolean unity_internal_scope_tracker_activate_wrapper_co (UnityInternalScopeTrackerActivateWrapperData* _data_);
static void unity_internal_scope_tracker_activate_wrapper_ready (GObject* source_object,
                                                          GAsyncResult* _res_,
                                                          gpointer _user_data_);
static void unity_internal_scope_tracker_search_wrapper_data_free (gpointer _data);
static void unity_internal_scope_tracker_search_wrapper_async_ready_wrapper (GObject *source_object,
                                                                      GAsyncResult *res,
                                                                      void *user_data);
void unity_internal_scope_tracker_search_wrapper (UnityInternalScopeTracker* self,
                                                  UnityInternalScopeChannel* master_channel,
                                                  UnityProtocolChannelType channel_type,
                                                  const gchar* search_string,
                                                  GHashTable* hints,
                                                  const gchar* scope_id,
                                                  GCancellable* cancellable,
                                                  GAsyncReadyCallback _callback_,
                                                  gpointer _user_data_);
GHashTable* unity_internal_scope_tracker_search_wrapper_finish (UnityInternalScopeTracker* self,
                                                                GAsyncResult* _res_,
                                                                GError** error);
static gboolean unity_internal_scope_tracker_search_wrapper_co (UnityInternalScopeTrackerSearchWrapperData* _data_);
static void unity_internal_scope_tracker_search_wrapper_ready (GObject* source_object,
                                                        GAsyncResult* _res_,
                                                        gpointer _user_data_);
static void _g_variant_unref0_ (gpointer var);
void unity_internal_results_synchronizer_enable_provider (UnityInternalResultsSynchronizer* self,
                                                          const gchar* scope_id);
#define UNITY_INTERNAL_SEARCH_SEQNUM_HINT "model-seqnum"
void unity_internal_results_synchronizer_copy_model (UnityInternalResultsSynchronizer* self,
                                                     DeeModel* provider);
#define UNITY_INTERNAL_SEARCH_TIME_HINT "search-time"
void unity_internal_results_synchronizer_disable_provider (UnityInternalResultsSynchronizer* self,
                                                           const gchar* scope_id);
static void unity_internal_scope_tracker_push_wrapper_data_free (gpointer _data);
static void unity_internal_scope_tracker_push_wrapper_async_ready_wrapper (GObject *source_object,
                                                                    GAsyncResult *res,
                                                                    void *user_data);
void unity_internal_scope_tracker_push_wrapper (UnityInternalScopeTracker* self,
                                                UnityInternalScopeChannel* parent_channel,
                                                const gchar* search_string,
                                                UnityProtocolChannelType channel_type,
                                                const gchar* master_scope_id,
                                                const gchar* scope_id,
                                                DeeSerializableModel* results_model,
                                                gchar** categories,
                                                int categories_length1,
                                                GCancellable* cancellable,
                                                GAsyncReadyCallback _callback_,
                                                gpointer _user_data_);
void unity_internal_scope_tracker_push_wrapper_finish (UnityInternalScopeTracker* self,
                                                       GAsyncResult* _res_,
                                                       GError** error);
static gboolean unity_internal_scope_tracker_push_wrapper_co (UnityInternalScopeTrackerPushWrapperData* _data_);
static void unity_internal_scope_tracker_push_wrapper_ready (GObject* source_object,
                                                      GAsyncResult* _res_,
                                                      gpointer _user_data_);
static void g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure,
                                                  GValue * return_value,
                                                  guint n_param_values,
                                                  const GValue * param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);
static void unity_internal_scope_tracker_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);


GType
unity_internal_channel_update_flags_get_type (void)
{
	static volatile gsize unity_internal_channel_update_flags_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_channel_update_flags_type_id__volatile)) {
		static const GFlagsValue values[] = {{UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_NONE, "UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_NONE", "none"}, {UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_DEFAULT, "UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_DEFAULT", "default"}, {UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_GLOBAL, "UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_GLOBAL", "global"}, {0, NULL, NULL}};
		GType unity_internal_channel_update_flags_type_id;
		unity_internal_channel_update_flags_type_id = g_flags_register_static ("UnityInternalChannelUpdateFlags", values);
		g_once_init_leave (&unity_internal_channel_update_flags_type_id__volatile, unity_internal_channel_update_flags_type_id);
	}
	return unity_internal_channel_update_flags_type_id__volatile;
}


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
_unity_internal_utils_async_once_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (unity_internal_utils_async_once_unref (var), NULL));
}


static void
_unity_protocol_scope_registry_scope_metadata_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (unity_protocol_scope_registry_scope_metadata_unref (var), NULL));
}


UnityInternalScopeTracker*
unity_internal_scope_tracker_construct (GType object_type)
{
	UnityInternalScopeTracker * self = NULL;
	GPtrArray* _tmp0_;
	GHashFunc _tmp1_;
	GEqualFunc _tmp2_;
	GHashTable* _tmp3_;
	GHashFunc _tmp4_;
	GEqualFunc _tmp5_;
	GHashTable* _tmp6_;
	GHashFunc _tmp7_;
	GEqualFunc _tmp8_;
	GHashTable* _tmp9_;
	GHashFunc _tmp10_;
	GEqualFunc _tmp11_;
	GHashTable* _tmp12_;
	GHashFunc _tmp13_;
	GEqualFunc _tmp14_;
	GHashTable* _tmp15_;
	GHashFunc _tmp16_;
	GEqualFunc _tmp17_;
	GHashTable* _tmp18_;
	GHashFunc _tmp19_;
	GEqualFunc _tmp20_;
	GHashTable* _tmp21_;
	self = (UnityInternalScopeTracker*) g_object_new (object_type, NULL);
	_tmp0_ = g_ptr_array_new_full ((guint) 0, _g_object_unref0_);
	_g_ptr_array_unref0 (self->priv->scope_proxy_arr);
	self->priv->scope_proxy_arr = _tmp0_;
	_tmp1_ = g_str_hash;
	_tmp2_ = g_str_equal;
	_tmp3_ = g_hash_table_new_full (_tmp1_, _tmp2_, _g_free0_, _unity_internal_utils_async_once_unref0_);
	_g_hash_table_unref0 (self->priv->scope_proxies);
	self->priv->scope_proxies = _tmp3_;
	_tmp4_ = g_str_hash;
	_tmp5_ = g_str_equal;
	_tmp6_ = g_hash_table_new_full (_tmp4_, _tmp5_, _g_free0_, _unity_internal_utils_async_once_unref0_);
	_g_hash_table_unref0 (self->priv->scope_channel_ids);
	self->priv->scope_channel_ids = _tmp6_;
	_tmp7_ = g_str_hash;
	_tmp8_ = g_str_equal;
	_tmp9_ = g_hash_table_new_full (_tmp7_, _tmp8_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (self->priv->scope_models);
	self->priv->scope_models = _tmp9_;
	_tmp10_ = g_str_hash;
	_tmp11_ = g_str_equal;
	_tmp12_ = g_hash_table_new_full (_tmp10_, _tmp11_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (self->priv->synchronizers);
	self->priv->synchronizers = _tmp12_;
	_tmp13_ = g_str_hash;
	_tmp14_ = g_str_equal;
	_tmp15_ = g_hash_table_new_full (_tmp13_, _tmp14_, _g_free0_, NULL);
	_g_hash_table_unref0 (self->priv->master_update_flags);
	self->priv->master_update_flags = _tmp15_;
	_tmp16_ = g_str_hash;
	_tmp17_ = g_str_equal;
	_tmp18_ = g_hash_table_new_full (_tmp16_, _tmp17_, _g_free0_, _unity_protocol_scope_registry_scope_metadata_unref0_);
	_g_hash_table_unref0 (self->priv->scope_metadata);
	self->priv->scope_metadata = _tmp18_;
	_tmp19_ = g_str_hash;
	_tmp20_ = g_str_equal;
	_tmp21_ = g_hash_table_new_full (_tmp19_, _tmp20_, _g_free0_, NULL);
	_g_hash_table_unref0 (self->priv->binary_present);
	self->priv->binary_present = _tmp21_;
	return self;
}


UnityInternalScopeTracker*
unity_internal_scope_tracker_new (void)
{
	return unity_internal_scope_tracker_construct (UNITY_INTERNAL_TYPE_SCOPE_TRACKER);
}


GList*
unity_internal_scope_tracker_scope_ids_for_proxies (UnityInternalScopeTracker* self)
{
	GList* result = NULL;
	GHashTable* _tmp0_;
	GList* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->scope_proxies;
	_tmp1_ = g_hash_table_get_keys (_tmp0_);
	result = _tmp1_;
	return result;
}


UnityProtocolScopeProxy*
unity_internal_scope_tracker_get_proxy_for_scope_id (UnityInternalScopeTracker* self,
                                                     const gchar* scope_id)
{
	UnityProtocolScopeProxy* result = NULL;
	UnityInternalUtilsAsyncOnce* proxy_once = NULL;
	UnityInternalUtilsAsyncOnce* _tmp0_;
	UnityInternalUtilsAsyncOnce* _tmp1_;
	UnityInternalUtilsAsyncOnce* _tmp2_;
	gconstpointer _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (scope_id != NULL, NULL);
	_tmp0_ = unity_internal_scope_tracker_get_proxy_once (self, scope_id);
	proxy_once = _tmp0_;
	_tmp1_ = proxy_once;
	if (!unity_internal_utils_async_once_is_initialized (_tmp1_)) {
		result = NULL;
		_unity_internal_utils_async_once_unref0 (proxy_once);
		return result;
	}
	_tmp2_ = proxy_once;
	_tmp3_ = unity_internal_utils_async_once_get_data (_tmp2_);
	result = (UnityProtocolScopeProxy*) _tmp3_;
	_unity_internal_utils_async_once_unref0 (proxy_once);
	return result;
}


gchar*
unity_internal_scope_tracker_get_scope_id_for_proxy (UnityInternalScopeTracker* self,
                                                     UnityProtocolScopeProxy* proxy)
{
	gchar* result = NULL;
	GHashTableIter iter = {0};
	GHashTable* _tmp0_;
	const gchar* scope_id = NULL;
	UnityInternalUtilsAsyncOnce* val = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (proxy != NULL, NULL);
	_tmp0_ = self->priv->scope_proxies;
	g_hash_table_iter_init (&iter, _tmp0_);
	while (TRUE) {
		gconstpointer _tmp1_ = NULL;
		gconstpointer _tmp2_ = NULL;
		gboolean _tmp3_;
		UnityInternalUtilsAsyncOnce* _tmp4_;
		gconstpointer _tmp5_;
		_tmp3_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp1_), (gpointer*) (&_tmp2_));
		scope_id = _tmp1_;
		val = _tmp2_;
		if (!_tmp3_) {
			break;
		}
		_tmp4_ = val;
		_tmp5_ = unity_internal_utils_async_once_get_data (_tmp4_);
		if (((UnityProtocolScopeProxy*) _tmp5_) == proxy) {
			const gchar* _tmp6_;
			gchar* _tmp7_;
			_tmp6_ = scope_id;
			_tmp7_ = g_strdup (_tmp6_);
			result = _tmp7_;
			return result;
		}
	}
	result = NULL;
	return result;
}


UnityInternalResultsSynchronizer*
unity_internal_scope_tracker_get_synchronizer (UnityInternalScopeTracker* self,
                                               const gchar* channel_id)
{
	UnityInternalResultsSynchronizer* result = NULL;
	GHashTable* _tmp0_;
	gconstpointer _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (channel_id != NULL, NULL);
	_tmp0_ = self->priv->synchronizers;
	_tmp1_ = g_hash_table_lookup (_tmp0_, channel_id);
	result = (UnityInternalResultsSynchronizer*) _tmp1_;
	return result;
}


static gboolean
unity_internal_scope_tracker_content_enabled (UnityInternalScopeTracker* self,
                                              UnityProtocolScopeRegistryScopeMetadata* metadata)
{
	gboolean result = FALSE;
	UnityPreferencesManager* pref_man = NULL;
	UnityPreferencesManager* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (metadata != NULL, FALSE);
	_tmp0_ = unity_preferences_manager_get_default ();
	pref_man = _tmp0_;
	_tmp2_ = metadata->remote_content;
	if (_tmp2_) {
		UnityPreferencesManager* _tmp3_;
		UnityPreferencesManagerRemoteContent _tmp4_;
		UnityPreferencesManagerRemoteContent _tmp5_;
		_tmp3_ = pref_man;
		_tmp4_ = unity_preferences_manager_get_remote_content_search (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp1_ = _tmp5_ == UNITY_PREFERENCES_MANAGER_REMOTE_CONTENT_NONE;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		result = FALSE;
		_g_object_unref0 (pref_man);
		return result;
	}
	result = TRUE;
	_g_object_unref0 (pref_man);
	return result;
}


static void
unity_internal_scope_tracker_perform_checks (UnityInternalScopeTracker* self,
                                             UnityProtocolScopeRegistryScopeMetadata* metadata,
                                             UnityProtocolChannelType requested_channel_type,
                                             GError** error)
{
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (metadata != NULL);
	if (!unity_internal_scope_tracker_content_enabled (self, metadata)) {
		GError* _tmp0_;
		_tmp0_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DISABLED_CONTENT, "Requested content disabled");
		_inner_error_ = _tmp0_;
		if (_inner_error_->domain == UNITY_PROTOCOL_SCOPE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = metadata->global_searches;
	if (!_tmp2_) {
		_tmp1_ = requested_channel_type == UNITY_PROTOCOL_CHANNEL_TYPE_GLOBAL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		GError* _tmp3_;
		_tmp3_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DISABLED_CONTENT, "Global search is disabled");
		_inner_error_ = _tmp3_;
		if (_inner_error_->domain == UNITY_PROTOCOL_SCOPE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp5_ = metadata->query_binary;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		_tmp6_ = metadata->query_binary;
		_tmp4_ = g_strcmp0 (_tmp6_, "") != 0;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		GHashTable* _tmp7_;
		const gchar* _tmp8_;
		GHashTable* _tmp15_;
		const gchar* _tmp16_;
		gconstpointer _tmp17_;
		_tmp7_ = self->priv->binary_present;
		_tmp8_ = metadata->query_binary;
		if (!g_hash_table_contains (_tmp7_, _tmp8_)) {
			GHashTable* _tmp9_;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			const gchar* _tmp12_;
			gchar* _tmp13_;
			gchar* _tmp14_;
			_tmp9_ = self->priv->binary_present;
			_tmp10_ = metadata->query_binary;
			_tmp11_ = g_strdup (_tmp10_);
			_tmp12_ = metadata->query_binary;
			_tmp13_ = g_find_program_in_path (_tmp12_);
			_tmp14_ = _tmp13_;
			g_hash_table_insert (_tmp9_, _tmp11_, (gpointer) ((gintptr) (_tmp14_ != NULL)));
			_g_free0 (_tmp14_);
		}
		_tmp15_ = self->priv->binary_present;
		_tmp16_ = metadata->query_binary;
		_tmp17_ = g_hash_table_lookup (_tmp15_, _tmp16_);
		if (!((gboolean) ((gintptr) _tmp17_))) {
			GError* _tmp18_;
			_tmp18_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DISABLED_CONTENT, "Required application isn't installed");
			_inner_error_ = _tmp18_;
			if (_inner_error_->domain == UNITY_PROTOCOL_SCOPE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static void
unity_internal_scope_tracker_create_proxy_data_free (gpointer _data)
{
	UnityInternalScopeTrackerCreateProxyData* _data_;
	_data_ = _data;
	_unity_protocol_scope_registry_scope_metadata_unref0 (_data_->metadata);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeTrackerCreateProxyData, _data_);
}


static void
unity_internal_scope_tracker_create_proxy_async_ready_wrapper (GObject *source_object,
                                                               GAsyncResult *res,
                                                               void *user_data)
{
	UnityInternalScopeTrackerCreateProxyData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static gpointer
_unity_protocol_scope_registry_scope_metadata_ref0 (gpointer self)
{
	return self ? unity_protocol_scope_registry_scope_metadata_ref (self) : NULL;
}


void
unity_internal_scope_tracker_create_proxy (UnityInternalScopeTracker* self,
                                           UnityProtocolScopeRegistryScopeMetadata* metadata,
                                           GAsyncReadyCallback _callback_,
                                           gpointer _user_data_)
{
	UnityInternalScopeTrackerCreateProxyData* _data_;
	UnityInternalScopeTracker* _tmp0_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp1_;
	_data_ = g_slice_new0 (UnityInternalScopeTrackerCreateProxyData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, unity_internal_scope_tracker_create_proxy_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_tracker_create_proxy_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _unity_protocol_scope_registry_scope_metadata_ref0 (metadata);
	_unity_protocol_scope_registry_scope_metadata_unref0 (_data_->metadata);
	_data_->metadata = _tmp1_;
	unity_internal_scope_tracker_create_proxy_co (_data_);
}


UnityProtocolScopeProxy*
unity_internal_scope_tracker_create_proxy_finish (UnityInternalScopeTracker* self,
                                                  GAsyncResult* _res_,
                                                  GError** error)
{
	UnityProtocolScopeProxy* result;
	UnityInternalScopeTrackerCreateProxyData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static void
unity_internal_scope_tracker_create_proxy_ready (GObject* source_object,
                                                 GAsyncResult* _res_,
                                                 gpointer _user_data_)
{
	UnityInternalScopeTrackerCreateProxyData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_scope_tracker_create_proxy_co (_data_);
}


static inline void
_dynamic_set_auto_reconnect0 (UnityProtocolScopeProxy* obj,
                              gboolean value)
{
	g_object_set (obj, "auto-reconnect", value, NULL);
}


static void
_unity_internal_scope_tracker_channels_invalidated_unity_protocol_scope_proxy_channels_invalidated (UnityProtocolScopeProxy* _sender,
                                                                                                    gpointer self)
{
	unity_internal_scope_tracker_channels_invalidated ((UnityInternalScopeTracker*) self, _sender);
}


static void
_unity_internal_scope_tracker_on_results_invalidated_unity_protocol_scope_proxy_results_invalidated (UnityProtocolScopeProxy* _sender,
                                                                                                     UnityProtocolChannelType channel_type,
                                                                                                     gpointer self)
{
	unity_internal_scope_tracker_on_results_invalidated ((UnityInternalScopeTracker*) self, _sender, channel_type);
}


static gboolean
unity_internal_scope_tracker_create_proxy_co (UnityInternalScopeTrackerCreateProxyData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	unity_protocol_scope_proxy_new_from_metadata (_data_->metadata, NULL, unity_internal_scope_tracker_create_proxy_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp0_ = unity_protocol_scope_proxy_new_from_metadata_finish (_data_->_res_, &_data_->_inner_error_);
	_data_->proxy = _data_->_tmp0_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp1_ = _data_->proxy;
	_data_->_tmp2_ = _g_object_ref0 (_data_->_tmp1_);
	_data_->remote_proxy = _data_->_tmp2_;
	_data_->_tmp3_ = _data_->remote_proxy;
	_dynamic_set_auto_reconnect0 (_data_->_tmp3_, FALSE);
	_data_->_tmp4_ = _data_->proxy;
	unity_internal_scope_tracker_check_proxy_vs_metadata (_data_->self, _data_->_tmp4_, _data_->metadata, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->remote_proxy);
		_g_object_unref0 (_data_->proxy);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp5_ = _data_->self->priv->scope_proxy_arr;
	_data_->_tmp6_ = _data_->proxy;
	_data_->_tmp7_ = _g_object_ref0 (_data_->_tmp6_);
	g_ptr_array_add (_data_->_tmp5_, _data_->_tmp7_);
	_data_->_tmp8_ = _data_->proxy;
	g_signal_connect_object (_data_->_tmp8_, "channels-invalidated", (GCallback) _unity_internal_scope_tracker_channels_invalidated_unity_protocol_scope_proxy_channels_invalidated, _data_->self, 0);
	_data_->_tmp9_ = _data_->proxy;
	g_signal_connect_object (_data_->_tmp9_, "results-invalidated", (GCallback) _unity_internal_scope_tracker_on_results_invalidated_unity_protocol_scope_proxy_results_invalidated, _data_->self, 0);
	_data_->result = _data_->proxy;
	_g_object_unref0 (_data_->remote_proxy);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
_vala_array_add12 (gchar** * array,
                   int* length,
                   int* size,
                   gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void
unity_internal_scope_tracker_channels_invalidated (UnityInternalScopeTracker* self,
                                                   UnityProtocolScopeProxy* proxy)
{
	gchar** invalid_keys = NULL;
	gchar** _tmp0_;
	gint invalid_keys_length1;
	gint _invalid_keys_size_;
	gchar* prefix = NULL;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	GHashTable* _tmp3_;
	GList* _tmp4_;
	gchar** _tmp10_;
	gint _tmp10__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (proxy != NULL);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	invalid_keys = _tmp0_;
	invalid_keys_length1 = 0;
	_invalid_keys_size_ = invalid_keys_length1;
	_tmp1_ = g_strdup_printf ("%p::", proxy);
	prefix = _tmp1_;
	_tmp2_ = prefix;
	g_debug ("unity-scope-tracker.vala:172: Invalidating channels for %s", _tmp2_);
	_tmp3_ = self->priv->scope_channel_ids;
	_tmp4_ = g_hash_table_get_keys (_tmp3_);
	{
		GList* channel_key_collection = NULL;
		GList* channel_key_it = NULL;
		channel_key_collection = _tmp4_;
		for (channel_key_it = channel_key_collection; channel_key_it != NULL; channel_key_it = channel_key_it->next) {
			const gchar* channel_key = NULL;
			channel_key = (const gchar*) channel_key_it->data;
			{
				const gchar* _tmp5_;
				const gchar* _tmp6_;
				_tmp5_ = channel_key;
				_tmp6_ = prefix;
				if (g_str_has_prefix (_tmp5_, _tmp6_)) {
					gchar** _tmp7_;
					gint _tmp7__length1;
					const gchar* _tmp8_;
					gchar* _tmp9_;
					_tmp7_ = invalid_keys;
					_tmp7__length1 = invalid_keys_length1;
					_tmp8_ = channel_key;
					_tmp9_ = g_strdup (_tmp8_);
					_vala_array_add12 (&invalid_keys, &invalid_keys_length1, &_invalid_keys_size_, _tmp9_);
				}
			}
		}
		(channel_key_collection == NULL) ? NULL : (channel_key_collection = (g_list_free (channel_key_collection), NULL));
	}
	_tmp10_ = invalid_keys;
	_tmp10__length1 = invalid_keys_length1;
	{
		gchar** channel_key_collection = NULL;
		gint channel_key_collection_length1 = 0;
		gint _channel_key_collection_size_ = 0;
		gint channel_key_it = 0;
		channel_key_collection = _tmp10_;
		channel_key_collection_length1 = _tmp10__length1;
		for (channel_key_it = 0; channel_key_it < _tmp10__length1; channel_key_it = channel_key_it + 1) {
			const gchar* channel_key = NULL;
			channel_key = channel_key_collection[channel_key_it];
			{
				GHashTable* _tmp11_;
				const gchar* _tmp12_;
				GHashTable* _tmp13_;
				const gchar* _tmp14_;
				_tmp11_ = self->priv->scope_channel_ids;
				_tmp12_ = channel_key;
				g_hash_table_remove (_tmp11_, _tmp12_);
				_tmp13_ = self->priv->scope_models;
				_tmp14_ = channel_key;
				g_hash_table_remove (_tmp13_, _tmp14_);
			}
		}
	}
	_g_free0 (prefix);
	invalid_keys = (_vala_array_free (invalid_keys, invalid_keys_length1, (GDestroyNotify) g_free), NULL);
}


static void
unity_internal_scope_tracker_on_results_invalidated (UnityInternalScopeTracker* self,
                                                     UnityProtocolScopeProxy* proxy,
                                                     UnityProtocolChannelType channel_type)
{
	UnityInternalChannelUpdateFlags flags = 0;
	GHashTable* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gconstpointer _tmp3_;
	UnityInternalChannelUpdateFlags _tmp4_;
	UnityInternalChannelUpdateFlags _tmp5_;
	UnityInternalChannelUpdateFlags _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (proxy != NULL);
	_tmp0_ = self->priv->master_update_flags;
	_tmp1_ = unity_internal_scope_tracker_get_update_key (self, proxy, channel_type);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_hash_table_lookup (_tmp0_, _tmp2_);
	_tmp4_ = (UnityInternalChannelUpdateFlags) ((gintptr) _tmp3_);
	_g_free0 (_tmp2_);
	flags = _tmp4_;
	_tmp5_ = flags;
	if (_tmp5_ == UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_NONE) {
		return;
	}
	_tmp6_ = flags;
	g_signal_emit (self, unity_internal_scope_tracker_signals[UNITY_INTERNAL_SCOPE_TRACKER_RESULTS_INVALIDATED_SIGNAL], 0, _tmp6_);
}


static void
unity_internal_scope_tracker_check_proxy_vs_metadata (UnityInternalScopeTracker* self,
                                                      UnityProtocolScopeProxy* proxy,
                                                      UnityProtocolScopeRegistryScopeMetadata* metadata,
                                                      GError** error)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	UnityProtocolMetaDataSchemaInfo* _tmp8_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (proxy != NULL);
	g_return_if_fail (metadata != NULL);
	_tmp0_ = unity_protocol_scope_proxy_get_is_master (proxy);
	_tmp1_ = _tmp0_;
	_tmp2_ = metadata->is_master;
	if (_tmp1_ != _tmp2_) {
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		GError* _tmp6_;
		GError* _tmp7_;
		_tmp3_ = metadata->id;
		_tmp4_ = g_strdup_printf ("Scope file info for '%s' doesn't match on IsMaster key", _tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DATA_MISMATCH, _tmp5_);
		_tmp7_ = _tmp6_;
		_g_free0 (_tmp5_);
		_inner_error_ = _tmp7_;
		g_propagate_error (error, _inner_error_);
		return;
	}
	_tmp8_ = metadata->required_metadata;
	if (_tmp8_ != NULL) {
		GHashTable* dict = NULL;
		UnityProtocolMetaDataSchemaInfo* _tmp9_;
		GHashTable* _tmp10_;
		const gchar* field_name = NULL;
		const gchar* schema = NULL;
		GHashTableIter iter = {0};
		GHashTable* _tmp11_;
		_tmp9_ = metadata->required_metadata;
		_tmp10_ = unity_protocol_meta_data_schema_info_as_hash_table (_tmp9_);
		dict = _tmp10_;
		_tmp11_ = dict;
		g_hash_table_iter_init (&iter, _tmp11_);
		while (TRUE) {
			gconstpointer _tmp12_ = NULL;
			gconstpointer _tmp13_ = NULL;
			gboolean _tmp14_;
			GHashTable* _tmp15_;
			GHashTable* _tmp16_;
			const gchar* _tmp17_;
			gconstpointer _tmp18_;
			const gchar* _tmp19_;
			_tmp14_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp12_), (gpointer*) (&_tmp13_));
			field_name = _tmp12_;
			schema = _tmp13_;
			if (!_tmp14_) {
				break;
			}
			_tmp15_ = unity_protocol_scope_proxy_get_metadata (proxy);
			_tmp16_ = _tmp15_;
			_tmp17_ = field_name;
			_tmp18_ = g_hash_table_lookup (_tmp16_, _tmp17_);
			_tmp19_ = schema;
			if (g_strcmp0 ((const gchar*) _tmp18_, _tmp19_) != 0) {
				const gchar* _tmp20_;
				gchar* _tmp21_;
				gchar* _tmp22_;
				GError* _tmp23_;
				GError* _tmp24_;
				_tmp20_ = metadata->id;
				_tmp21_ = g_strdup_printf ("Scope file info for '%s' doesn't match on RequiredMetadata key", _tmp20_);
				_tmp22_ = _tmp21_;
				_tmp23_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DATA_MISMATCH, _tmp22_);
				_tmp24_ = _tmp23_;
				_g_free0 (_tmp22_);
				_inner_error_ = _tmp24_;
				g_propagate_error (error, _inner_error_);
				_g_hash_table_unref0 (dict);
				return;
			}
		}
		_g_hash_table_unref0 (dict);
	}
}


static gchar*
unity_internal_scope_tracker_get_channel_key (UnityInternalScopeTracker* self,
                                              const gchar* master_channel_id,
                                              UnityProtocolScopeProxy* proxy)
{
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (master_channel_id != NULL, NULL);
	g_return_val_if_fail (proxy != NULL, NULL);
	_tmp0_ = g_strdup_printf ("%p::%s", proxy, master_channel_id);
	result = _tmp0_;
	return result;
}


static gchar*
unity_internal_scope_tracker_get_update_key (UnityInternalScopeTracker* self,
                                             UnityProtocolScopeProxy* proxy,
                                             UnityProtocolChannelType channel_type)
{
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (proxy != NULL, NULL);
	_tmp0_ = g_strdup_printf ("%p::%d", proxy, (gint) channel_type);
	result = _tmp0_;
	return result;
}


void
unity_internal_scope_tracker_register_channel (UnityInternalScopeTracker* self,
                                               const gchar* owner_scope_id,
                                               const gchar* master_channel_id,
                                               DeeSerializableModel* model,
                                               UnityInternalMergeStrategy* merge_strategy)
{
	UnityInternalResultsSynchronizer* synchronizer = NULL;
	UnityInternalResultsSynchronizer* _tmp0_;
	GHashTable* _tmp1_;
	gchar* _tmp2_;
	UnityInternalResultsSynchronizer* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (owner_scope_id != NULL);
	g_return_if_fail (master_channel_id != NULL);
	g_return_if_fail (model != NULL);
	g_return_if_fail (merge_strategy != NULL);
	_tmp0_ = unity_internal_results_synchronizer_new ((DeeModel*) model, owner_scope_id);
	synchronizer = _tmp0_;
	unity_internal_results_synchronizer_set_merge_strategy (synchronizer, merge_strategy);
	_tmp1_ = self->priv->synchronizers;
	_tmp2_ = g_strdup (master_channel_id);
	_tmp3_ = _g_object_ref0 (synchronizer);
	g_hash_table_insert (_tmp1_, _tmp2_, _tmp3_);
	_g_object_unref0 (synchronizer);
}


static gint
g_ptr_array_get_length (GPtrArray* self)
{
	gint result;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->len;
	result = (gint) _tmp0_;
	return result;
}


static void
g_ptr_array_set_length (GPtrArray* self,
                        gint value)
{
	g_return_if_fail (self != NULL);
	g_ptr_array_set_size (self, value);
}


void
unity_internal_scope_tracker_unregister_channel (UnityInternalScopeTracker* self,
                                                 const gchar* master_channel_id)
{
	UnityInternalResultsSynchronizer* synchronizer = NULL;
	GHashTable* _tmp0_;
	gconstpointer _tmp1_;
	UnityInternalResultsSynchronizer* _tmp2_;
	UnityInternalResultsSynchronizer* _tmp3_;
	GHashTable* channel_keys_to_close = NULL;
	GHashFunc _tmp9_;
	GEqualFunc _tmp10_;
	GHashTable* _tmp11_;
	GHashTableIter iter = {0};
	GHashTable* _tmp35_;
	const gchar* channel_key = NULL;
	UnityProtocolScopeProxy* proxy = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (master_channel_id != NULL);
	_tmp0_ = self->priv->synchronizers;
	_tmp1_ = g_hash_table_lookup (_tmp0_, master_channel_id);
	_tmp2_ = _g_object_ref0 ((UnityInternalResultsSynchronizer*) _tmp1_);
	synchronizer = _tmp2_;
	_tmp3_ = synchronizer;
	if (_tmp3_ != NULL) {
		UnityInternalResultsSynchronizer* _tmp4_;
		DeeModel* _tmp5_;
		DeeModel* _tmp6_;
		GQuark _tmp7_;
		GHashTable* _tmp8_;
		_tmp4_ = synchronizer;
		_tmp5_ = unity_internal_results_synchronizer_get_receiver (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = unity_internal_scope_tracker_DEDUP_MODEL_QUARK;
		g_object_set_qdata_full ((GObject*) _tmp6_, _tmp7_, NULL, g_object_unref);
		_tmp8_ = self->priv->synchronizers;
		g_hash_table_remove (_tmp8_, master_channel_id);
	}
	_tmp9_ = g_str_hash;
	_tmp10_ = g_str_equal;
	_tmp11_ = g_hash_table_new_full (_tmp9_, _tmp10_, _g_free0_, _g_object_unref0_);
	channel_keys_to_close = _tmp11_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				gint _tmp14_;
				GPtrArray* _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				gchar* channel_key = NULL;
				GPtrArray* _tmp18_;
				gint _tmp19_;
				gconstpointer _tmp20_;
				gchar* _tmp21_;
				GHashTable* _tmp22_;
				const gchar* _tmp23_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = self->priv->scope_proxy_arr;
				_tmp16_ = g_ptr_array_get_length (_tmp15_);
				_tmp17_ = _tmp16_;
				if (!(_tmp14_ < _tmp17_)) {
					break;
				}
				_tmp18_ = self->priv->scope_proxy_arr;
				_tmp19_ = i;
				_tmp20_ = g_ptr_array_index (_tmp18_, (guint) _tmp19_);
				_tmp21_ = unity_internal_scope_tracker_get_channel_key (self, master_channel_id, (UnityProtocolScopeProxy*) _tmp20_);
				channel_key = _tmp21_;
				_tmp22_ = self->priv->scope_channel_ids;
				_tmp23_ = channel_key;
				if (g_hash_table_contains (_tmp22_, _tmp23_)) {
					GHashTable* _tmp24_;
					const gchar* _tmp25_;
					gconstpointer _tmp26_;
					gconstpointer _tmp27_;
					_tmp24_ = self->priv->scope_channel_ids;
					_tmp25_ = channel_key;
					_tmp26_ = g_hash_table_lookup (_tmp24_, _tmp25_);
					_tmp27_ = unity_internal_utils_async_once_get_data ((UnityInternalUtilsAsyncOnce*) _tmp26_);
					if (((const gchar*) _tmp27_) != NULL) {
						GHashTable* _tmp28_;
						const gchar* _tmp29_;
						gchar* _tmp30_;
						GPtrArray* _tmp31_;
						gint _tmp32_;
						gconstpointer _tmp33_;
						UnityProtocolScopeProxy* _tmp34_;
						_tmp28_ = channel_keys_to_close;
						_tmp29_ = channel_key;
						_tmp30_ = g_strdup (_tmp29_);
						_tmp31_ = self->priv->scope_proxy_arr;
						_tmp32_ = i;
						_tmp33_ = g_ptr_array_index (_tmp31_, (guint) _tmp32_);
						_tmp34_ = _g_object_ref0 ((UnityProtocolScopeProxy*) _tmp33_);
						g_hash_table_insert (_tmp28_, _tmp30_, _tmp34_);
					}
				}
				_g_free0 (channel_key);
			}
		}
	}
	_tmp35_ = channel_keys_to_close;
	g_hash_table_iter_init (&iter, _tmp35_);
	while (TRUE) {
		gconstpointer _tmp36_ = NULL;
		gconstpointer _tmp37_ = NULL;
		gboolean _tmp38_;
		gchar* child_channel_id = NULL;
		GHashTable* _tmp39_;
		const gchar* _tmp40_;
		gconstpointer _tmp41_;
		gconstpointer _tmp42_;
		gchar* _tmp43_;
		const gchar* _tmp44_;
		UnityProtocolScopeProxy* _tmp45_;
		const gchar* _tmp46_;
		GHashTable* _tmp47_;
		const gchar* _tmp48_;
		GHashTable* _tmp49_;
		const gchar* _tmp50_;
		_tmp38_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp36_), (gpointer*) (&_tmp37_));
		channel_key = _tmp36_;
		proxy = _tmp37_;
		if (!_tmp38_) {
			break;
		}
		_tmp39_ = self->priv->scope_channel_ids;
		_tmp40_ = channel_key;
		_tmp41_ = g_hash_table_lookup (_tmp39_, _tmp40_);
		_tmp42_ = unity_internal_utils_async_once_get_data ((UnityInternalUtilsAsyncOnce*) _tmp41_);
		_tmp43_ = g_strdup ((const gchar*) _tmp42_);
		child_channel_id = _tmp43_;
		_tmp44_ = child_channel_id;
		if (_tmp44_ == NULL) {
			_g_free0 (child_channel_id);
			continue;
		}
		_tmp45_ = proxy;
		_tmp46_ = child_channel_id;
		unity_protocol_scope_proxy_close_channel (_tmp45_, _tmp46_, NULL, NULL, NULL);
		_tmp47_ = self->priv->scope_channel_ids;
		_tmp48_ = channel_key;
		g_hash_table_remove (_tmp47_, _tmp48_);
		_tmp49_ = self->priv->scope_models;
		_tmp50_ = channel_key;
		g_hash_table_remove (_tmp49_, _tmp50_);
		_g_free0 (child_channel_id);
	}
	_g_hash_table_unref0 (channel_keys_to_close);
	_g_object_unref0 (synchronizer);
}


static void
unity_internal_scope_tracker_wait_for_seqnum_data_free (gpointer _data)
{
	UnityInternalScopeTrackerWaitForSeqnumData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->model);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeTrackerWaitForSeqnumData, _data_);
}


static void
unity_internal_scope_tracker_wait_for_seqnum_async_ready_wrapper (GObject *source_object,
                                                                  GAsyncResult *res,
                                                                  void *user_data)
{
	UnityInternalScopeTrackerWaitForSeqnumData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static void
unity_internal_scope_tracker_wait_for_seqnum (UnityInternalScopeTracker* self,
                                              DeeSharedModel* model,
                                              guint64 seqnum,
                                              GAsyncReadyCallback _callback_,
                                              gpointer _user_data_)
{
	UnityInternalScopeTrackerWaitForSeqnumData* _data_;
	UnityInternalScopeTracker* _tmp0_;
	DeeSharedModel* _tmp1_;
	_data_ = g_slice_new0 (UnityInternalScopeTrackerWaitForSeqnumData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, unity_internal_scope_tracker_wait_for_seqnum_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_tracker_wait_for_seqnum_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (model);
	_g_object_unref0 (_data_->model);
	_data_->model = _tmp1_;
	_data_->seqnum = seqnum;
	unity_internal_scope_tracker_wait_for_seqnum_co (_data_);
}


static void
unity_internal_scope_tracker_wait_for_seqnum_finish (UnityInternalScopeTracker* self,
                                                     GAsyncResult* _res_,
                                                     GError** error)
{
	UnityInternalScopeTrackerWaitForSeqnumData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return;
	}
}


static Block25Data*
block25_data_ref (Block25Data* _data25_)
{
	g_atomic_int_inc (&_data25_->_ref_count_);
	return _data25_;
}


static void
block25_data_unref (void * _userdata_)
{
	Block25Data* _data25_;
	_data25_ = (Block25Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data25_->_ref_count_)) {
		UnityInternalScopeTracker* self;
		self = _data25_->self;
		_g_object_unref0 (self);
		g_slice_free (Block25Data, _data25_);
	}
}


static void
__lambda20_ (Block25Data* _data25_,
             DeeSharedModel* m,
             guint64 begin_seqnum,
             guint64 end_seqnum)
{
	UnityInternalScopeTracker* self;
	self = _data25_->self;
	g_return_if_fail (m != NULL);
	if (end_seqnum < _data25_->seqnum) {
		return;
	}
	unity_internal_scope_tracker_wait_for_seqnum_co (_data25_->_async_data_);
}


static void
___lambda20__dee_shared_model_end_transaction (DeeSharedModel* _sender,
                                               guint64 begin_seqnum,
                                               guint64 end_seqnum,
                                               gpointer self)
{
	__lambda20_ (self, _sender, begin_seqnum, end_seqnum);
}


static gboolean
__lambda21_ (Block25Data* _data25_)
{
	UnityInternalScopeTracker* self;
	gboolean result = FALSE;
	self = _data25_->self;
	_data25_->src_id = (guint) 0;
	unity_internal_scope_tracker_wait_for_seqnum_co (_data25_->_async_data_);
	result = FALSE;
	return result;
}


static gboolean
___lambda21__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda21_ (self);
	return result;
}


static gboolean
unity_internal_scope_tracker_wait_for_seqnum_co (UnityInternalScopeTrackerWaitForSeqnumData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data25_ = g_slice_new0 (Block25Data);
	_data_->_data25_->_ref_count_ = 1;
	_data_->_data25_->self = g_object_ref (_data_->self);
	_data_->_data25_->seqnum = _data_->seqnum;
	_data_->_data25_->_async_data_ = _data_;
	if (dee_serializable_model_get_seqnum ((DeeSerializableModel*) _data_->model) >= _data_->_data25_->seqnum) {
		block25_data_unref (_data_->_data25_);
		_data_->_data25_ = NULL;
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp0_ = g_signal_connect_data (_data_->model, "end-transaction", (GCallback) ___lambda20__dee_shared_model_end_transaction, block25_data_ref (_data_->_data25_), (GClosureNotify) block25_data_unref, 0);
	_data_->update_sig_id = _data_->_tmp0_;
	_data_->_data25_->src_id = (guint) 0;
	_data_->_data25_->src_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) UNITY_INTERNAL_SCOPE_TRACKER_MODEL_UPDATE_TIMEOUT_SECS, ___lambda21__gsource_func, block25_data_ref (_data_->_data25_), block25_data_unref);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->_tmp1_ = _data_->update_sig_id;
	g_signal_handler_disconnect (_data_->model, _data_->_tmp1_);
	_data_->_tmp2_ = _data_->_data25_->src_id;
	if (_data_->_tmp2_ != ((guint) 0)) {
		_data_->_tmp3_ = _data_->_data25_->src_id;
		g_source_remove (_data_->_tmp3_);
	} else {
		_data_->_tmp4_ = g_error_new_literal (G_DBUS_ERROR, G_DBUS_ERROR_TIMEOUT, "Timed out waiting for model update");
		_data_->_inner_error_ = _data_->_tmp4_;
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		block25_data_unref (_data_->_data25_);
		_data_->_data25_ = NULL;
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	block25_data_unref (_data_->_data25_);
	_data_->_data25_ = NULL;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gpointer
_unity_internal_utils_async_once_ref0 (gpointer self)
{
	return self ? unity_internal_utils_async_once_ref (self) : NULL;
}


static UnityInternalUtilsAsyncOnce*
unity_internal_scope_tracker_get_proxy_once (UnityInternalScopeTracker* self,
                                             const gchar* scope_id)
{
	UnityInternalUtilsAsyncOnce* result = NULL;
	UnityInternalUtilsAsyncOnce* proxy_once = NULL;
	GHashTable* _tmp0_;
	gconstpointer _tmp1_;
	UnityInternalUtilsAsyncOnce* _tmp2_;
	UnityInternalUtilsAsyncOnce* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (scope_id != NULL, NULL);
	_tmp0_ = self->priv->scope_proxies;
	_tmp1_ = g_hash_table_lookup (_tmp0_, scope_id);
	_tmp2_ = _unity_internal_utils_async_once_ref0 ((UnityInternalUtilsAsyncOnce*) _tmp1_);
	proxy_once = _tmp2_;
	_tmp3_ = proxy_once;
	if (_tmp3_ == NULL) {
		UnityInternalUtilsAsyncOnce* _tmp4_;
		GHashTable* _tmp5_;
		gchar* _tmp6_;
		UnityInternalUtilsAsyncOnce* _tmp7_;
		UnityInternalUtilsAsyncOnce* _tmp8_;
		_tmp4_ = unity_internal_utils_async_once_new (UNITY_PROTOCOL_TYPE_SCOPE_PROXY, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref);
		_unity_internal_utils_async_once_unref0 (proxy_once);
		proxy_once = _tmp4_;
		_tmp5_ = self->priv->scope_proxies;
		_tmp6_ = g_strdup (scope_id);
		_tmp7_ = proxy_once;
		_tmp8_ = _unity_internal_utils_async_once_ref0 (_tmp7_);
		g_hash_table_insert (_tmp5_, _tmp6_, _tmp8_);
	}
	result = proxy_once;
	return result;
}


static UnityInternalUtilsAsyncOnce*
unity_internal_scope_tracker_get_channel_id_once (UnityInternalScopeTracker* self,
                                                  const gchar* channel_key)
{
	UnityInternalUtilsAsyncOnce* result = NULL;
	UnityInternalUtilsAsyncOnce* channel_id_once = NULL;
	GHashTable* _tmp0_;
	gconstpointer _tmp1_;
	UnityInternalUtilsAsyncOnce* _tmp2_;
	UnityInternalUtilsAsyncOnce* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (channel_key != NULL, NULL);
	_tmp0_ = self->priv->scope_channel_ids;
	_tmp1_ = g_hash_table_lookup (_tmp0_, channel_key);
	_tmp2_ = _unity_internal_utils_async_once_ref0 ((UnityInternalUtilsAsyncOnce*) _tmp1_);
	channel_id_once = _tmp2_;
	_tmp3_ = channel_id_once;
	if (_tmp3_ == NULL) {
		UnityInternalUtilsAsyncOnce* _tmp4_;
		GHashTable* _tmp5_;
		gchar* _tmp6_;
		UnityInternalUtilsAsyncOnce* _tmp7_;
		UnityInternalUtilsAsyncOnce* _tmp8_;
		_tmp4_ = unity_internal_utils_async_once_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free);
		_unity_internal_utils_async_once_unref0 (channel_id_once);
		channel_id_once = _tmp4_;
		_tmp5_ = self->priv->scope_channel_ids;
		_tmp6_ = g_strdup (channel_key);
		_tmp7_ = channel_id_once;
		_tmp8_ = _unity_internal_utils_async_once_ref0 (_tmp7_);
		g_hash_table_insert (_tmp5_, _tmp6_, _tmp8_);
	}
	result = channel_id_once;
	return result;
}


static const gchar*
unity_internal_scope_tracker_get_channel_id (UnityInternalScopeTracker* self,
                                             const gchar* master_channel_id,
                                             const gchar* scope_id,
                                             UnityProtocolScopeProxy* * proxy,
                                             GError** error)
{
	UnityProtocolScopeProxy* _vala_proxy = NULL;
	const gchar* result = NULL;
	UnityInternalUtilsAsyncOnce* proxy_once = NULL;
	UnityInternalUtilsAsyncOnce* _tmp0_;
	UnityInternalUtilsAsyncOnce* _tmp1_;
	UnityInternalUtilsAsyncOnce* _tmp2_;
	gconstpointer _tmp3_;
	UnityInternalUtilsAsyncOnce* _tmp5_;
	gconstpointer _tmp6_;
	UnityProtocolScopeProxy* _tmp7_;
	gchar* channel_key = NULL;
	UnityProtocolScopeProxy* _tmp8_;
	gchar* _tmp9_;
	UnityInternalUtilsAsyncOnce* channel_id_once = NULL;
	const gchar* _tmp10_;
	UnityInternalUtilsAsyncOnce* _tmp11_;
	UnityInternalUtilsAsyncOnce* _tmp12_;
	UnityInternalUtilsAsyncOnce* _tmp13_;
	gconstpointer _tmp14_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (master_channel_id != NULL, NULL);
	g_return_val_if_fail (scope_id != NULL, NULL);
	_tmp0_ = unity_internal_scope_tracker_get_proxy_once (self, scope_id);
	proxy_once = _tmp0_;
	_tmp1_ = proxy_once;
	if (!unity_internal_utils_async_once_is_initialized (_tmp1_)) {
		_g_object_unref0 (_vala_proxy);
		_vala_proxy = NULL;
		result = NULL;
		_unity_internal_utils_async_once_unref0 (proxy_once);
		if (proxy) {
			*proxy = _vala_proxy;
		} else {
			_g_object_unref0 (_vala_proxy);
		}
		return result;
	}
	_tmp2_ = proxy_once;
	_tmp3_ = unity_internal_utils_async_once_get_data (_tmp2_);
	if (((UnityProtocolScopeProxy*) _tmp3_) == NULL) {
		GError* _tmp4_;
		_tmp4_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_REQUEST_FAILED, "Unable to create proxy");
		_inner_error_ = _tmp4_;
		g_propagate_error (error, _inner_error_);
		_unity_internal_utils_async_once_unref0 (proxy_once);
		return NULL;
	}
	_tmp5_ = proxy_once;
	_tmp6_ = unity_internal_utils_async_once_get_data (_tmp5_);
	_tmp7_ = _g_object_ref0 ((UnityProtocolScopeProxy*) _tmp6_);
	_g_object_unref0 (_vala_proxy);
	_vala_proxy = _tmp7_;
	_tmp8_ = _vala_proxy;
	_tmp9_ = unity_internal_scope_tracker_get_channel_key (self, master_channel_id, _tmp8_);
	channel_key = _tmp9_;
	_tmp10_ = channel_key;
	_tmp11_ = unity_internal_scope_tracker_get_channel_id_once (self, _tmp10_);
	channel_id_once = _tmp11_;
	_tmp12_ = channel_id_once;
	if (!unity_internal_utils_async_once_is_initialized (_tmp12_)) {
		result = NULL;
		_unity_internal_utils_async_once_unref0 (channel_id_once);
		_g_free0 (channel_key);
		_unity_internal_utils_async_once_unref0 (proxy_once);
		if (proxy) {
			*proxy = _vala_proxy;
		} else {
			_g_object_unref0 (_vala_proxy);
		}
		return result;
	}
	_tmp13_ = channel_id_once;
	_tmp14_ = unity_internal_utils_async_once_get_data (_tmp13_);
	result = (const gchar*) _tmp14_;
	_unity_internal_utils_async_once_unref0 (channel_id_once);
	_g_free0 (channel_key);
	_unity_internal_utils_async_once_unref0 (proxy_once);
	if (proxy) {
		*proxy = _vala_proxy;
	} else {
		_g_object_unref0 (_vala_proxy);
	}
	return result;
}


static void
unity_internal_scope_tracker_init_channel_data_free (gpointer _data)
{
	UnityInternalScopeTrackerInitChannelData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->master_channel);
	_g_free0 (_data_->scope_id);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeTrackerInitChannelData, _data_);
}


static void
unity_internal_scope_tracker_init_channel_async_ready_wrapper (GObject *source_object,
                                                               GAsyncResult *res,
                                                               void *user_data)
{
	UnityInternalScopeTrackerInitChannelData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static void
unity_internal_scope_tracker_init_channel (UnityInternalScopeTracker* self,
                                           UnityInternalScopeChannel* master_channel,
                                           const gchar* scope_id,
                                           UnityProtocolChannelType channel_type,
                                           GAsyncReadyCallback _callback_,
                                           gpointer _user_data_)
{
	UnityInternalScopeTrackerInitChannelData* _data_;
	UnityInternalScopeTracker* _tmp0_;
	UnityInternalScopeChannel* _tmp1_;
	gchar* _tmp2_;
	_data_ = g_slice_new0 (UnityInternalScopeTrackerInitChannelData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, unity_internal_scope_tracker_init_channel_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_tracker_init_channel_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (master_channel);
	_g_object_unref0 (_data_->master_channel);
	_data_->master_channel = _tmp1_;
	_tmp2_ = g_strdup (scope_id);
	_g_free0 (_data_->scope_id);
	_data_->scope_id = _tmp2_;
	_data_->channel_type = channel_type;
	unity_internal_scope_tracker_init_channel_co (_data_);
}


static const gchar*
unity_internal_scope_tracker_init_channel_finish (UnityInternalScopeTracker* self,
                                                  GAsyncResult* _res_,
                                                  UnityProtocolScopeProxy* * proxy,
                                                  GError** error)
{
	const gchar* result;
	UnityInternalScopeTrackerInitChannelData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	if (proxy) {
		*proxy = _data_->proxy;
	} else {
		_g_object_unref0 (_data_->proxy);
	}
	_data_->proxy = NULL;
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static void
unity_internal_scope_tracker_init_channel_ready (GObject* source_object,
                                                 GAsyncResult* _res_,
                                                 gpointer _user_data_)
{
	UnityInternalScopeTrackerInitChannelData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_scope_tracker_init_channel_co (_data_);
}


static void
_____lambda22_ (UnityInternalScopeTracker* self,
                GObject* obj,
                GParamSpec* pspec)
{
	UnityProtocolScopeProxy* the_proxy = NULL;
	UnityProtocolScopeProxy* _tmp0_;
	gchar* id = NULL;
	UnityProtocolScopeProxy* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (obj, UNITY_PROTOCOL_TYPE_SCOPE_PROXY) ? ((UnityProtocolScopeProxy*) obj) : NULL);
	the_proxy = _tmp0_;
	_tmp1_ = the_proxy;
	_tmp2_ = unity_internal_scope_tracker_get_scope_id_for_proxy (self, _tmp1_);
	id = _tmp2_;
	_tmp3_ = id;
	if (_tmp3_ != NULL) {
		const gchar* _tmp4_;
		UnityProtocolScopeProxy* _tmp5_;
		_tmp4_ = id;
		_tmp5_ = the_proxy;
		g_signal_emit (self, unity_internal_scope_tracker_signals[UNITY_INTERNAL_SCOPE_TRACKER_PROXY_CATEGORY_MODEL_CHANGED_SIGNAL], 0, _tmp4_, _tmp5_);
	}
	_g_free0 (id);
	_g_object_unref0 (the_proxy);
}


static void
______lambda22__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_____lambda22_ ((UnityInternalScopeTracker*) self, _sender, pspec);
}


static gpointer
_g_error_copy0 (gpointer self)
{
	return self ? g_error_copy (self) : NULL;
}


static gboolean
unity_internal_scope_tracker_init_channel_co (UnityInternalScopeTrackerInitChannelData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		case 4:
		goto _state_4;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = unity_internal_scope_tracker_get_proxy_once (_data_->self, _data_->scope_id);
	_data_->proxy_once = _data_->_tmp0_;
	_data_->failure = NULL;
	_data_->_tmp1_ = _data_->self->priv->scope_metadata;
	if (g_hash_table_contains (_data_->_tmp1_, _data_->scope_id)) {
		_data_->_tmp2_ = _data_->self->priv->scope_metadata;
		_data_->_tmp3_ = g_hash_table_lookup (_data_->_tmp2_, _data_->scope_id);
		unity_internal_scope_tracker_perform_checks (_data_->self, (UnityProtocolScopeRegistryScopeMetadata*) _data_->_tmp3_, _data_->channel_type, &_data_->_inner_error_);
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_error_free0 (_data_->failure);
			_unity_internal_utils_async_once_unref0 (_data_->proxy_once);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp4_ = _data_->proxy_once;
	if (!unity_internal_utils_async_once_is_initialized (_data_->_tmp4_)) {
		_data_->_tmp5_ = _data_->proxy_once;
		_data_->_state_ = 1;
		unity_internal_utils_async_once_enter (_data_->_tmp5_, unity_internal_scope_tracker_init_channel_ready, _data_);
		return FALSE;
		_state_1:
		if (unity_internal_utils_async_once_enter_finish (_data_->_tmp5_, _data_->_res_)) {
			_data_->actual_proxy = NULL;
			{
				_data_->_tmp6_ = _data_->self->priv->scope_metadata;
				if (!g_hash_table_contains (_data_->_tmp6_, _data_->scope_id)) {
					_data_->_tmp8_ = unity_protocol_scope_registry_scope_metadata_for_id (_data_->scope_id, &_data_->_inner_error_);
					_data_->_tmp7_ = _data_->_tmp8_;
					if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
						goto __catch32_g_error;
					}
					_data_->_tmp9_ = _data_->self->priv->scope_metadata;
					_data_->_tmp10_ = g_strdup (_data_->scope_id);
					_data_->_tmp11_ = _data_->_tmp7_;
					_data_->_tmp7_ = NULL;
					g_hash_table_insert (_data_->_tmp9_, _data_->_tmp10_, _data_->_tmp11_);
					_unity_protocol_scope_registry_scope_metadata_unref0 (_data_->_tmp7_);
				}
				_data_->_tmp12_ = _data_->self->priv->scope_metadata;
				_data_->_tmp13_ = g_hash_table_lookup (_data_->_tmp12_, _data_->scope_id);
				_data_->_tmp14_ = _unity_protocol_scope_registry_scope_metadata_ref0 ((UnityProtocolScopeRegistryScopeMetadata*) _data_->_tmp13_);
				_data_->metadata = _data_->_tmp14_;
				_data_->_tmp15_ = _data_->metadata;
				unity_internal_scope_tracker_perform_checks (_data_->self, _data_->_tmp15_, _data_->channel_type, &_data_->_inner_error_);
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					_unity_protocol_scope_registry_scope_metadata_unref0 (_data_->metadata);
					goto __catch32_g_error;
				}
				_data_->_tmp17_ = _data_->metadata;
				_data_->_state_ = 2;
				unity_internal_scope_tracker_create_proxy (_data_->self, _data_->_tmp17_, unity_internal_scope_tracker_init_channel_ready, _data_);
				return FALSE;
				_state_2:
				_data_->_tmp18_ = unity_internal_scope_tracker_create_proxy_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
				_data_->_tmp16_ = _data_->_tmp18_;
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					_unity_protocol_scope_registry_scope_metadata_unref0 (_data_->metadata);
					goto __catch32_g_error;
				}
				_data_->_tmp19_ = _data_->_tmp16_;
				_data_->_tmp16_ = NULL;
				_g_object_unref0 (_data_->actual_proxy);
				_data_->actual_proxy = _data_->_tmp19_;
				_data_->_tmp20_ = _data_->actual_proxy;
				_data_->_tmp21_ = unity_protocol_scope_proxy_get_categories_model (_data_->_tmp20_);
				_data_->_tmp22_ = _data_->_tmp21_;
				if (_data_->_tmp22_ != NULL) {
					_data_->_tmp23_ = _data_->actual_proxy;
					g_signal_emit (_data_->self, unity_internal_scope_tracker_signals[UNITY_INTERNAL_SCOPE_TRACKER_PROXY_CATEGORY_MODEL_CHANGED_SIGNAL], 0, _data_->scope_id, _data_->_tmp23_);
				}
				_data_->_tmp24_ = _data_->actual_proxy;
				g_signal_connect_object ((GObject*) _data_->_tmp24_, "notify::categories-model", (GCallback) ______lambda22__g_object_notify, _data_->self, 0);
				_g_object_unref0 (_data_->_tmp16_);
				_unity_protocol_scope_registry_scope_metadata_unref0 (_data_->metadata);
			}
			goto __finally32;
			__catch32_g_error:
			{
				_data_->e = _data_->_inner_error_;
				_data_->_inner_error_ = NULL;
				_data_->_tmp25_ = _data_->e;
				_data_->_tmp26_ = _g_error_copy0 (_data_->_tmp25_);
				_g_error_free0 (_data_->failure);
				_data_->failure = _data_->_tmp26_;
				_g_error_free0 (_data_->e);
			}
			__finally32:
			{
				_data_->_tmp27_ = _data_->proxy_once;
				_data_->_tmp28_ = _data_->actual_proxy;
				unity_internal_utils_async_once_leave (_data_->_tmp27_, _data_->_tmp28_);
			}
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				g_task_return_error (_data_->_async_result, _data_->_inner_error_);
				_g_object_unref0 (_data_->actual_proxy);
				_g_error_free0 (_data_->failure);
				_unity_internal_utils_async_once_unref0 (_data_->proxy_once);
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_g_object_unref0 (_data_->actual_proxy);
		}
	}
	_data_->_tmp29_ = _data_->proxy_once;
	_data_->_tmp30_ = unity_internal_utils_async_once_get_data (_data_->_tmp29_);
	_data_->_tmp31_ = _g_object_ref0 ((UnityProtocolScopeProxy*) _data_->_tmp30_);
	_g_object_unref0 (_data_->proxy);
	_data_->proxy = _data_->_tmp31_;
	_data_->_tmp32_ = _data_->proxy;
	if (_data_->_tmp32_ == NULL) {
		_data_->_tmp34_ = _data_->failure;
		if (_data_->_tmp34_ != NULL) {
			_data_->_tmp35_ = _data_->failure;
			_data_->_tmp33_ = g_error_matches (_data_->_tmp35_, UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_DISABLED_CONTENT);
		} else {
			_data_->_tmp33_ = FALSE;
		}
		if (_data_->_tmp33_) {
			_data_->_tmp36_ = _data_->proxy_once;
			unity_internal_utils_async_once_reset (_data_->_tmp36_);
			_data_->_tmp37_ = _data_->failure;
			_data_->_tmp38_ = _g_error_copy0 (_data_->_tmp37_);
			_data_->_inner_error_ = _data_->_tmp38_;
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_error_free0 (_data_->failure);
			_unity_internal_utils_async_once_unref0 (_data_->proxy_once);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp40_ = _data_->failure;
		if (_data_->_tmp40_ != NULL) {
			_data_->_tmp41_ = _data_->failure;
			_data_->_tmp42_ = _data_->_tmp41_->message;
			_data_->_tmp39_ = _data_->_tmp42_;
		} else {
			_data_->_tmp39_ = "(unknown)";
		}
		_data_->_tmp43_ = g_strdup_printf ("Unable to create scope proxy for \"%s\": %s", _data_->scope_id, _data_->_tmp39_);
		_data_->msg = _data_->_tmp43_;
		_data_->_tmp44_ = _data_->msg;
		_data_->_tmp45_ = g_error_new_literal (UNITY_PROTOCOL_SCOPE_ERROR, UNITY_PROTOCOL_SCOPE_ERROR_REQUEST_FAILED, _data_->_tmp44_);
		_data_->_inner_error_ = _data_->_tmp45_;
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_free0 (_data_->msg);
		_g_error_free0 (_data_->failure);
		_unity_internal_utils_async_once_unref0 (_data_->proxy_once);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp46_ = _data_->master_channel->id;
	_data_->_tmp47_ = _data_->proxy;
	_data_->_tmp48_ = unity_internal_scope_tracker_get_channel_key (_data_->self, _data_->_tmp46_, _data_->_tmp47_);
	_data_->channel_key = _data_->_tmp48_;
	_data_->_tmp49_ = _data_->channel_key;
	_data_->_tmp50_ = unity_internal_scope_tracker_get_channel_id_once (_data_->self, _data_->_tmp49_);
	_data_->channel_id_once = _data_->_tmp50_;
	_data_->_tmp51_ = _data_->channel_id_once;
	if (!unity_internal_utils_async_once_is_initialized (_data_->_tmp51_)) {
		_data_->_tmp52_ = _data_->channel_id_once;
		_data_->_state_ = 3;
		unity_internal_utils_async_once_enter (_data_->_tmp52_, unity_internal_scope_tracker_init_channel_ready, _data_);
		return FALSE;
		_state_3:
		if (unity_internal_utils_async_once_enter_finish (_data_->_tmp52_, _data_->_res_)) {
			_data_->chan_id = NULL;
			{
				_data_->_tmp54_ = _data_->proxy;
				_data_->_tmp55_ = NULL;
				_data_->_state_ = 4;
				unity_protocol_scope_proxy_open_channel (_data_->_tmp54_, _data_->channel_type, UNITY_PROTOCOL_CHANNEL_FLAGS_PRIVATE, NULL, unity_internal_scope_tracker_init_channel_ready, _data_);
				return FALSE;
				_state_4:
				_data_->_tmp56_ = unity_protocol_scope_proxy_open_channel_finish (_data_->_tmp54_, _data_->_res_, &_data_->_tmp55_, &_data_->_inner_error_);
				_g_object_unref0 (_data_->model);
				_data_->model = _data_->_tmp55_;
				_data_->_tmp53_ = _data_->_tmp56_;
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					goto __finally33;
				}
				_data_->_tmp57_ = _data_->_tmp53_;
				_data_->_tmp53_ = NULL;
				_g_free0 (_data_->chan_id);
				_data_->chan_id = _data_->_tmp57_;
				_data_->_tmp58_ = _data_->self->priv->scope_models;
				_data_->_tmp59_ = _data_->channel_key;
				_data_->_tmp60_ = g_strdup (_data_->_tmp59_);
				_data_->_tmp61_ = _data_->model;
				_data_->_tmp62_ = _g_object_ref0 (_data_->_tmp61_);
				g_hash_table_insert (_data_->_tmp58_, _data_->_tmp60_, _data_->_tmp62_);
				_data_->_tmp63_ = _data_->self->priv->synchronizers;
				_data_->_tmp64_ = _data_->master_channel->id;
				_data_->_tmp65_ = g_hash_table_lookup (_data_->_tmp63_, _data_->_tmp64_);
				_data_->_tmp66_ = _g_object_ref0 ((UnityInternalResultsSynchronizer*) _data_->_tmp65_);
				_data_->synchronizer = _data_->_tmp66_;
				_data_->_tmp67_ = _data_->synchronizer;
				if (_data_->_tmp67_ != NULL) {
					_data_->_tmp68_ = _data_->synchronizer;
					_data_->_tmp69_ = _data_->model;
					unity_internal_results_synchronizer_add_provider (_data_->_tmp68_, (DeeModel*) _data_->_tmp69_, _data_->scope_id);
				} else {
					_data_->_tmp70_ = _data_->master_channel->id;
					g_warning ("unity-scope-tracker.vala:455: Unable to find ResultsSynchronizer for c" \
"hannel %s", _data_->_tmp70_);
				}
				_data_->_tmp72_ = _data_->master_channel->channel_type;
				if (_data_->_tmp72_ == UNITY_PROTOCOL_CHANNEL_TYPE_DEFAULT) {
					_data_->_tmp71_ = UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_DEFAULT;
				} else {
					_data_->_tmp71_ = UNITY_INTERNAL_CHANNEL_UPDATE_FLAGS_GLOBAL;
				}
				_data_->flag = _data_->_tmp71_;
				_data_->_tmp73_ = _data_->self->priv->master_update_flags;
				_data_->_tmp74_ = _data_->proxy;
				_data_->_tmp75_ = unity_internal_scope_tracker_get_update_key (_data_->self, _data_->_tmp74_, _data_->channel_type);
				_data_->_tmp76_ = _data_->flag;
				g_hash_table_insert (_data_->_tmp73_, _data_->_tmp75_, (gpointer) ((gintptr) _data_->_tmp76_));
				_g_object_unref0 (_data_->synchronizer);
				_g_free0 (_data_->_tmp53_);
			}
			__finally33:
			{
				_data_->_tmp77_ = _data_->channel_id_once;
				_data_->_tmp78_ = _data_->chan_id;
				unity_internal_utils_async_once_leave (_data_->_tmp77_, _data_->_tmp78_);
			}
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				g_task_return_error (_data_->_async_result, _data_->_inner_error_);
				_g_free0 (_data_->chan_id);
				_g_object_unref0 (_data_->model);
				_unity_internal_utils_async_once_unref0 (_data_->channel_id_once);
				_g_free0 (_data_->channel_key);
				_g_error_free0 (_data_->failure);
				_unity_internal_utils_async_once_unref0 (_data_->proxy_once);
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_g_free0 (_data_->chan_id);
			_g_object_unref0 (_data_->model);
		}
	}
	_data_->_tmp79_ = _data_->channel_id_once;
	_data_->_tmp80_ = unity_internal_utils_async_once_get_data (_data_->_tmp79_);
	_data_->scope_channel_id = (const gchar*) _data_->_tmp80_;
	_data_->_tmp81_ = _data_->scope_channel_id;
	if (_data_->_tmp81_ == NULL) {
		_data_->_tmp82_ = _data_->channel_id_once;
		unity_internal_utils_async_once_reset (_data_->_tmp82_);
	}
	_data_->_tmp83_ = _data_->scope_channel_id;
	_data_->result = _data_->_tmp83_;
	_unity_internal_utils_async_once_unref0 (_data_->channel_id_once);
	_g_free0 (_data_->channel_key);
	_g_error_free0 (_data_->failure);
	_unity_internal_utils_async_once_unref0 (_data_->proxy_once);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_scope_tracker_activate_wrapper_data_free (gpointer _data)
{
	UnityInternalScopeTrackerActivateWrapperData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->master_channel);
	_g_free0 (_data_->scope_id);
	_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
	_g_hash_table_unref0 (_data_->hints);
	_g_object_unref0 (_data_->cancellable);
	unity_protocol_activation_reply_raw_destroy (&_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeTrackerActivateWrapperData, _data_);
}


static void
unity_internal_scope_tracker_activate_wrapper_async_ready_wrapper (GObject *source_object,
                                                                   GAsyncResult *res,
                                                                   void *user_data)
{
	UnityInternalScopeTrackerActivateWrapperData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_g_hash_table_ref0 (gpointer self)
{
	return self ? g_hash_table_ref (self) : NULL;
}


void
unity_internal_scope_tracker_activate_wrapper (UnityInternalScopeTracker* self,
                                               UnityInternalScopeChannel* master_channel,
                                               const gchar* scope_id,
                                               GVariant** result_arr,
                                               int result_arr_length1,
                                               guint action_type,
                                               GHashTable* hints,
                                               GCancellable* cancellable,
                                               GAsyncReadyCallback _callback_,
                                               gpointer _user_data_)
{
	UnityInternalScopeTrackerActivateWrapperData* _data_;
	UnityInternalScopeTracker* _tmp0_;
	UnityInternalScopeChannel* _tmp1_;
	gchar* _tmp2_;
	GHashTable* _tmp3_;
	GCancellable* _tmp4_;
	_data_ = g_slice_new0 (UnityInternalScopeTrackerActivateWrapperData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, unity_internal_scope_tracker_activate_wrapper_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_tracker_activate_wrapper_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (master_channel);
	_g_object_unref0 (_data_->master_channel);
	_data_->master_channel = _tmp1_;
	_tmp2_ = g_strdup (scope_id);
	_g_free0 (_data_->scope_id);
	_data_->scope_id = _tmp2_;
	_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
	_data_->result_arr = result_arr;
	_data_->result_arr_length1 = result_arr_length1;
	_data_->action_type = action_type;
	_tmp3_ = _g_hash_table_ref0 (hints);
	_g_hash_table_unref0 (_data_->hints);
	_data_->hints = _tmp3_;
	_tmp4_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp4_;
	unity_internal_scope_tracker_activate_wrapper_co (_data_);
}


void
unity_internal_scope_tracker_activate_wrapper_finish (UnityInternalScopeTracker* self,
                                                      GAsyncResult* _res_,
                                                      UnityProtocolActivationReplyRaw* result,
                                                      GError** error)
{
	UnityInternalScopeTrackerActivateWrapperData* _data_;
	UnityProtocolActivationReplyRaw _tmp0_ = {0};
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return;
	}
	unity_protocol_activation_reply_raw_copy (&_data_->result, &_tmp0_);
	*result = _tmp0_;
}


static void
unity_internal_scope_tracker_activate_wrapper_ready (GObject* source_object,
                                                     GAsyncResult* _res_,
                                                     gpointer _user_data_)
{
	UnityInternalScopeTrackerActivateWrapperData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_scope_tracker_activate_wrapper_co (_data_);
}


static gboolean
unity_internal_scope_tracker_activate_wrapper_co (UnityInternalScopeTrackerActivateWrapperData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp1_ = _data_->master_channel->id;
	_data_->_tmp2_ = NULL;
	_data_->_tmp3_ = unity_internal_scope_tracker_get_channel_id (_data_->self, _data_->_tmp1_, _data_->scope_id, &_data_->_tmp2_, &_data_->_inner_error_);
	_g_object_unref0 (_data_->proxy);
	_data_->proxy = _data_->_tmp2_;
	_data_->_tmp0_ = _data_->_tmp3_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->scope_channel_id = _data_->_tmp0_;
	_data_->_tmp4_ = _data_->scope_channel_id;
	if (_data_->_tmp4_ == NULL) {
		_data_->_tmp6_ = _data_->master_channel->channel_type;
		_data_->_tmp7_ = NULL;
		_data_->_state_ = 1;
		unity_internal_scope_tracker_init_channel (_data_->self, _data_->master_channel, _data_->scope_id, _data_->_tmp6_, unity_internal_scope_tracker_activate_wrapper_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp8_ = unity_internal_scope_tracker_init_channel_finish (_data_->self, _data_->_res_, &_data_->_tmp7_, &_data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->proxy = _data_->_tmp7_;
		_data_->_tmp5_ = _data_->_tmp8_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->proxy);
			_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->scope_channel_id = _data_->_tmp5_;
	}
	g_cancellable_set_error_if_cancelled (_data_->cancellable, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->action = (UnityProtocolActionType) _data_->action_type;
	_data_->_tmp10_ = _data_->proxy;
	_data_->_tmp11_ = _data_->scope_channel_id;
	_data_->_tmp12_ = _data_->action;
	memset (&_data_->_tmp13_, 0, sizeof (UnityProtocolActivationReplyRaw));
	_data_->_state_ = 2;
	unity_protocol_scope_proxy_activate (_data_->_tmp10_, _data_->_tmp11_, _data_->result_arr, _data_->result_arr_length1, _data_->_tmp12_, _data_->hints, _data_->cancellable, unity_internal_scope_tracker_activate_wrapper_ready, _data_);
	return FALSE;
	_state_2:
	unity_protocol_scope_proxy_activate_finish (_data_->_tmp10_, _data_->_res_, &_data_->_tmp13_, &_data_->_inner_error_);
	_data_->_tmp9_ = _data_->_tmp13_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp14_ = _data_->_tmp9_;
	memset (&_data_->_tmp9_, 0, sizeof (UnityProtocolActivationReplyRaw));
	_data_->result = _data_->_tmp14_;
	unity_protocol_activation_reply_raw_destroy (&_data_->_tmp9_);
	_g_object_unref0 (_data_->proxy);
	_data_->result_arr = (_vala_array_free (_data_->result_arr, _data_->result_arr_length1, (GDestroyNotify) g_variant_unref), NULL);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_scope_tracker_search_wrapper_data_free (gpointer _data)
{
	UnityInternalScopeTrackerSearchWrapperData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->master_channel);
	_g_free0 (_data_->search_string);
	_g_hash_table_unref0 (_data_->hints);
	_g_free0 (_data_->scope_id);
	_g_object_unref0 (_data_->cancellable);
	_g_hash_table_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeTrackerSearchWrapperData, _data_);
}


static void
unity_internal_scope_tracker_search_wrapper_async_ready_wrapper (GObject *source_object,
                                                                 GAsyncResult *res,
                                                                 void *user_data)
{
	UnityInternalScopeTrackerSearchWrapperData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_internal_scope_tracker_search_wrapper (UnityInternalScopeTracker* self,
                                             UnityInternalScopeChannel* master_channel,
                                             UnityProtocolChannelType channel_type,
                                             const gchar* search_string,
                                             GHashTable* hints,
                                             const gchar* scope_id,
                                             GCancellable* cancellable,
                                             GAsyncReadyCallback _callback_,
                                             gpointer _user_data_)
{
	UnityInternalScopeTrackerSearchWrapperData* _data_;
	UnityInternalScopeTracker* _tmp0_;
	UnityInternalScopeChannel* _tmp1_;
	gchar* _tmp2_;
	GHashTable* _tmp3_;
	gchar* _tmp4_;
	GCancellable* _tmp5_;
	_data_ = g_slice_new0 (UnityInternalScopeTrackerSearchWrapperData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, unity_internal_scope_tracker_search_wrapper_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_tracker_search_wrapper_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (master_channel);
	_g_object_unref0 (_data_->master_channel);
	_data_->master_channel = _tmp1_;
	_data_->channel_type = channel_type;
	_tmp2_ = g_strdup (search_string);
	_g_free0 (_data_->search_string);
	_data_->search_string = _tmp2_;
	_tmp3_ = _g_hash_table_ref0 (hints);
	_g_hash_table_unref0 (_data_->hints);
	_data_->hints = _tmp3_;
	_tmp4_ = g_strdup (scope_id);
	_g_free0 (_data_->scope_id);
	_data_->scope_id = _tmp4_;
	_tmp5_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp5_;
	unity_internal_scope_tracker_search_wrapper_co (_data_);
}


GHashTable*
unity_internal_scope_tracker_search_wrapper_finish (UnityInternalScopeTracker* self,
                                                    GAsyncResult* _res_,
                                                    GError** error)
{
	GHashTable* result;
	UnityInternalScopeTrackerSearchWrapperData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static void
unity_internal_scope_tracker_search_wrapper_ready (GObject* source_object,
                                                   GAsyncResult* _res_,
                                                   gpointer _user_data_)
{
	UnityInternalScopeTrackerSearchWrapperData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_scope_tracker_search_wrapper_co (_data_);
}


static void
_g_variant_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_variant_unref (var), NULL));
}


static gpointer
_g_variant_ref0 (gpointer self)
{
	return self ? g_variant_ref (self) : NULL;
}


static gboolean
unity_internal_scope_tracker_search_wrapper_co (UnityInternalScopeTrackerSearchWrapperData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp1_ = _data_->master_channel->id;
	_data_->_tmp2_ = NULL;
	_data_->_tmp3_ = unity_internal_scope_tracker_get_channel_id (_data_->self, _data_->_tmp1_, _data_->scope_id, &_data_->_tmp2_, &_data_->_inner_error_);
	_g_object_unref0 (_data_->proxy);
	_data_->proxy = _data_->_tmp2_;
	_data_->_tmp0_ = _data_->_tmp3_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->scope_channel_id = _data_->_tmp0_;
	_data_->_tmp4_ = _data_->scope_channel_id;
	if (_data_->_tmp4_ == NULL) {
		_data_->_tmp6_ = NULL;
		_data_->_state_ = 1;
		unity_internal_scope_tracker_init_channel (_data_->self, _data_->master_channel, _data_->scope_id, _data_->channel_type, unity_internal_scope_tracker_search_wrapper_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp7_ = unity_internal_scope_tracker_init_channel_finish (_data_->self, _data_->_res_, &_data_->_tmp6_, &_data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->proxy = _data_->_tmp6_;
		_data_->_tmp5_ = _data_->_tmp7_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->proxy);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->scope_channel_id = _data_->_tmp5_;
	}
	g_cancellable_set_error_if_cancelled (_data_->cancellable, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp8_ = g_str_hash;
	_data_->_tmp9_ = g_str_equal;
	_data_->_tmp10_ = g_hash_table_new_full (_data_->_tmp8_, _data_->_tmp9_, _g_free0_, _g_variant_unref0_);
	_data_->reply_hints = _data_->_tmp10_;
	_data_->_tmp12_ = _data_->self->priv->scope_metadata;
	_data_->_tmp13_ = g_hash_table_lookup (_data_->_tmp12_, _data_->scope_id);
	if (!unity_internal_scope_tracker_content_enabled (_data_->self, (UnityProtocolScopeRegistryScopeMetadata*) _data_->_tmp13_)) {
		_data_->_tmp11_ = TRUE;
	} else {
		_data_->_tmp14_ = _data_->scope_channel_id;
		_data_->_tmp11_ = _data_->_tmp14_ == NULL;
	}
	if (_data_->_tmp11_) {
		_data_->result = _data_->reply_hints;
		_g_object_unref0 (_data_->proxy);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp15_ = _data_->master_channel->id;
	_data_->_tmp16_ = _data_->proxy;
	_data_->_tmp17_ = unity_internal_scope_tracker_get_channel_key (_data_->self, _data_->_tmp15_, _data_->_tmp16_);
	_data_->channel_key = _data_->_tmp17_;
	_data_->_tmp18_ = _data_->self->priv->scope_models;
	_data_->_tmp19_ = _data_->channel_key;
	_data_->_tmp20_ = g_hash_table_lookup (_data_->_tmp18_, _data_->_tmp19_);
	_data_->last_seq_num = dee_serializable_model_get_seqnum ((DeeSerializableModel*) _data_->_tmp20_);
	_data_->_tmp21_ = _data_->self->priv->synchronizers;
	_data_->_tmp22_ = _data_->master_channel->id;
	_data_->_tmp23_ = g_hash_table_lookup (_data_->_tmp21_, _data_->_tmp22_);
	_data_->_tmp24_ = _g_object_ref0 ((UnityInternalResultsSynchronizer*) _data_->_tmp23_);
	_data_->sync = _data_->_tmp24_;
	_data_->_tmp25_ = _data_->sync;
	unity_internal_results_synchronizer_enable_provider (_data_->_tmp25_, _data_->scope_id);
	_data_->_tmp26_ = _data_->proxy;
	_data_->_tmp27_ = _data_->scope_channel_id;
	_data_->_state_ = 2;
	unity_protocol_scope_proxy_search (_data_->_tmp26_, _data_->_tmp27_, _data_->search_string, _data_->hints, _data_->cancellable, unity_internal_scope_tracker_search_wrapper_ready, _data_);
	return FALSE;
	_state_2:
	_data_->_tmp28_ = unity_protocol_scope_proxy_search_finish (_data_->_tmp26_, _data_->_res_, &_data_->_inner_error_);
	_data_->reply_dict = _data_->_tmp28_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->sync);
		_g_free0 (_data_->channel_key);
		_g_hash_table_unref0 (_data_->reply_hints);
		_g_object_unref0 (_data_->proxy);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp29_ = _data_->reply_dict;
	g_hash_table_iter_init (&_data_->iter, _data_->_tmp29_);
	while (TRUE) {
		_data_->_tmp30_ = NULL;
		_data_->_tmp31_ = NULL;
		_data_->_tmp32_ = g_hash_table_iter_next (&_data_->iter, (gpointer*) (&_data_->_tmp30_), (gpointer*) (&_data_->_tmp31_));
		_data_->key = _data_->_tmp30_;
		_data_->variant = _data_->_tmp31_;
		if (!_data_->_tmp32_) {
			break;
		}
		_data_->_tmp33_ = _data_->key;
		if (g_strcmp0 (_data_->_tmp33_, UNITY_INTERNAL_SEARCH_SEQNUM_HINT) == 0) {
			_data_->_tmp34_ = _data_->variant;
			_data_->seqnum = g_variant_get_uint64 (_data_->_tmp34_);
			_data_->_tmp35_ = _data_->self->priv->scope_models;
			_data_->_tmp36_ = _data_->channel_key;
			_data_->_tmp37_ = g_hash_table_lookup (_data_->_tmp35_, _data_->_tmp36_);
			_data_->_tmp38_ = _g_object_ref0 ((DeeSerializableModel*) _data_->_tmp37_);
			_data_->model = _data_->_tmp38_;
			_data_->_tmp39_ = _data_->model;
			_data_->_tmp40_ = _data_->seqnum;
			if (dee_serializable_model_get_seqnum (_data_->_tmp39_) < _data_->_tmp40_) {
				_data_->_tmp41_ = _data_->model;
				_data_->_tmp42_ = _data_->seqnum;
				_data_->_state_ = 3;
				unity_internal_scope_tracker_wait_for_seqnum (_data_->self, G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp41_, dee_shared_model_get_type ()) ? ((DeeSharedModel*) _data_->_tmp41_) : NULL, _data_->_tmp42_, unity_internal_scope_tracker_search_wrapper_ready, _data_);
				return FALSE;
				_state_3:
				unity_internal_scope_tracker_wait_for_seqnum_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					g_task_return_error (_data_->_async_result, _data_->_inner_error_);
					_g_object_unref0 (_data_->model);
					_g_hash_table_unref0 (_data_->reply_dict);
					_g_object_unref0 (_data_->sync);
					_g_free0 (_data_->channel_key);
					_g_hash_table_unref0 (_data_->reply_hints);
					_g_object_unref0 (_data_->proxy);
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
			}
			_data_->_tmp43_ = _data_->self->priv->scope_models;
			_data_->_tmp44_ = _data_->channel_key;
			_data_->_tmp45_ = g_hash_table_lookup (_data_->_tmp43_, _data_->_tmp44_);
			_data_->_tmp46_ = _data_->model;
			if (((DeeSerializableModel*) _data_->_tmp45_) != _data_->_tmp46_) {
				_data_->result = _data_->reply_hints;
				_g_object_unref0 (_data_->model);
				_g_hash_table_unref0 (_data_->reply_dict);
				_g_object_unref0 (_data_->sync);
				_g_free0 (_data_->channel_key);
				_g_object_unref0 (_data_->proxy);
				g_task_return_pointer (_data_->_async_result, _data_, NULL);
				if (_data_->_state_ != 0) {
					while (_data_->_task_complete_ != TRUE) {
						g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
					}
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_data_->_tmp47_ = _data_->seqnum;
			_data_->_tmp48_ = _data_->last_seq_num;
			if (_data_->_tmp47_ == _data_->_tmp48_) {
				_data_->_tmp49_ = _data_->channel_key;
				g_debug ("unity-scope-tracker.vala:558: Model seqnum for channel key %s not chan" \
"ged, copying", _data_->_tmp49_);
				_data_->_tmp50_ = _data_->master_channel->id;
				_data_->_tmp51_ = unity_internal_scope_tracker_get_synchronizer (_data_->self, _data_->_tmp50_);
				_data_->_tmp52_ = _g_object_ref0 (_data_->_tmp51_);
				_data_->synchronizer = _data_->_tmp52_;
				_data_->_tmp53_ = _data_->synchronizer;
				if (_data_->_tmp53_ != NULL) {
					_data_->_tmp54_ = _data_->synchronizer;
					_data_->_tmp55_ = _data_->model;
					unity_internal_results_synchronizer_copy_model (_data_->_tmp54_, (DeeModel*) _data_->_tmp55_);
				} else {
					_data_->_tmp56_ = _data_->master_channel->id;
					g_warning ("unity-scope-tracker.vala:563: No synchronizer for master channel %s", _data_->_tmp56_);
				}
				_g_object_unref0 (_data_->synchronizer);
			}
			_g_object_unref0 (_data_->model);
		} else {
			_data_->_tmp57_ = _data_->key;
			if (g_strcmp0 (_data_->_tmp57_, UNITY_INTERNAL_SEARCH_TIME_HINT) == 0) {
				_data_->_tmp58_ = _data_->reply_hints;
				_data_->_tmp59_ = g_strdup_printf ("%s:%s", UNITY_INTERNAL_SEARCH_TIME_HINT, _data_->scope_id);
				_data_->_tmp60_ = _data_->variant;
				_data_->_tmp61_ = _g_variant_ref0 (_data_->_tmp60_);
				g_hash_table_insert (_data_->_tmp58_, _data_->_tmp59_, _data_->_tmp61_);
			} else {
				_data_->_tmp62_ = _data_->reply_hints;
				_data_->_tmp63_ = _data_->key;
				_data_->_tmp64_ = g_strdup (_data_->_tmp63_);
				_data_->_tmp65_ = _data_->variant;
				_data_->_tmp66_ = _g_variant_ref0 (_data_->_tmp65_);
				g_hash_table_insert (_data_->_tmp62_, _data_->_tmp64_, _data_->_tmp66_);
			}
		}
	}
	g_cancellable_set_error_if_cancelled (_data_->cancellable, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_hash_table_unref0 (_data_->reply_dict);
		_g_object_unref0 (_data_->sync);
		_g_free0 (_data_->channel_key);
		_g_hash_table_unref0 (_data_->reply_hints);
		_g_object_unref0 (_data_->proxy);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp67_ = _data_->sync;
	unity_internal_results_synchronizer_disable_provider (_data_->_tmp67_, _data_->scope_id);
	_data_->result = _data_->reply_hints;
	_g_hash_table_unref0 (_data_->reply_dict);
	_g_object_unref0 (_data_->sync);
	_g_free0 (_data_->channel_key);
	_g_object_unref0 (_data_->proxy);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_scope_tracker_push_wrapper_data_free (gpointer _data)
{
	UnityInternalScopeTrackerPushWrapperData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->parent_channel);
	_g_free0 (_data_->search_string);
	_g_free0 (_data_->master_scope_id);
	_g_free0 (_data_->scope_id);
	_g_object_unref0 (_data_->results_model);
	_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (_data_->cancellable);
	_g_object_unref0 (_data_->self);
	g_slice_free (UnityInternalScopeTrackerPushWrapperData, _data_);
}


static void
unity_internal_scope_tracker_push_wrapper_async_ready_wrapper (GObject *source_object,
                                                               GAsyncResult *res,
                                                               void *user_data)
{
	UnityInternalScopeTrackerPushWrapperData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


void
unity_internal_scope_tracker_push_wrapper (UnityInternalScopeTracker* self,
                                           UnityInternalScopeChannel* parent_channel,
                                           const gchar* search_string,
                                           UnityProtocolChannelType channel_type,
                                           const gchar* master_scope_id,
                                           const gchar* scope_id,
                                           DeeSerializableModel* results_model,
                                           gchar** categories,
                                           int categories_length1,
                                           GCancellable* cancellable,
                                           GAsyncReadyCallback _callback_,
                                           gpointer _user_data_)
{
	UnityInternalScopeTrackerPushWrapperData* _data_;
	UnityInternalScopeTracker* _tmp0_;
	UnityInternalScopeChannel* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	DeeSerializableModel* _tmp5_;
	GCancellable* _tmp6_;
	_data_ = g_slice_new0 (UnityInternalScopeTrackerPushWrapperData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, unity_internal_scope_tracker_push_wrapper_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_scope_tracker_push_wrapper_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (parent_channel);
	_g_object_unref0 (_data_->parent_channel);
	_data_->parent_channel = _tmp1_;
	_tmp2_ = g_strdup (search_string);
	_g_free0 (_data_->search_string);
	_data_->search_string = _tmp2_;
	_data_->channel_type = channel_type;
	_tmp3_ = g_strdup (master_scope_id);
	_g_free0 (_data_->master_scope_id);
	_data_->master_scope_id = _tmp3_;
	_tmp4_ = g_strdup (scope_id);
	_g_free0 (_data_->scope_id);
	_data_->scope_id = _tmp4_;
	_tmp5_ = _g_object_ref0 (results_model);
	_g_object_unref0 (_data_->results_model);
	_data_->results_model = _tmp5_;
	_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
	_data_->categories = categories;
	_data_->categories_length1 = categories_length1;
	_tmp6_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp6_;
	unity_internal_scope_tracker_push_wrapper_co (_data_);
}


void
unity_internal_scope_tracker_push_wrapper_finish (UnityInternalScopeTracker* self,
                                                  GAsyncResult* _res_,
                                                  GError** error)
{
	UnityInternalScopeTrackerPushWrapperData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return;
	}
}


static void
unity_internal_scope_tracker_push_wrapper_ready (GObject* source_object,
                                                 GAsyncResult* _res_,
                                                 gpointer _user_data_)
{
	UnityInternalScopeTrackerPushWrapperData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_scope_tracker_push_wrapper_co (_data_);
}


static gboolean
unity_internal_scope_tracker_push_wrapper_co (UnityInternalScopeTrackerPushWrapperData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp1_ = _data_->parent_channel->id;
	_data_->_tmp2_ = NULL;
	_data_->_tmp3_ = unity_internal_scope_tracker_get_channel_id (_data_->self, _data_->_tmp1_, _data_->master_scope_id, &_data_->_tmp2_, &_data_->_inner_error_);
	_g_object_unref0 (_data_->proxy);
	_data_->proxy = _data_->_tmp2_;
	_data_->_tmp0_ = _data_->_tmp3_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->scope_channel_id = _data_->_tmp0_;
	_data_->_tmp4_ = _data_->scope_channel_id;
	if (_data_->_tmp4_ == NULL) {
		_data_->_tmp6_ = NULL;
		_data_->_state_ = 1;
		unity_internal_scope_tracker_init_channel (_data_->self, _data_->parent_channel, _data_->master_scope_id, _data_->channel_type, unity_internal_scope_tracker_push_wrapper_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp7_ = unity_internal_scope_tracker_init_channel_finish (_data_->self, _data_->_res_, &_data_->_tmp6_, &_data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->proxy = _data_->_tmp6_;
		_data_->_tmp5_ = _data_->_tmp7_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->proxy);
			_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->scope_channel_id = _data_->_tmp5_;
	}
	_data_->_tmp8_ = _data_->scope_channel_id;
	if (_data_->_tmp8_ == NULL) {
		_g_object_unref0 (_data_->proxy);
		_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	g_cancellable_set_error_if_cancelled (_data_->cancellable, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->proxy);
		_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp9_ = _data_->parent_channel->id;
	_data_->_tmp10_ = _data_->proxy;
	_data_->_tmp11_ = unity_internal_scope_tracker_get_channel_key (_data_->self, _data_->_tmp9_, _data_->_tmp10_);
	_data_->channel_key = _data_->_tmp11_;
	_data_->_tmp12_ = _data_->self->priv->synchronizers;
	_data_->_tmp13_ = _data_->parent_channel->id;
	_data_->_tmp14_ = g_hash_table_lookup (_data_->_tmp12_, _data_->_tmp13_);
	_data_->_tmp15_ = _g_object_ref0 ((UnityInternalResultsSynchronizer*) _data_->_tmp14_);
	_data_->sync = _data_->_tmp15_;
	_data_->_tmp16_ = _data_->sync;
	unity_internal_results_synchronizer_enable_provider (_data_->_tmp16_, _data_->master_scope_id);
	_data_->_tmp17_ = _data_->proxy;
	_data_->_tmp18_ = _data_->scope_channel_id;
	_data_->_state_ = 2;
	unity_protocol_scope_proxy_push_results (_data_->_tmp17_, _data_->_tmp18_, _data_->search_string, _data_->scope_id, _data_->results_model, _data_->categories, _data_->categories_length1, _data_->cancellable, unity_internal_scope_tracker_push_wrapper_ready, _data_);
	return FALSE;
	_state_2:
	_data_->_tmp19_ = unity_protocol_scope_proxy_push_results_finish (_data_->_tmp17_, _data_->_res_, &_data_->_inner_error_);
	_data_->reply_dict = _data_->_tmp19_;
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_object_unref0 (_data_->sync);
		_g_free0 (_data_->channel_key);
		_g_object_unref0 (_data_->proxy);
		_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp20_ = _data_->reply_dict;
	g_hash_table_iter_init (&_data_->iter, _data_->_tmp20_);
	while (TRUE) {
		_data_->_tmp21_ = NULL;
		_data_->_tmp22_ = NULL;
		_data_->_tmp23_ = g_hash_table_iter_next (&_data_->iter, (gpointer*) (&_data_->_tmp21_), (gpointer*) (&_data_->_tmp22_));
		_data_->key = _data_->_tmp21_;
		_data_->variant = _data_->_tmp22_;
		if (!_data_->_tmp23_) {
			break;
		}
		_data_->_tmp24_ = _data_->key;
		if (g_strcmp0 (_data_->_tmp24_, UNITY_INTERNAL_SEARCH_SEQNUM_HINT) == 0) {
			_data_->_tmp25_ = _data_->variant;
			_data_->seqnum = g_variant_get_uint64 (_data_->_tmp25_);
			_data_->_tmp26_ = _data_->self->priv->scope_models;
			_data_->_tmp27_ = _data_->channel_key;
			_data_->_tmp28_ = g_hash_table_lookup (_data_->_tmp26_, _data_->_tmp27_);
			_data_->_tmp29_ = _g_object_ref0 ((DeeSerializableModel*) _data_->_tmp28_);
			_data_->model = _data_->_tmp29_;
			_data_->_tmp30_ = _data_->model;
			_data_->_tmp31_ = _data_->seqnum;
			if (dee_serializable_model_get_seqnum (_data_->_tmp30_) < _data_->_tmp31_) {
				_data_->_tmp32_ = _data_->model;
				_data_->_tmp33_ = _data_->seqnum;
				_data_->_state_ = 3;
				unity_internal_scope_tracker_wait_for_seqnum (_data_->self, G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp32_, dee_shared_model_get_type ()) ? ((DeeSharedModel*) _data_->_tmp32_) : NULL, _data_->_tmp33_, unity_internal_scope_tracker_push_wrapper_ready, _data_);
				return FALSE;
				_state_3:
				unity_internal_scope_tracker_wait_for_seqnum_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					g_task_return_error (_data_->_async_result, _data_->_inner_error_);
					_g_object_unref0 (_data_->model);
					_g_hash_table_unref0 (_data_->reply_dict);
					_g_object_unref0 (_data_->sync);
					_g_free0 (_data_->channel_key);
					_g_object_unref0 (_data_->proxy);
					_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
			}
			_g_object_unref0 (_data_->model);
		}
	}
	g_cancellable_set_error_if_cancelled (_data_->cancellable, &_data_->_inner_error_);
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error_);
		_g_hash_table_unref0 (_data_->reply_dict);
		_g_object_unref0 (_data_->sync);
		_g_free0 (_data_->channel_key);
		_g_object_unref0 (_data_->proxy);
		_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp34_ = _data_->sync;
	unity_internal_results_synchronizer_disable_provider (_data_->_tmp34_, _data_->master_scope_id);
	_g_hash_table_unref0 (_data_->reply_dict);
	_g_object_unref0 (_data_->sync);
	_g_free0 (_data_->channel_key);
	_g_object_unref0 (_data_->proxy);
	_data_->categories = (_vala_array_free (_data_->categories, _data_->categories_length1, (GDestroyNotify) g_free), NULL);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure,
                                             GValue * return_value,
                                             guint n_param_values,
                                             const GValue * param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_OBJECT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static void
unity_internal_scope_tracker_class_init (UnityInternalScopeTrackerClass * klass)
{
	unity_internal_scope_tracker_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityInternalScopeTrackerPrivate));
	G_OBJECT_CLASS (klass)->finalize = unity_internal_scope_tracker_finalize;
	unity_internal_scope_tracker_signals[UNITY_INTERNAL_SCOPE_TRACKER_RESULTS_INVALIDATED_SIGNAL] = g_signal_new ("results-invalidated", UNITY_INTERNAL_TYPE_SCOPE_TRACKER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__FLAGS, G_TYPE_NONE, 1, UNITY_INTERNAL_TYPE_CHANNEL_UPDATE_FLAGS);
	unity_internal_scope_tracker_signals[UNITY_INTERNAL_SCOPE_TRACKER_PROXY_CATEGORY_MODEL_CHANGED_SIGNAL] = g_signal_new ("proxy-category-model-changed", UNITY_INTERNAL_TYPE_SCOPE_TRACKER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_OBJECT, G_TYPE_NONE, 2, G_TYPE_STRING, UNITY_PROTOCOL_TYPE_SCOPE_PROXY);
	unity_internal_scope_tracker_DEDUP_MODEL_QUARK = g_quark_from_string ("unity-dedup-model");
}


static void
unity_internal_scope_tracker_instance_init (UnityInternalScopeTracker * self)
{
	self->priv = UNITY_INTERNAL_SCOPE_TRACKER_GET_PRIVATE (self);
}


static void
unity_internal_scope_tracker_finalize (GObject * obj)
{
	UnityInternalScopeTracker * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_INTERNAL_TYPE_SCOPE_TRACKER, UnityInternalScopeTracker);
	_g_ptr_array_unref0 (self->priv->scope_proxy_arr);
	_g_hash_table_unref0 (self->priv->scope_proxies);
	_g_hash_table_unref0 (self->priv->scope_channel_ids);
	_g_hash_table_unref0 (self->priv->scope_models);
	_g_hash_table_unref0 (self->priv->synchronizers);
	_g_hash_table_unref0 (self->priv->master_update_flags);
	_g_hash_table_unref0 (self->priv->scope_metadata);
	_g_hash_table_unref0 (self->priv->binary_present);
	G_OBJECT_CLASS (unity_internal_scope_tracker_parent_class)->finalize (obj);
}


GType
unity_internal_scope_tracker_get_type (void)
{
	static volatile gsize unity_internal_scope_tracker_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_scope_tracker_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityInternalScopeTrackerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_internal_scope_tracker_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityInternalScopeTracker), 0, (GInstanceInitFunc) unity_internal_scope_tracker_instance_init, NULL };
		GType unity_internal_scope_tracker_type_id;
		unity_internal_scope_tracker_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityInternalScopeTracker", &g_define_type_info, 0);
		g_once_init_leave (&unity_internal_scope_tracker_type_id__volatile, unity_internal_scope_tracker_type_id);
	}
	return unity_internal_scope_tracker_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



