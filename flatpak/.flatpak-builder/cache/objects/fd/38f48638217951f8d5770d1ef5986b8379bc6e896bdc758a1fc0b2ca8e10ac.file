/* unity-utils.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-utils.vala, do not modify */

/*
 * Copyright (C) 2011 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Neil Jagdish Patel <neil.patel@canonical.com>
 *
 */


#include <glib.h>
#include <glib-object.h>
#include "unity.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <dee.h>
#include <gobject/gvaluecollector.h>


#define UNITY_INTERNAL_TYPE_CATEGORY_COLUMN (unity_internal_category_column_get_type ())

#define UNITY_INTERNAL_TYPE_FILTER_COLUMN (unity_internal_filter_column_get_type ())

#define UNITY_INTERNAL_TYPE_RESULT_COLUMN (unity_internal_result_column_get_type ())
typedef struct _UnityInternalUtilsDelegateWrapper UnityInternalUtilsDelegateWrapper;

#define UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE (unity_internal_utils_async_once_get_type ())
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnce))
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnceClass))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE))
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnceClass))

typedef struct _UnityInternalUtilsAsyncOnce UnityInternalUtilsAsyncOnce;
typedef struct _UnityInternalUtilsAsyncOnceClass UnityInternalUtilsAsyncOnceClass;
typedef struct _UnityInternalUtilsAsyncOncePrivate UnityInternalUtilsAsyncOncePrivate;

#define UNITY_INTERNAL_UTILS_ASYNC_ONCE_TYPE_OPERATION_STATE (unity_internal_utils_async_once_operation_state_get_type ())
#define _unity_internal_utils_async_once_unref0(var) ((var == NULL) ? NULL : (var = (unity_internal_utils_async_once_unref (var), NULL)))
typedef struct _UnityInternalUtilsAsyncOnceEnterData UnityInternalUtilsAsyncOnceEnterData;
typedef struct _UnityInternalUtilsAsyncOnceWaitAsyncData UnityInternalUtilsAsyncOnceWaitAsyncData;
typedef struct _UnityInternalUtilsParamSpecAsyncOnce UnityInternalUtilsParamSpecAsyncOnce;

#define UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX (unity_internal_utils_async_mutex_get_type ())
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutex))
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexClass))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_MUTEX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX))
#define UNITY_INTERNAL_UTILS_IS_ASYNC_MUTEX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX))
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexClass))

typedef struct _UnityInternalUtilsAsyncMutex UnityInternalUtilsAsyncMutex;
typedef struct _UnityInternalUtilsAsyncMutexClass UnityInternalUtilsAsyncMutexClass;
typedef struct _UnityInternalUtilsAsyncMutexPrivate UnityInternalUtilsAsyncMutexPrivate;
#define _unity_internal_utils_async_mutex_unref0(var) ((var == NULL) ? NULL : (var = (unity_internal_utils_async_mutex_unref (var), NULL)))
typedef struct _UnityInternalUtilsAsyncMutexLockData UnityInternalUtilsAsyncMutexLockData;
#define _unity_internal_utils_delegate_wrapper_free0(var) ((var == NULL) ? NULL : (var = (unity_internal_utils_delegate_wrapper_free (var), NULL)))
typedef struct _UnityInternalUtilsAsyncMutexWaitAsyncData UnityInternalUtilsAsyncMutexWaitAsyncData;
typedef struct _UnityInternalUtilsParamSpecAsyncMutex UnityInternalUtilsParamSpecAsyncMutex;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block29Data Block29Data;
typedef struct _UnityInternalUtilsWaitForModelSynchronizationData UnityInternalUtilsWaitForModelSynchronizationData;
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_variant_builder_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_builder_unref (var), NULL)))

#define UNITY_INTERNAL_UTILS_DIFF_TYPE_CONTEXT (unity_internal_utils_diff_context_get_type ())
typedef struct _UnityInternalUtilsDiffContext UnityInternalUtilsDiffContext;

#define UNITY_INTERNAL_UTILS_DIFF_TYPE_PARTITION (unity_internal_utils_diff_partition_get_type ())
typedef struct _UnityInternalUtilsDiffPartition UnityInternalUtilsDiffPartition;

#define UNITY_INTERNAL_UTILS_DIFF_TYPE_CHANGE (unity_internal_utils_diff_change_get_type ())
typedef struct _UnityInternalUtilsDiffChange UnityInternalUtilsDiffChange;

typedef enum  {
	UNITY_INTERNAL_CATEGORY_COLUMN_ID,
	UNITY_INTERNAL_CATEGORY_COLUMN_DISPLAY_NAME,
	UNITY_INTERNAL_CATEGORY_COLUMN_ICON_HINT,
	UNITY_INTERNAL_CATEGORY_COLUMN_RENDERER_NAME,
	UNITY_INTERNAL_CATEGORY_COLUMN_HINTS,
	UNITY_INTERNAL_CATEGORY_COLUMN_N_COLUMNS
} UnityInternalCategoryColumn;

typedef enum  {
	UNITY_INTERNAL_FILTER_COLUMN_ID,
	UNITY_INTERNAL_FILTER_COLUMN_DISPLAY_NAME,
	UNITY_INTERNAL_FILTER_COLUMN_ICON_HINT,
	UNITY_INTERNAL_FILTER_COLUMN_RENDERER_NAME,
	UNITY_INTERNAL_FILTER_COLUMN_RENDERER_STATE,
	UNITY_INTERNAL_FILTER_COLUMN_VISIBLE,
	UNITY_INTERNAL_FILTER_COLUMN_COLLAPSED,
	UNITY_INTERNAL_FILTER_COLUMN_FILTERING,
	UNITY_INTERNAL_FILTER_COLUMN_N_COLUMNS
} UnityInternalFilterColumn;

typedef enum  {
	UNITY_INTERNAL_RESULT_COLUMN_URI,
	UNITY_INTERNAL_RESULT_COLUMN_ICON_HINT,
	UNITY_INTERNAL_RESULT_COLUMN_CATEGORY,
	UNITY_INTERNAL_RESULT_COLUMN_RESULT_TYPE,
	UNITY_INTERNAL_RESULT_COLUMN_MIMETYPE,
	UNITY_INTERNAL_RESULT_COLUMN_TITLE,
	UNITY_INTERNAL_RESULT_COLUMN_COMMENT,
	UNITY_INTERNAL_RESULT_COLUMN_DND_URI,
	UNITY_INTERNAL_RESULT_COLUMN_METADATA,
	UNITY_INTERNAL_RESULT_COLUMN_N_COLUMNS
} UnityInternalResultColumn;

struct _UnityInternalUtilsDelegateWrapper {
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
};

struct _UnityInternalUtilsAsyncOnce {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityInternalUtilsAsyncOncePrivate * priv;
};

struct _UnityInternalUtilsAsyncOnceClass {
	GTypeClass parent_class;
	void (*finalize) (UnityInternalUtilsAsyncOnce *self);
};

typedef enum  {
	UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED,
	UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS,
	UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE
} UnityInternalUtilsAsyncOnceOperationState;

struct _UnityInternalUtilsAsyncOncePrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gpointer inner;
	UnityInternalUtilsAsyncOnceOperationState state;
	UnityInternalUtilsDelegateWrapper** callbacks;
	gint callbacks_length1;
	gint _callbacks_size_;
};

struct _UnityInternalUtilsAsyncOnceEnterData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalUtilsAsyncOnce* self;
	gboolean result;
	UnityInternalUtilsAsyncOnceOperationState _tmp0_;
	UnityInternalUtilsAsyncOnceOperationState _tmp1_;
};

struct _UnityInternalUtilsAsyncOnceWaitAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalUtilsAsyncOnce* self;
	UnityInternalUtilsDelegateWrapper** _tmp0_;
	gint _tmp0__length1;
	UnityInternalUtilsDelegateWrapper* _tmp1_;
};

struct _UnityInternalUtilsParamSpecAsyncOnce {
	GParamSpec parent_instance;
};

struct _UnityInternalUtilsAsyncMutex {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityInternalUtilsAsyncMutexPrivate * priv;
};

struct _UnityInternalUtilsAsyncMutexClass {
	GTypeClass parent_class;
	void (*finalize) (UnityInternalUtilsAsyncMutex *self);
};

struct _UnityInternalUtilsAsyncMutexPrivate {
	gboolean is_locked;
	GQueue* callbacks;
};

struct _UnityInternalUtilsAsyncMutexLockData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalUtilsAsyncMutex* self;
	gboolean _tmp0_;
};

struct _UnityInternalUtilsAsyncMutexWaitAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	UnityInternalUtilsAsyncMutex* self;
	GQueue* _tmp0_;
	UnityInternalUtilsDelegateWrapper* _tmp1_;
};

struct _UnityInternalUtilsParamSpecAsyncMutex {
	GParamSpec parent_instance;
};

struct _Block29Data {
	int _ref_count_;
	DeeSharedModel* model;
	gpointer _async_data_;
};

struct _UnityInternalUtilsWaitForModelSynchronizationData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	DeeSharedModel* model;
	Block29Data* _data29_;
	gulong sig_id;
	gulong _tmp0_;
	gulong _tmp1_;
	gulong _tmp2_;
};

typedef gboolean (*UnityInternalUtilsDiffResultSetCompareFunc) (gint index_a, gint index_b, gpointer user_data);
struct _UnityInternalUtilsDiffContext {
	gint x_length;
	gint y_length;
	gint* real_diag;
	gint real_diag_length1;
	gint _real_diag_size_;
	gint* f_diag;
	gint* b_diag;
	gint max_cost;
	guint8* real_changes;
	gint real_changes_length1;
	gint _real_changes_size_;
	guint8* x_changes;
	guint8* y_changes;
};

struct _UnityInternalUtilsDiffPartition {
	gint x_mid;
	gint y_mid;
	gboolean lo_minimal;
	gboolean hi_minimal;
};

struct _UnityInternalUtilsDiffChange {
	gint x_offset;
	gint y_offset;
	gint inserted;
	gint deleted;
};


static gpointer unity_internal_utils_async_once_parent_class = NULL;
static gpointer unity_internal_utils_async_mutex_parent_class = NULL;

GType unity_internal_category_column_get_type (void) G_GNUC_CONST;
GType unity_internal_filter_column_get_type (void) G_GNUC_CONST;
GType unity_internal_result_column_get_type (void) G_GNUC_CONST;
#define UNITY_INTERNAL_VAR_MEASURED_SEARCHES "LIBUNITY_TIME_SEARCHES"
#define UNITY_INTERNAL_VAR_SYNC_DBUS_SEARCHES "LIBUNITY_SYNC_DBUS"
#define UNITY_INTERNAL_SEARCH_FILTER_ROW_HINT "changed-filter-row"
#define UNITY_INTERNAL_SEARCH_SEQNUM_HINT "model-seqnum"
#define UNITY_INTERNAL_SEARCH_TIME_HINT "search-time"
#define UNITY_INTERNAL_SEARCH_SUBSCOPES_HINT "subscopes-filter"
#define UNITY_INTERNAL_SEARCH_NO_RESULTS_HINT "no-results-hint"
#define UNITY_INTERNAL_ACTIVATE_PREVIEW_ACTION_HINT "preview-action-id"
void unity_internal_utils_delegate_wrapper_free (UnityInternalUtilsDelegateWrapper * self);
static void unity_internal_utils_delegate_wrapper_instance_init (UnityInternalUtilsDelegateWrapper * self);
UnityInternalUtilsDelegateWrapper* unity_internal_utils_delegate_wrapper_new (GSourceFunc cb,
                                                                              gpointer cb_target,
                                                                              GDestroyNotify cb_target_destroy_notify);
gpointer unity_internal_utils_async_once_ref (gpointer instance);
void unity_internal_utils_async_once_unref (gpointer instance);
GParamSpec* unity_internal_utils_param_spec_async_once (const gchar* name,
                                                        const gchar* nick,
                                                        const gchar* blurb,
                                                        GType object_type,
                                                        GParamFlags flags);
void unity_internal_utils_value_set_async_once (GValue* value,
                                                gpointer v_object);
void unity_internal_utils_value_take_async_once (GValue* value,
                                                 gpointer v_object);
gpointer unity_internal_utils_value_get_async_once (const GValue* value);
GType unity_internal_utils_async_once_get_type (void) G_GNUC_CONST;
static GType unity_internal_utils_async_once_operation_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define UNITY_INTERNAL_UTILS_ASYNC_ONCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOncePrivate))
UnityInternalUtilsAsyncOnce* unity_internal_utils_async_once_new (GType g_type,
                                                                  GBoxedCopyFunc g_dup_func,
                                                                  GDestroyNotify g_destroy_func);
UnityInternalUtilsAsyncOnce* unity_internal_utils_async_once_construct (GType object_type,
                                                                        GType g_type,
                                                                        GBoxedCopyFunc g_dup_func,
                                                                        GDestroyNotify g_destroy_func);
gconstpointer unity_internal_utils_async_once_get_data (UnityInternalUtilsAsyncOnce* self);
gboolean unity_internal_utils_async_once_is_initialized (UnityInternalUtilsAsyncOnce* self);
static void unity_internal_utils_async_once_enter_data_free (gpointer _data);
static void unity_internal_utils_async_once_enter_async_ready_wrapper (GObject *source_object,
                                                                GAsyncResult *res,
                                                                void *user_data);
void unity_internal_utils_async_once_enter (UnityInternalUtilsAsyncOnce* self,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_);
gboolean unity_internal_utils_async_once_enter_finish (UnityInternalUtilsAsyncOnce* self,
                                                       GAsyncResult* _res_);
static gboolean unity_internal_utils_async_once_enter_co (UnityInternalUtilsAsyncOnceEnterData* _data_);
static void unity_internal_utils_async_once_wait_async (UnityInternalUtilsAsyncOnce* self,
                                                 GAsyncReadyCallback _callback_,
                                                 gpointer _user_data_);
static void unity_internal_utils_async_once_wait_finish (UnityInternalUtilsAsyncOnce* self,
                                                  GAsyncResult* _res_);
static void unity_internal_utils_async_once_enter_ready (GObject* source_object,
                                                  GAsyncResult* _res_,
                                                  gpointer _user_data_);
void unity_internal_utils_async_once_leave (UnityInternalUtilsAsyncOnce* self,
                                            gconstpointer _result_);
static void unity_internal_utils_async_once_notify_all (UnityInternalUtilsAsyncOnce* self);
void unity_internal_utils_async_once_reset (UnityInternalUtilsAsyncOnce* self);
static void unity_internal_utils_async_once_wait_async_data_free (gpointer _data);
static void unity_internal_utils_async_once_wait_async_async_ready_wrapper (GObject *source_object,
                                                                     GAsyncResult *res,
                                                                     void *user_data);
static gboolean unity_internal_utils_async_once_wait_async_co (UnityInternalUtilsAsyncOnceWaitAsyncData* _data_);
static gboolean _unity_internal_utils_async_once_wait_async_co_gsource_func (gpointer self);
static void _vala_array_add14 (UnityInternalUtilsDelegateWrapper** * array,
                        int* length,
                        int* size,
                        UnityInternalUtilsDelegateWrapper* value);
static void unity_internal_utils_async_once_finalize (UnityInternalUtilsAsyncOnce * obj);
gpointer unity_internal_utils_async_mutex_ref (gpointer instance);
void unity_internal_utils_async_mutex_unref (gpointer instance);
GParamSpec* unity_internal_utils_param_spec_async_mutex (const gchar* name,
                                                         const gchar* nick,
                                                         const gchar* blurb,
                                                         GType object_type,
                                                         GParamFlags flags);
void unity_internal_utils_value_set_async_mutex (GValue* value,
                                                 gpointer v_object);
void unity_internal_utils_value_take_async_mutex (GValue* value,
                                                  gpointer v_object);
gpointer unity_internal_utils_value_get_async_mutex (const GValue* value);
GType unity_internal_utils_async_mutex_get_type (void) G_GNUC_CONST;
#define UNITY_INTERNAL_UTILS_ASYNC_MUTEX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutexPrivate))
static void _unity_internal_utils_delegate_wrapper_free0_ (gpointer var);
static inline void _g_queue_free__unity_internal_utils_delegate_wrapper_free0_ (GQueue* self);
UnityInternalUtilsAsyncMutex* unity_internal_utils_async_mutex_new (void);
UnityInternalUtilsAsyncMutex* unity_internal_utils_async_mutex_construct (GType object_type);
gboolean unity_internal_utils_async_mutex_try_lock (UnityInternalUtilsAsyncMutex* self);
static void unity_internal_utils_async_mutex_lock_data_free (gpointer _data);
static void unity_internal_utils_async_mutex_lock_async_ready_wrapper (GObject *source_object,
                                                                GAsyncResult *res,
                                                                void *user_data);
void unity_internal_utils_async_mutex_lock (UnityInternalUtilsAsyncMutex* self,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_);
void unity_internal_utils_async_mutex_lock_finish (UnityInternalUtilsAsyncMutex* self,
                                                   GAsyncResult* _res_);
static gboolean unity_internal_utils_async_mutex_lock_co (UnityInternalUtilsAsyncMutexLockData* _data_);
static void unity_internal_utils_async_mutex_wait_async (UnityInternalUtilsAsyncMutex* self,
                                                  GAsyncReadyCallback _callback_,
                                                  gpointer _user_data_);
static void unity_internal_utils_async_mutex_wait_finish (UnityInternalUtilsAsyncMutex* self,
                                                   GAsyncResult* _res_);
static void unity_internal_utils_async_mutex_lock_ready (GObject* source_object,
                                                  GAsyncResult* _res_,
                                                  gpointer _user_data_);
void unity_internal_utils_async_mutex_unlock (UnityInternalUtilsAsyncMutex* self);
static void unity_internal_utils_async_mutex_notify (UnityInternalUtilsAsyncMutex* self);
static void unity_internal_utils_async_mutex_wait_async_data_free (gpointer _data);
static void unity_internal_utils_async_mutex_wait_async_async_ready_wrapper (GObject *source_object,
                                                                      GAsyncResult *res,
                                                                      void *user_data);
static gboolean unity_internal_utils_async_mutex_wait_async_co (UnityInternalUtilsAsyncMutexWaitAsyncData* _data_);
static gboolean _unity_internal_utils_async_mutex_wait_async_co_gsource_func (gpointer self);
static void unity_internal_utils_async_mutex_finalize (UnityInternalUtilsAsyncMutex * obj);
static void unity_internal_utils_wait_for_model_synchronization_data_free (gpointer _data);
static void unity_internal_utils_wait_for_model_synchronization_async_ready_wrapper (GObject *source_object,
                                                                              GAsyncResult *res,
                                                                              void *user_data);
void unity_internal_utils_wait_for_model_synchronization (DeeSharedModel* model,
                                                          GAsyncReadyCallback _callback_,
                                                          gpointer _user_data_);
void unity_internal_utils_wait_for_model_synchronization_finish (GAsyncResult* _res_);
static gboolean unity_internal_utils_wait_for_model_synchronization_co (UnityInternalUtilsWaitForModelSynchronizationData* _data_);
static Block29Data* block29_data_ref (Block29Data* _data29_);
static void block29_data_unref (void * _userdata_);
static void __lambda17_ (Block29Data* _data29_);
static void ___lambda17__g_object_notify (GObject* _sender,
                                   GParamSpec* pspec,
                                   gpointer self);
GVariant* unity_internal_utils_hash_table_to_asv (GHashTable* hash);
gchar* unity_internal_utils_icon_to_string (GIcon* icon);
GType unity_internal_utils_diff_context_get_type (void) G_GNUC_CONST;
UnityInternalUtilsDiffContext* unity_internal_utils_diff_context_dup (const UnityInternalUtilsDiffContext* self);
void unity_internal_utils_diff_context_free (UnityInternalUtilsDiffContext* self);
void unity_internal_utils_diff_context_copy (const UnityInternalUtilsDiffContext* self,
                                             UnityInternalUtilsDiffContext* dest);
void unity_internal_utils_diff_context_destroy (UnityInternalUtilsDiffContext* self);
static void unity_internal_utils_diff_context_init (UnityInternalUtilsDiffContext *self,
                                             gint x_set_length,
                                             gint y_set_length);
static gint* _vala_array_dup11 (gint* self,
                         int length);
static guint8* _vala_array_dup12 (guint8* self,
                           int length);
GType unity_internal_utils_diff_partition_get_type (void) G_GNUC_CONST;
UnityInternalUtilsDiffPartition* unity_internal_utils_diff_partition_dup (const UnityInternalUtilsDiffPartition* self);
void unity_internal_utils_diff_partition_free (UnityInternalUtilsDiffPartition* self);
GType unity_internal_utils_diff_change_get_type (void) G_GNUC_CONST;
UnityInternalUtilsDiffChange* unity_internal_utils_diff_change_dup (const UnityInternalUtilsDiffChange* self);
void unity_internal_utils_diff_change_free (UnityInternalUtilsDiffChange* self);
GSList* unity_internal_utils_diff_run (gint x_set_length,
                                       gint y_set_length,
                                       UnityInternalUtilsDiffResultSetCompareFunc cmp_func,
                                       gpointer cmp_func_target);
gboolean unity_internal_utils_diff_compare_sequences (gint x_offset,
                                                      gint x_limit,
                                                      gint y_offset,
                                                      gint y_limit,
                                                      gboolean find_minimal,
                                                      UnityInternalUtilsDiffContext* ctx,
                                                      UnityInternalUtilsDiffResultSetCompareFunc equal_func,
                                                      gpointer equal_func_target);
GSList* unity_internal_utils_diff_build_edit_script (UnityInternalUtilsDiffContext* ctx);
static void _unity_internal_utils_diff_change_free0_ (gpointer var);
static inline void _g_slist_free__unity_internal_utils_diff_change_free0_ (GSList* self);
void unity_internal_utils_diff_find_diag (gint x_offset,
                                          gint x_limit,
                                          gint y_offset,
                                          gint y_limit,
                                          UnityInternalUtilsDiffResultSetCompareFunc equal_func,
                                          gpointer equal_func_target,
                                          UnityInternalUtilsDiffContext* ctx,
                                          UnityInternalUtilsDiffPartition* partition);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

const gchar* UNITY_INTERNAL_CATEGORIES_SCHEMA[5] = {"s", "s", "s", "s", "a{sv}"};
const gchar* UNITY_INTERNAL_FILTERS_SCHEMA[8] = {"s", "s", "s", "s", "a{sv}", "b", "b", "b"};
const gchar* UNITY_INTERNAL_RESULTS_SCHEMA[9] = {"s", "s", "u", "u", "s", "s", "s", "s", "a{sv}"};
const gchar* UNITY_INTERNAL_RESULTS_COLUMN_NAMES[9] = {"uri", "icon_hint", "category", "result_type", "mimetype", "title", "comment", "dnd_uri", "metadata"};

/**
   * Destroy an object.
   *
   * Unreferences object returned by one of unity_*_new constructors.
   */
void
unity_object_unref (void* object)
{
	GObject* o_ptr = NULL;
	gboolean _tmp0_ = FALSE;
	GObject* _tmp1_;
	o_ptr = (GObject*) object;
	_tmp1_ = o_ptr;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, G_TYPE_OBJECT)) {
		GObject* _tmp2_;
		const gchar* _tmp3_;
		_tmp2_ = o_ptr;
		_tmp3_ = g_type_name (G_TYPE_FROM_INSTANCE (_tmp2_));
		_tmp0_ = g_str_has_prefix (_tmp3_, "Unity");
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GObject* _tmp4_;
		_tmp4_ = o_ptr;
		g_object_unref (_tmp4_);
	} else {
		g_critical ("unity-utils.vala:38: Unable to unref object, invalid object type");
	}
}


GType
unity_internal_category_column_get_type (void)
{
	static volatile gsize unity_internal_category_column_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_category_column_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_INTERNAL_CATEGORY_COLUMN_ID, "UNITY_INTERNAL_CATEGORY_COLUMN_ID", "id"}, {UNITY_INTERNAL_CATEGORY_COLUMN_DISPLAY_NAME, "UNITY_INTERNAL_CATEGORY_COLUMN_DISPLAY_NAME", "display-name"}, {UNITY_INTERNAL_CATEGORY_COLUMN_ICON_HINT, "UNITY_INTERNAL_CATEGORY_COLUMN_ICON_HINT", "icon-hint"}, {UNITY_INTERNAL_CATEGORY_COLUMN_RENDERER_NAME, "UNITY_INTERNAL_CATEGORY_COLUMN_RENDERER_NAME", "renderer-name"}, {UNITY_INTERNAL_CATEGORY_COLUMN_HINTS, "UNITY_INTERNAL_CATEGORY_COLUMN_HINTS", "hints"}, {UNITY_INTERNAL_CATEGORY_COLUMN_N_COLUMNS, "UNITY_INTERNAL_CATEGORY_COLUMN_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType unity_internal_category_column_type_id;
		unity_internal_category_column_type_id = g_enum_register_static ("UnityInternalCategoryColumn", values);
		g_once_init_leave (&unity_internal_category_column_type_id__volatile, unity_internal_category_column_type_id);
	}
	return unity_internal_category_column_type_id__volatile;
}


GType
unity_internal_filter_column_get_type (void)
{
	static volatile gsize unity_internal_filter_column_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_filter_column_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_INTERNAL_FILTER_COLUMN_ID, "UNITY_INTERNAL_FILTER_COLUMN_ID", "id"}, {UNITY_INTERNAL_FILTER_COLUMN_DISPLAY_NAME, "UNITY_INTERNAL_FILTER_COLUMN_DISPLAY_NAME", "display-name"}, {UNITY_INTERNAL_FILTER_COLUMN_ICON_HINT, "UNITY_INTERNAL_FILTER_COLUMN_ICON_HINT", "icon-hint"}, {UNITY_INTERNAL_FILTER_COLUMN_RENDERER_NAME, "UNITY_INTERNAL_FILTER_COLUMN_RENDERER_NAME", "renderer-name"}, {UNITY_INTERNAL_FILTER_COLUMN_RENDERER_STATE, "UNITY_INTERNAL_FILTER_COLUMN_RENDERER_STATE", "renderer-state"}, {UNITY_INTERNAL_FILTER_COLUMN_VISIBLE, "UNITY_INTERNAL_FILTER_COLUMN_VISIBLE", "visible"}, {UNITY_INTERNAL_FILTER_COLUMN_COLLAPSED, "UNITY_INTERNAL_FILTER_COLUMN_COLLAPSED", "collapsed"}, {UNITY_INTERNAL_FILTER_COLUMN_FILTERING, "UNITY_INTERNAL_FILTER_COLUMN_FILTERING", "filtering"}, {UNITY_INTERNAL_FILTER_COLUMN_N_COLUMNS, "UNITY_INTERNAL_FILTER_COLUMN_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType unity_internal_filter_column_type_id;
		unity_internal_filter_column_type_id = g_enum_register_static ("UnityInternalFilterColumn", values);
		g_once_init_leave (&unity_internal_filter_column_type_id__volatile, unity_internal_filter_column_type_id);
	}
	return unity_internal_filter_column_type_id__volatile;
}


GType
unity_internal_result_column_get_type (void)
{
	static volatile gsize unity_internal_result_column_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_result_column_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_INTERNAL_RESULT_COLUMN_URI, "UNITY_INTERNAL_RESULT_COLUMN_URI", "uri"}, {UNITY_INTERNAL_RESULT_COLUMN_ICON_HINT, "UNITY_INTERNAL_RESULT_COLUMN_ICON_HINT", "icon-hint"}, {UNITY_INTERNAL_RESULT_COLUMN_CATEGORY, "UNITY_INTERNAL_RESULT_COLUMN_CATEGORY", "category"}, {UNITY_INTERNAL_RESULT_COLUMN_RESULT_TYPE, "UNITY_INTERNAL_RESULT_COLUMN_RESULT_TYPE", "result-type"}, {UNITY_INTERNAL_RESULT_COLUMN_MIMETYPE, "UNITY_INTERNAL_RESULT_COLUMN_MIMETYPE", "mimetype"}, {UNITY_INTERNAL_RESULT_COLUMN_TITLE, "UNITY_INTERNAL_RESULT_COLUMN_TITLE", "title"}, {UNITY_INTERNAL_RESULT_COLUMN_COMMENT, "UNITY_INTERNAL_RESULT_COLUMN_COMMENT", "comment"}, {UNITY_INTERNAL_RESULT_COLUMN_DND_URI, "UNITY_INTERNAL_RESULT_COLUMN_DND_URI", "dnd-uri"}, {UNITY_INTERNAL_RESULT_COLUMN_METADATA, "UNITY_INTERNAL_RESULT_COLUMN_METADATA", "metadata"}, {UNITY_INTERNAL_RESULT_COLUMN_N_COLUMNS, "UNITY_INTERNAL_RESULT_COLUMN_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType unity_internal_result_column_type_id;
		unity_internal_result_column_type_id = g_enum_register_static ("UnityInternalResultColumn", values);
		g_once_init_leave (&unity_internal_result_column_type_id__volatile, unity_internal_result_column_type_id);
	}
	return unity_internal_result_column_type_id__volatile;
}


UnityInternalUtilsDelegateWrapper*
unity_internal_utils_delegate_wrapper_new (GSourceFunc cb,
                                           gpointer cb_target,
                                           GDestroyNotify cb_target_destroy_notify)
{
	UnityInternalUtilsDelegateWrapper* self;
	GSourceFunc _tmp0_;
	void* _tmp0__target;
	GDestroyNotify _tmp0__target_destroy_notify;
	self = g_slice_new0 (UnityInternalUtilsDelegateWrapper);
	unity_internal_utils_delegate_wrapper_instance_init (self);
	_tmp0_ = cb;
	_tmp0__target = cb_target;
	_tmp0__target_destroy_notify = cb_target_destroy_notify;
	cb = NULL;
	cb_target = NULL;
	cb_target_destroy_notify = NULL;
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	self->callback = _tmp0_;
	self->callback_target = _tmp0__target;
	self->callback_target_destroy_notify = _tmp0__target_destroy_notify;
	(cb_target_destroy_notify == NULL) ? NULL : (cb_target_destroy_notify (cb_target), NULL);
	cb = NULL;
	cb_target = NULL;
	cb_target_destroy_notify = NULL;
	return self;
}


static void
unity_internal_utils_delegate_wrapper_instance_init (UnityInternalUtilsDelegateWrapper * self)
{
}


void
unity_internal_utils_delegate_wrapper_free (UnityInternalUtilsDelegateWrapper * self)
{
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	g_slice_free (UnityInternalUtilsDelegateWrapper, self);
}


static GType
unity_internal_utils_async_once_operation_state_get_type (void)
{
	static volatile gsize unity_internal_utils_async_once_operation_state_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_utils_async_once_operation_state_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED, "UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED", "not-started"}, {UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS, "UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS", "in-progress"}, {UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE, "UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE", "done"}, {0, NULL, NULL}};
		GType unity_internal_utils_async_once_operation_state_type_id;
		unity_internal_utils_async_once_operation_state_type_id = g_enum_register_static ("UnityInternalUtilsAsyncOnceOperationState", values);
		g_once_init_leave (&unity_internal_utils_async_once_operation_state_type_id__volatile, unity_internal_utils_async_once_operation_state_type_id);
	}
	return unity_internal_utils_async_once_operation_state_type_id__volatile;
}


UnityInternalUtilsAsyncOnce*
unity_internal_utils_async_once_construct (GType object_type,
                                           GType g_type,
                                           GBoxedCopyFunc g_dup_func,
                                           GDestroyNotify g_destroy_func)
{
	UnityInternalUtilsAsyncOnce* self = NULL;
	self = (UnityInternalUtilsAsyncOnce*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	self->priv->state = UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED;
	return self;
}


UnityInternalUtilsAsyncOnce*
unity_internal_utils_async_once_new (GType g_type,
                                     GBoxedCopyFunc g_dup_func,
                                     GDestroyNotify g_destroy_func)
{
	return unity_internal_utils_async_once_construct (UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, g_type, g_dup_func, g_destroy_func);
}


gconstpointer
unity_internal_utils_async_once_get_data (UnityInternalUtilsAsyncOnce* self)
{
	gconstpointer result = NULL;
	gconstpointer _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->inner;
	result = _tmp0_;
	return result;
}


gboolean
unity_internal_utils_async_once_is_initialized (UnityInternalUtilsAsyncOnce* self)
{
	gboolean result = FALSE;
	UnityInternalUtilsAsyncOnceOperationState _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->state;
	result = _tmp0_ == UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE;
	return result;
}


static void
unity_internal_utils_async_once_enter_data_free (gpointer _data)
{
	UnityInternalUtilsAsyncOnceEnterData* _data_;
	_data_ = _data;
	_unity_internal_utils_async_once_unref0 (_data_->self);
	g_slice_free (UnityInternalUtilsAsyncOnceEnterData, _data_);
}


static void
unity_internal_utils_async_once_enter_async_ready_wrapper (GObject *source_object,
                                                           GAsyncResult *res,
                                                           void *user_data)
{
	UnityInternalUtilsAsyncOnceEnterData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_unity_internal_utils_async_once_ref0 (gpointer self)
{
	return self ? unity_internal_utils_async_once_ref (self) : NULL;
}


void
unity_internal_utils_async_once_enter (UnityInternalUtilsAsyncOnce* self,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_)
{
	UnityInternalUtilsAsyncOnceEnterData* _data_;
	UnityInternalUtilsAsyncOnce* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalUtilsAsyncOnceEnterData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_utils_async_once_enter_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_utils_async_once_enter_data_free);
	_tmp0_ = _unity_internal_utils_async_once_ref0 (self);
	_data_->self = _tmp0_;
	unity_internal_utils_async_once_enter_co (_data_);
}


gboolean
unity_internal_utils_async_once_enter_finish (UnityInternalUtilsAsyncOnce* self,
                                              GAsyncResult* _res_)
{
	gboolean result;
	UnityInternalUtilsAsyncOnceEnterData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	return result;
}


static void
unity_internal_utils_async_once_enter_ready (GObject* source_object,
                                             GAsyncResult* _res_,
                                             gpointer _user_data_)
{
	UnityInternalUtilsAsyncOnceEnterData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_utils_async_once_enter_co (_data_);
}


static gboolean
unity_internal_utils_async_once_enter_co (UnityInternalUtilsAsyncOnceEnterData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->state;
	if (_data_->_tmp0_ == UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED) {
		_data_->self->priv->state = UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS;
		_data_->result = TRUE;
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		_data_->_tmp1_ = _data_->self->priv->state;
		if (_data_->_tmp1_ == UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS) {
			_data_->_state_ = 1;
			unity_internal_utils_async_once_wait_async (_data_->self, unity_internal_utils_async_once_enter_ready, _data_);
			return FALSE;
			_state_1:
			unity_internal_utils_async_once_wait_finish (_data_->self, _data_->_res_);
		}
	}
	_data_->result = FALSE;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void
unity_internal_utils_async_once_leave (UnityInternalUtilsAsyncOnce* self,
                                       gconstpointer _result_)
{
	UnityInternalUtilsAsyncOnceOperationState _tmp0_;
	gpointer _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state;
	if (_tmp0_ != UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS) {
		g_warning ("unity-utils.vala:172: Incorrect usage of AsyncOnce");
		return;
	}
	self->priv->state = UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE;
	_tmp1_ = ((_result_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _result_) : ((gpointer) _result_);
	((self->priv->inner == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->priv->inner = (self->priv->g_destroy_func (self->priv->inner), NULL));
	self->priv->inner = _tmp1_;
	unity_internal_utils_async_once_notify_all (self);
}


void
unity_internal_utils_async_once_reset (UnityInternalUtilsAsyncOnce* self)
{
	g_return_if_fail (self != NULL);
	self->priv->state = UNITY_INTERNAL_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED;
	((self->priv->inner == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->priv->inner = (self->priv->g_destroy_func (self->priv->inner), NULL));
	self->priv->inner = NULL;
}


static void
unity_internal_utils_async_once_notify_all (UnityInternalUtilsAsyncOnce* self)
{
	UnityInternalUtilsDelegateWrapper** _tmp0_;
	gint _tmp0__length1;
	UnityInternalUtilsDelegateWrapper** _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->callbacks;
	_tmp0__length1 = self->priv->callbacks_length1;
	{
		UnityInternalUtilsDelegateWrapper** wrapper_collection = NULL;
		gint wrapper_collection_length1 = 0;
		gint _wrapper_collection_size_ = 0;
		gint wrapper_it = 0;
		wrapper_collection = _tmp0_;
		wrapper_collection_length1 = _tmp0__length1;
		for (wrapper_it = 0; wrapper_it < _tmp0__length1; wrapper_it = wrapper_it + 1) {
			UnityInternalUtilsDelegateWrapper* wrapper = NULL;
			wrapper = wrapper_collection[wrapper_it];
			{
				UnityInternalUtilsDelegateWrapper* _tmp1_;
				GSourceFunc _tmp2_;
				void* _tmp2__target;
				_tmp1_ = wrapper;
				_tmp2_ = _tmp1_->callback;
				_tmp2__target = _tmp1_->callback_target;
				_tmp2_ (_tmp2__target);
			}
		}
	}
	_tmp3_ = g_new0 (UnityInternalUtilsDelegateWrapper*, 0 + 1);
	self->priv->callbacks = (_vala_array_free (self->priv->callbacks, self->priv->callbacks_length1, (GDestroyNotify) unity_internal_utils_delegate_wrapper_free), NULL);
	self->priv->callbacks = _tmp3_;
	self->priv->callbacks_length1 = 0;
	self->priv->_callbacks_size_ = self->priv->callbacks_length1;
}


static void
unity_internal_utils_async_once_wait_async_data_free (gpointer _data)
{
	UnityInternalUtilsAsyncOnceWaitAsyncData* _data_;
	_data_ = _data;
	_unity_internal_utils_async_once_unref0 (_data_->self);
	g_slice_free (UnityInternalUtilsAsyncOnceWaitAsyncData, _data_);
}


static void
unity_internal_utils_async_once_wait_async_async_ready_wrapper (GObject *source_object,
                                                                GAsyncResult *res,
                                                                void *user_data)
{
	UnityInternalUtilsAsyncOnceWaitAsyncData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static void
unity_internal_utils_async_once_wait_async (UnityInternalUtilsAsyncOnce* self,
                                            GAsyncReadyCallback _callback_,
                                            gpointer _user_data_)
{
	UnityInternalUtilsAsyncOnceWaitAsyncData* _data_;
	UnityInternalUtilsAsyncOnce* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalUtilsAsyncOnceWaitAsyncData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_utils_async_once_wait_async_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_utils_async_once_wait_async_data_free);
	_tmp0_ = _unity_internal_utils_async_once_ref0 (self);
	_data_->self = _tmp0_;
	unity_internal_utils_async_once_wait_async_co (_data_);
}


static void
unity_internal_utils_async_once_wait_finish (UnityInternalUtilsAsyncOnce* self,
                                             GAsyncResult* _res_)
{
	UnityInternalUtilsAsyncOnceWaitAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}


static gboolean
_unity_internal_utils_async_once_wait_async_co_gsource_func (gpointer self)
{
	gboolean result;
	result = unity_internal_utils_async_once_wait_async_co (self);
	return result;
}


static void
_vala_array_add14 (UnityInternalUtilsDelegateWrapper** * array,
                   int* length,
                   int* size,
                   UnityInternalUtilsDelegateWrapper* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (UnityInternalUtilsDelegateWrapper*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean
unity_internal_utils_async_once_wait_async_co (UnityInternalUtilsAsyncOnceWaitAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->callbacks;
	_data_->_tmp0__length1 = _data_->self->priv->callbacks_length1;
	_data_->_tmp1_ = unity_internal_utils_delegate_wrapper_new (_unity_internal_utils_async_once_wait_async_co_gsource_func, _data_, NULL);
	_vala_array_add14 (&_data_->self->priv->callbacks, &_data_->self->priv->callbacks_length1, &_data_->self->priv->_callbacks_size_, _data_->_tmp1_);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_utils_value_async_once_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}


static void
unity_internal_utils_value_async_once_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		unity_internal_utils_async_once_unref (value->data[0].v_pointer);
	}
}


static void
unity_internal_utils_value_async_once_copy_value (const GValue* src_value,
                                                  GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_internal_utils_async_once_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer
unity_internal_utils_value_async_once_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}


static gchar*
unity_internal_utils_value_async_once_collect_value (GValue* value,
                                                     guint n_collect_values,
                                                     GTypeCValue* collect_values,
                                                     guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		UnityInternalUtilsAsyncOnce * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_internal_utils_async_once_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar*
unity_internal_utils_value_async_once_lcopy_value (const GValue* value,
                                                   guint n_collect_values,
                                                   GTypeCValue* collect_values,
                                                   guint collect_flags)
{
	UnityInternalUtilsAsyncOnce ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_internal_utils_async_once_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec*
unity_internal_utils_param_spec_async_once (const gchar* name,
                                            const gchar* nick,
                                            const gchar* blurb,
                                            GType object_type,
                                            GParamFlags flags)
{
	UnityInternalUtilsParamSpecAsyncOnce* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer
unity_internal_utils_value_get_async_once (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE), NULL);
	return value->data[0].v_pointer;
}


void
unity_internal_utils_value_set_async_once (GValue* value,
                                           gpointer v_object)
{
	UnityInternalUtilsAsyncOnce * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_internal_utils_async_once_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_internal_utils_async_once_unref (old);
	}
}


void
unity_internal_utils_value_take_async_once (GValue* value,
                                            gpointer v_object)
{
	UnityInternalUtilsAsyncOnce * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_internal_utils_async_once_unref (old);
	}
}


static void
unity_internal_utils_async_once_class_init (UnityInternalUtilsAsyncOnceClass * klass)
{
	unity_internal_utils_async_once_parent_class = g_type_class_peek_parent (klass);
	((UnityInternalUtilsAsyncOnceClass *) klass)->finalize = unity_internal_utils_async_once_finalize;
	g_type_class_add_private (klass, sizeof (UnityInternalUtilsAsyncOncePrivate));
}


static void
unity_internal_utils_async_once_instance_init (UnityInternalUtilsAsyncOnce * self)
{
	UnityInternalUtilsDelegateWrapper** _tmp0_;
	self->priv = UNITY_INTERNAL_UTILS_ASYNC_ONCE_GET_PRIVATE (self);
	_tmp0_ = g_new0 (UnityInternalUtilsDelegateWrapper*, 0 + 1);
	self->priv->callbacks = _tmp0_;
	self->priv->callbacks_length1 = 0;
	self->priv->_callbacks_size_ = self->priv->callbacks_length1;
	self->ref_count = 1;
}


static void
unity_internal_utils_async_once_finalize (UnityInternalUtilsAsyncOnce * obj)
{
	UnityInternalUtilsAsyncOnce * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_INTERNAL_UTILS_TYPE_ASYNC_ONCE, UnityInternalUtilsAsyncOnce);
	g_signal_handlers_destroy (self);
	((self->priv->inner == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->priv->inner = (self->priv->g_destroy_func (self->priv->inner), NULL));
	self->priv->callbacks = (_vala_array_free (self->priv->callbacks, self->priv->callbacks_length1, (GDestroyNotify) unity_internal_utils_delegate_wrapper_free), NULL);
}


GType
unity_internal_utils_async_once_get_type (void)
{
	static volatile gsize unity_internal_utils_async_once_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_utils_async_once_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_internal_utils_value_async_once_init, unity_internal_utils_value_async_once_free_value, unity_internal_utils_value_async_once_copy_value, unity_internal_utils_value_async_once_peek_pointer, "p", unity_internal_utils_value_async_once_collect_value, "p", unity_internal_utils_value_async_once_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityInternalUtilsAsyncOnceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_internal_utils_async_once_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityInternalUtilsAsyncOnce), 0, (GInstanceInitFunc) unity_internal_utils_async_once_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_internal_utils_async_once_type_id;
		unity_internal_utils_async_once_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityInternalUtilsAsyncOnce", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_internal_utils_async_once_type_id__volatile, unity_internal_utils_async_once_type_id);
	}
	return unity_internal_utils_async_once_type_id__volatile;
}


gpointer
unity_internal_utils_async_once_ref (gpointer instance)
{
	UnityInternalUtilsAsyncOnce * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void
unity_internal_utils_async_once_unref (gpointer instance)
{
	UnityInternalUtilsAsyncOnce * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_INTERNAL_UTILS_ASYNC_ONCE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void
_unity_internal_utils_delegate_wrapper_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (unity_internal_utils_delegate_wrapper_free (var), NULL));
}


static inline void
_g_queue_free__unity_internal_utils_delegate_wrapper_free0_ (GQueue* self)
{
	g_queue_free_full (self, (GDestroyNotify) _unity_internal_utils_delegate_wrapper_free0_);
}


UnityInternalUtilsAsyncMutex*
unity_internal_utils_async_mutex_construct (GType object_type)
{
	UnityInternalUtilsAsyncMutex* self = NULL;
	GQueue* _tmp0_;
	self = (UnityInternalUtilsAsyncMutex*) g_type_create_instance (object_type);
	_tmp0_ = g_queue_new ();
	(self->priv->callbacks == NULL) ? NULL : (self->priv->callbacks = (_g_queue_free__unity_internal_utils_delegate_wrapper_free0_ (self->priv->callbacks), NULL));
	self->priv->callbacks = _tmp0_;
	self->priv->is_locked = FALSE;
	return self;
}


UnityInternalUtilsAsyncMutex*
unity_internal_utils_async_mutex_new (void)
{
	return unity_internal_utils_async_mutex_construct (UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX);
}


gboolean
unity_internal_utils_async_mutex_try_lock (UnityInternalUtilsAsyncMutex* self)
{
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->is_locked;
	if (!_tmp0_) {
		self->priv->is_locked = TRUE;
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static void
unity_internal_utils_async_mutex_lock_data_free (gpointer _data)
{
	UnityInternalUtilsAsyncMutexLockData* _data_;
	_data_ = _data;
	_unity_internal_utils_async_mutex_unref0 (_data_->self);
	g_slice_free (UnityInternalUtilsAsyncMutexLockData, _data_);
}


static void
unity_internal_utils_async_mutex_lock_async_ready_wrapper (GObject *source_object,
                                                           GAsyncResult *res,
                                                           void *user_data)
{
	UnityInternalUtilsAsyncMutexLockData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_unity_internal_utils_async_mutex_ref0 (gpointer self)
{
	return self ? unity_internal_utils_async_mutex_ref (self) : NULL;
}


void
unity_internal_utils_async_mutex_lock (UnityInternalUtilsAsyncMutex* self,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_)
{
	UnityInternalUtilsAsyncMutexLockData* _data_;
	UnityInternalUtilsAsyncMutex* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalUtilsAsyncMutexLockData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_utils_async_mutex_lock_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_utils_async_mutex_lock_data_free);
	_tmp0_ = _unity_internal_utils_async_mutex_ref0 (self);
	_data_->self = _tmp0_;
	unity_internal_utils_async_mutex_lock_co (_data_);
}


void
unity_internal_utils_async_mutex_lock_finish (UnityInternalUtilsAsyncMutex* self,
                                              GAsyncResult* _res_)
{
	UnityInternalUtilsAsyncMutexLockData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}


static void
unity_internal_utils_async_mutex_lock_ready (GObject* source_object,
                                             GAsyncResult* _res_,
                                             gpointer _user_data_)
{
	UnityInternalUtilsAsyncMutexLockData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	unity_internal_utils_async_mutex_lock_co (_data_);
}


static gboolean
unity_internal_utils_async_mutex_lock_co (UnityInternalUtilsAsyncMutexLockData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->is_locked;
	if (!_data_->_tmp0_) {
		_data_->self->priv->is_locked = TRUE;
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_state_ = 1;
	unity_internal_utils_async_mutex_wait_async (_data_->self, unity_internal_utils_async_mutex_lock_ready, _data_);
	return FALSE;
	_state_1:
	unity_internal_utils_async_mutex_wait_finish (_data_->self, _data_->_res_);
	_data_->self->priv->is_locked = TRUE;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void
unity_internal_utils_async_mutex_unlock (UnityInternalUtilsAsyncMutex* self)
{
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->is_locked;
	if (!_tmp0_) {
		g_warning ("unity-utils.vala:239: Unlock failed: AsyncMutex was already unlocked");
		return;
	}
	self->priv->is_locked = FALSE;
	unity_internal_utils_async_mutex_notify (self);
}


static void
unity_internal_utils_async_mutex_notify (UnityInternalUtilsAsyncMutex* self)
{
	GQueue* _tmp0_;
	UnityInternalUtilsDelegateWrapper* cb = NULL;
	GQueue* _tmp1_;
	gpointer _tmp2_;
	UnityInternalUtilsDelegateWrapper* _tmp3_;
	GSourceFunc _tmp4_;
	void* _tmp4__target;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->callbacks;
	if (g_queue_is_empty (_tmp0_)) {
		return;
	}
	_tmp1_ = self->priv->callbacks;
	_tmp2_ = g_queue_pop_head (_tmp1_);
	cb = (UnityInternalUtilsDelegateWrapper*) _tmp2_;
	_tmp3_ = cb;
	_tmp4_ = _tmp3_->callback;
	_tmp4__target = _tmp3_->callback_target;
	_tmp4_ (_tmp4__target);
	_unity_internal_utils_delegate_wrapper_free0 (cb);
}


static void
unity_internal_utils_async_mutex_wait_async_data_free (gpointer _data)
{
	UnityInternalUtilsAsyncMutexWaitAsyncData* _data_;
	_data_ = _data;
	_unity_internal_utils_async_mutex_unref0 (_data_->self);
	g_slice_free (UnityInternalUtilsAsyncMutexWaitAsyncData, _data_);
}


static void
unity_internal_utils_async_mutex_wait_async_async_ready_wrapper (GObject *source_object,
                                                                 GAsyncResult *res,
                                                                 void *user_data)
{
	UnityInternalUtilsAsyncMutexWaitAsyncData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static void
unity_internal_utils_async_mutex_wait_async (UnityInternalUtilsAsyncMutex* self,
                                             GAsyncReadyCallback _callback_,
                                             gpointer _user_data_)
{
	UnityInternalUtilsAsyncMutexWaitAsyncData* _data_;
	UnityInternalUtilsAsyncMutex* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalUtilsAsyncMutexWaitAsyncData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_utils_async_mutex_wait_async_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_utils_async_mutex_wait_async_data_free);
	_tmp0_ = _unity_internal_utils_async_mutex_ref0 (self);
	_data_->self = _tmp0_;
	unity_internal_utils_async_mutex_wait_async_co (_data_);
}


static void
unity_internal_utils_async_mutex_wait_finish (UnityInternalUtilsAsyncMutex* self,
                                              GAsyncResult* _res_)
{
	UnityInternalUtilsAsyncMutexWaitAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}


static gboolean
_unity_internal_utils_async_mutex_wait_async_co_gsource_func (gpointer self)
{
	gboolean result;
	result = unity_internal_utils_async_mutex_wait_async_co (self);
	return result;
}


static gboolean
unity_internal_utils_async_mutex_wait_async_co (UnityInternalUtilsAsyncMutexWaitAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->callbacks;
	_data_->_tmp1_ = unity_internal_utils_delegate_wrapper_new (_unity_internal_utils_async_mutex_wait_async_co_gsource_func, _data_, NULL);
	g_queue_push_tail (_data_->_tmp0_, _data_->_tmp1_);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
unity_internal_utils_value_async_mutex_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}


static void
unity_internal_utils_value_async_mutex_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		unity_internal_utils_async_mutex_unref (value->data[0].v_pointer);
	}
}


static void
unity_internal_utils_value_async_mutex_copy_value (const GValue* src_value,
                                                   GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_internal_utils_async_mutex_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer
unity_internal_utils_value_async_mutex_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}


static gchar*
unity_internal_utils_value_async_mutex_collect_value (GValue* value,
                                                      guint n_collect_values,
                                                      GTypeCValue* collect_values,
                                                      guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		UnityInternalUtilsAsyncMutex * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_internal_utils_async_mutex_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar*
unity_internal_utils_value_async_mutex_lcopy_value (const GValue* value,
                                                    guint n_collect_values,
                                                    GTypeCValue* collect_values,
                                                    guint collect_flags)
{
	UnityInternalUtilsAsyncMutex ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_internal_utils_async_mutex_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec*
unity_internal_utils_param_spec_async_mutex (const gchar* name,
                                             const gchar* nick,
                                             const gchar* blurb,
                                             GType object_type,
                                             GParamFlags flags)
{
	UnityInternalUtilsParamSpecAsyncMutex* spec;
	g_return_val_if_fail (g_type_is_a (object_type, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer
unity_internal_utils_value_get_async_mutex (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX), NULL);
	return value->data[0].v_pointer;
}


void
unity_internal_utils_value_set_async_mutex (GValue* value,
                                            gpointer v_object)
{
	UnityInternalUtilsAsyncMutex * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_internal_utils_async_mutex_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_internal_utils_async_mutex_unref (old);
	}
}


void
unity_internal_utils_value_take_async_mutex (GValue* value,
                                             gpointer v_object)
{
	UnityInternalUtilsAsyncMutex * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_internal_utils_async_mutex_unref (old);
	}
}


static void
unity_internal_utils_async_mutex_class_init (UnityInternalUtilsAsyncMutexClass * klass)
{
	unity_internal_utils_async_mutex_parent_class = g_type_class_peek_parent (klass);
	((UnityInternalUtilsAsyncMutexClass *) klass)->finalize = unity_internal_utils_async_mutex_finalize;
	g_type_class_add_private (klass, sizeof (UnityInternalUtilsAsyncMutexPrivate));
}


static void
unity_internal_utils_async_mutex_instance_init (UnityInternalUtilsAsyncMutex * self)
{
	self->priv = UNITY_INTERNAL_UTILS_ASYNC_MUTEX_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void
unity_internal_utils_async_mutex_finalize (UnityInternalUtilsAsyncMutex * obj)
{
	UnityInternalUtilsAsyncMutex * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_INTERNAL_UTILS_TYPE_ASYNC_MUTEX, UnityInternalUtilsAsyncMutex);
	g_signal_handlers_destroy (self);
	(self->priv->callbacks == NULL) ? NULL : (self->priv->callbacks = (_g_queue_free__unity_internal_utils_delegate_wrapper_free0_ (self->priv->callbacks), NULL));
}


GType
unity_internal_utils_async_mutex_get_type (void)
{
	static volatile gsize unity_internal_utils_async_mutex_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_utils_async_mutex_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { unity_internal_utils_value_async_mutex_init, unity_internal_utils_value_async_mutex_free_value, unity_internal_utils_value_async_mutex_copy_value, unity_internal_utils_value_async_mutex_peek_pointer, "p", unity_internal_utils_value_async_mutex_collect_value, "p", unity_internal_utils_value_async_mutex_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityInternalUtilsAsyncMutexClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_internal_utils_async_mutex_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityInternalUtilsAsyncMutex), 0, (GInstanceInitFunc) unity_internal_utils_async_mutex_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_internal_utils_async_mutex_type_id;
		unity_internal_utils_async_mutex_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityInternalUtilsAsyncMutex", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_internal_utils_async_mutex_type_id__volatile, unity_internal_utils_async_mutex_type_id);
	}
	return unity_internal_utils_async_mutex_type_id__volatile;
}


gpointer
unity_internal_utils_async_mutex_ref (gpointer instance)
{
	UnityInternalUtilsAsyncMutex * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void
unity_internal_utils_async_mutex_unref (gpointer instance)
{
	UnityInternalUtilsAsyncMutex * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_INTERNAL_UTILS_ASYNC_MUTEX_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void
unity_internal_utils_wait_for_model_synchronization_data_free (gpointer _data)
{
	UnityInternalUtilsWaitForModelSynchronizationData* _data_;
	_data_ = _data;
	g_slice_free (UnityInternalUtilsWaitForModelSynchronizationData, _data_);
}


static void
unity_internal_utils_wait_for_model_synchronization_async_ready_wrapper (GObject *source_object,
                                                                         GAsyncResult *res,
                                                                         void *user_data)
{
	UnityInternalUtilsWaitForModelSynchronizationData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


void
unity_internal_utils_wait_for_model_synchronization (DeeSharedModel* model,
                                                     GAsyncReadyCallback _callback_,
                                                     gpointer _user_data_)
{
	UnityInternalUtilsWaitForModelSynchronizationData* _data_;
	DeeSharedModel* _tmp0_;
	_data_ = g_slice_new0 (UnityInternalUtilsWaitForModelSynchronizationData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, unity_internal_utils_wait_for_model_synchronization_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, unity_internal_utils_wait_for_model_synchronization_data_free);
	_tmp0_ = _g_object_ref0 (model);
	_g_object_unref0 (_data_->model);
	_data_->model = _tmp0_;
	unity_internal_utils_wait_for_model_synchronization_co (_data_);
}


void
unity_internal_utils_wait_for_model_synchronization_finish (GAsyncResult* _res_)
{
	UnityInternalUtilsWaitForModelSynchronizationData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}


static Block29Data*
block29_data_ref (Block29Data* _data29_)
{
	g_atomic_int_inc (&_data29_->_ref_count_);
	return _data29_;
}


static void
block29_data_unref (void * _userdata_)
{
	Block29Data* _data29_;
	_data29_ = (Block29Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data29_->_ref_count_)) {
		_g_object_unref0 (_data29_->model);
		g_slice_free (Block29Data, _data29_);
	}
}


static void
__lambda17_ (Block29Data* _data29_)
{
	if (dee_shared_model_is_synchronized (_data29_->model)) {
		unity_internal_utils_wait_for_model_synchronization_co (_data29_->_async_data_);
	}
}


static void
___lambda17__g_object_notify (GObject* _sender,
                              GParamSpec* pspec,
                              gpointer self)
{
	__lambda17_ (self);
}


static gboolean
unity_internal_utils_wait_for_model_synchronization_co (UnityInternalUtilsWaitForModelSynchronizationData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data29_ = g_slice_new0 (Block29Data);
	_data_->_data29_->_ref_count_ = 1;
	_g_object_unref0 (_data_->_data29_->model);
	_data_->_data29_->model = _data_->model;
	_data_->_data29_->_async_data_ = _data_;
	if (dee_shared_model_is_synchronized (_data_->_data29_->model)) {
		block29_data_unref (_data_->_data29_);
		_data_->_data29_ = NULL;
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp0_ = g_signal_connect_data ((GObject*) _data_->_data29_->model, "notify::synchronized", (GCallback) ___lambda17__g_object_notify, block29_data_ref (_data_->_data29_), (GClosureNotify) block29_data_unref, 0);
	_data_->sig_id = _data_->_tmp0_;
	_data_->_tmp1_ = _data_->sig_id;
	if (_data_->_tmp1_ == ((gulong) 0)) {
		g_critical ("unity-utils.vala:274: Internal error, unable to wait for synchronizati" \
"on");
		block29_data_unref (_data_->_data29_);
		_data_->_data29_ = NULL;
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (_data_->_task_complete_ != TRUE) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->_tmp2_ = _data_->sig_id;
	g_signal_handler_disconnect (_data_->_data29_->model, _data_->_tmp2_);
	block29_data_unref (_data_->_data29_);
	_data_->_data29_ = NULL;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gpointer
_g_variant_ref0 (gpointer self)
{
	return self ? g_variant_ref (self) : NULL;
}


GVariant*
unity_internal_utils_hash_table_to_asv (GHashTable* hash)
{
	GVariant* result = NULL;
	GVariantBuilder* b = NULL;
	GVariantType* _tmp0_;
	GVariantType* _tmp1_;
	GVariantBuilder* _tmp2_;
	GVariantBuilder* _tmp3_;
	GHashTableIter iter = {0};
	gchar* key = NULL;
	GVariant* val = NULL;
	GVariantBuilder* _tmp12_;
	GVariant* _tmp13_;
	g_return_val_if_fail (hash != NULL, NULL);
	_tmp0_ = g_variant_type_new ("a{sv}");
	_tmp1_ = _tmp0_;
	_tmp2_ = g_variant_builder_new (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_variant_type_free0 (_tmp1_);
	b = _tmp3_;
	g_hash_table_iter_init (&iter, hash);
	while (TRUE) {
		gconstpointer _tmp4_ = NULL;
		gconstpointer _tmp5_ = NULL;
		gboolean _tmp6_;
		gchar* _tmp7_;
		GVariant* _tmp8_;
		GVariantBuilder* _tmp9_;
		const gchar* _tmp10_;
		GVariant* _tmp11_;
		_tmp6_ = g_hash_table_iter_next (&iter, (gpointer*) (&_tmp4_), (gpointer*) (&_tmp5_));
		_g_free0 (key);
		_tmp7_ = g_strdup (_tmp4_);
		key = _tmp7_;
		_g_variant_unref0 (val);
		_tmp8_ = _g_variant_ref0 (_tmp5_);
		val = _tmp8_;
		if (!_tmp6_) {
			break;
		}
		_tmp9_ = b;
		_tmp10_ = key;
		_tmp11_ = val;
		g_variant_builder_add (_tmp9_, "{sv}", _tmp10_, _tmp11_, NULL);
	}
	_tmp12_ = b;
	_tmp13_ = g_variant_builder_end (_tmp12_);
	g_variant_ref_sink (_tmp13_);
	result = _tmp13_;
	_g_variant_unref0 (val);
	_g_free0 (key);
	_g_variant_builder_unref0 (b);
	return result;
}


gchar*
unity_internal_utils_icon_to_string (GIcon* icon)
{
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	if (icon != NULL) {
		gchar* _tmp1_;
		_tmp1_ = g_icon_to_string (icon);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp1_;
	} else {
		gchar* _tmp2_;
		_tmp2_ = g_strdup ("");
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp2_;
	}
	result = _tmp0_;
	return result;
}


static void
unity_internal_utils_diff_context_init (UnityInternalUtilsDiffContext *self,
                                        gint x_set_length,
                                        gint y_set_length)
{
	gint diags = 0;
	gint _tmp0_;
	gint* _tmp1_;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint* _tmp3_;
	gint* _tmp4_;
	gint _tmp4__length1;
	gint* _tmp5_;
	gint _tmp6_;
	gint* _tmp7_;
	gint _tmp8_;
	guint8* _tmp9_;
	guint8* _tmp10_;
	gint _tmp10__length1;
	guint8* _tmp11_;
	gint _tmp11__length1;
	guint8* _tmp12_;
	gint _tmp16_;
	memset (self, 0, sizeof (UnityInternalUtilsDiffContext));
	(*self).x_length = x_set_length;
	(*self).y_length = y_set_length;
	diags = (((x_set_length + 1) + y_set_length) + 1) + 1;
	_tmp0_ = diags;
	_tmp1_ = g_new0 (gint, _tmp0_ * 2);
	(*self).real_diag = (g_free ((*self).real_diag), NULL);
	(*self).real_diag = _tmp1_;
	(*self).real_diag_length1 = _tmp0_ * 2;
	(*self)._real_diag_size_ = (*self).real_diag_length1;
	_tmp2_ = (*self).real_diag;
	_tmp2__length1 = (*self).real_diag_length1;
	(*self).f_diag = _tmp2_;
	_tmp3_ = (*self).f_diag;
	(*self).f_diag = _tmp3_ + (y_set_length + 1);
	_tmp4_ = (*self).real_diag;
	_tmp4__length1 = (*self).real_diag_length1;
	(*self).b_diag = _tmp4_;
	_tmp5_ = (*self).b_diag;
	_tmp6_ = diags;
	(*self).b_diag = _tmp5_ + _tmp6_;
	_tmp7_ = (*self).b_diag;
	(*self).b_diag = _tmp7_ + (y_set_length + 1);
	_tmp8_ = diags;
	_tmp9_ = g_new0 (guint8, _tmp8_);
	(*self).real_changes = (g_free ((*self).real_changes), NULL);
	(*self).real_changes = _tmp9_;
	(*self).real_changes_length1 = _tmp8_;
	(*self)._real_changes_size_ = (*self).real_changes_length1;
	_tmp10_ = (*self).real_changes;
	_tmp10__length1 = (*self).real_changes_length1;
	(*self).x_changes = _tmp10_;
	_tmp11_ = (*self).real_changes;
	_tmp11__length1 = (*self).real_changes_length1;
	(*self).y_changes = _tmp11_;
	_tmp12_ = (*self).y_changes;
	(*self).y_changes = _tmp12_ + (x_set_length + 1);
	(*self).max_cost = 1;
	while (TRUE) {
		gint _tmp13_;
		gint _tmp14_;
		gint _tmp15_;
		_tmp13_ = diags;
		if (!(_tmp13_ != 0)) {
			break;
		}
		_tmp14_ = diags;
		diags = _tmp14_ / 4;
		_tmp15_ = (*self).max_cost;
		(*self).max_cost = _tmp15_ * 2;
	}
	_tmp16_ = (*self).max_cost;
	(*self).max_cost = MAX (_tmp16_, 256);
}


static gint*
_vala_array_dup11 (gint* self,
                   int length)
{
	return g_memdup (self, length * sizeof (gint));
}


static guint8*
_vala_array_dup12 (guint8* self,
                   int length)
{
	return g_memdup (self, length * sizeof (guint8));
}


void
unity_internal_utils_diff_context_copy (const UnityInternalUtilsDiffContext* self,
                                        UnityInternalUtilsDiffContext* dest)
{
	gint _tmp0_;
	gint _tmp1_;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint* _tmp3_;
	gint _tmp3__length1;
	gint* _tmp4_;
	gint* _tmp5_;
	gint _tmp6_;
	guint8* _tmp7_;
	gint _tmp7__length1;
	guint8* _tmp8_;
	gint _tmp8__length1;
	guint8* _tmp9_;
	guint8* _tmp10_;
	_tmp0_ = (*self).x_length;
	(*dest).x_length = _tmp0_;
	_tmp1_ = (*self).y_length;
	(*dest).y_length = _tmp1_;
	_tmp2_ = (*self).real_diag;
	_tmp2__length1 = (*self).real_diag_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup11 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	(*dest).real_diag = (g_free ((*dest).real_diag), NULL);
	(*dest).real_diag = _tmp3_;
	(*dest).real_diag_length1 = _tmp3__length1;
	(*dest)._real_diag_size_ = (*dest).real_diag_length1;
	_tmp4_ = (*self).f_diag;
	(*dest).f_diag = _tmp4_;
	_tmp5_ = (*self).b_diag;
	(*dest).b_diag = _tmp5_;
	_tmp6_ = (*self).max_cost;
	(*dest).max_cost = _tmp6_;
	_tmp7_ = (*self).real_changes;
	_tmp7__length1 = (*self).real_changes_length1;
	_tmp8_ = (_tmp7_ != NULL) ? _vala_array_dup12 (_tmp7_, _tmp7__length1) : ((gpointer) _tmp7_);
	_tmp8__length1 = _tmp7__length1;
	(*dest).real_changes = (g_free ((*dest).real_changes), NULL);
	(*dest).real_changes = _tmp8_;
	(*dest).real_changes_length1 = _tmp8__length1;
	(*dest)._real_changes_size_ = (*dest).real_changes_length1;
	_tmp9_ = (*self).x_changes;
	(*dest).x_changes = _tmp9_;
	_tmp10_ = (*self).y_changes;
	(*dest).y_changes = _tmp10_;
}


void
unity_internal_utils_diff_context_destroy (UnityInternalUtilsDiffContext* self)
{
	(*self).real_diag = (g_free ((*self).real_diag), NULL);
	(*self).real_changes = (g_free ((*self).real_changes), NULL);
}


UnityInternalUtilsDiffContext*
unity_internal_utils_diff_context_dup (const UnityInternalUtilsDiffContext* self)
{
	UnityInternalUtilsDiffContext* dup;
	dup = g_new0 (UnityInternalUtilsDiffContext, 1);
	unity_internal_utils_diff_context_copy (self, dup);
	return dup;
}


void
unity_internal_utils_diff_context_free (UnityInternalUtilsDiffContext* self)
{
	unity_internal_utils_diff_context_destroy (self);
	g_free (self);
}


GType
unity_internal_utils_diff_context_get_type (void)
{
	static volatile gsize unity_internal_utils_diff_context_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_utils_diff_context_type_id__volatile)) {
		GType unity_internal_utils_diff_context_type_id;
		unity_internal_utils_diff_context_type_id = g_boxed_type_register_static ("UnityInternalUtilsDiffContext", (GBoxedCopyFunc) unity_internal_utils_diff_context_dup, (GBoxedFreeFunc) unity_internal_utils_diff_context_free);
		g_once_init_leave (&unity_internal_utils_diff_context_type_id__volatile, unity_internal_utils_diff_context_type_id);
	}
	return unity_internal_utils_diff_context_type_id__volatile;
}


UnityInternalUtilsDiffPartition*
unity_internal_utils_diff_partition_dup (const UnityInternalUtilsDiffPartition* self)
{
	UnityInternalUtilsDiffPartition* dup;
	dup = g_new0 (UnityInternalUtilsDiffPartition, 1);
	memcpy (dup, self, sizeof (UnityInternalUtilsDiffPartition));
	return dup;
}


void
unity_internal_utils_diff_partition_free (UnityInternalUtilsDiffPartition* self)
{
	g_free (self);
}


GType
unity_internal_utils_diff_partition_get_type (void)
{
	static volatile gsize unity_internal_utils_diff_partition_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_utils_diff_partition_type_id__volatile)) {
		GType unity_internal_utils_diff_partition_type_id;
		unity_internal_utils_diff_partition_type_id = g_boxed_type_register_static ("UnityInternalUtilsDiffPartition", (GBoxedCopyFunc) unity_internal_utils_diff_partition_dup, (GBoxedFreeFunc) unity_internal_utils_diff_partition_free);
		g_once_init_leave (&unity_internal_utils_diff_partition_type_id__volatile, unity_internal_utils_diff_partition_type_id);
	}
	return unity_internal_utils_diff_partition_type_id__volatile;
}


UnityInternalUtilsDiffChange*
unity_internal_utils_diff_change_dup (const UnityInternalUtilsDiffChange* self)
{
	UnityInternalUtilsDiffChange* dup;
	dup = g_new0 (UnityInternalUtilsDiffChange, 1);
	memcpy (dup, self, sizeof (UnityInternalUtilsDiffChange));
	return dup;
}


void
unity_internal_utils_diff_change_free (UnityInternalUtilsDiffChange* self)
{
	g_free (self);
}


GType
unity_internal_utils_diff_change_get_type (void)
{
	static volatile gsize unity_internal_utils_diff_change_type_id__volatile = 0;
	if (g_once_init_enter (&unity_internal_utils_diff_change_type_id__volatile)) {
		GType unity_internal_utils_diff_change_type_id;
		unity_internal_utils_diff_change_type_id = g_boxed_type_register_static ("UnityInternalUtilsDiffChange", (GBoxedCopyFunc) unity_internal_utils_diff_change_dup, (GBoxedFreeFunc) unity_internal_utils_diff_change_free);
		g_once_init_leave (&unity_internal_utils_diff_change_type_id__volatile, unity_internal_utils_diff_change_type_id);
	}
	return unity_internal_utils_diff_change_type_id__volatile;
}


GSList*
unity_internal_utils_diff_run (gint x_set_length,
                               gint y_set_length,
                               UnityInternalUtilsDiffResultSetCompareFunc cmp_func,
                               gpointer cmp_func_target)
{
	GSList* result = NULL;
	UnityInternalUtilsDiffContext ctx = {0};
	GSList* _tmp0_;
	unity_internal_utils_diff_context_init (&ctx, x_set_length, y_set_length);
	unity_internal_utils_diff_compare_sequences (0, x_set_length, 0, y_set_length, FALSE, &ctx, cmp_func, cmp_func_target);
	_tmp0_ = unity_internal_utils_diff_build_edit_script (&ctx);
	result = _tmp0_;
	unity_internal_utils_diff_context_destroy (&ctx);
	return result;
}


static gpointer
_unity_internal_utils_diff_change_dup0 (gpointer self)
{
	return self ? unity_internal_utils_diff_change_dup (self) : NULL;
}


static void
_unity_internal_utils_diff_change_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (unity_internal_utils_diff_change_free (var), NULL));
}


static inline void
_g_slist_free__unity_internal_utils_diff_change_free0_ (GSList* self)
{
	g_slist_free_full (self, (GDestroyNotify) _unity_internal_utils_diff_change_free0_);
}


GSList*
unity_internal_utils_diff_build_edit_script (UnityInternalUtilsDiffContext* ctx)
{
	GSList* result = NULL;
	GSList* script = NULL;
	gint x_length = 0;
	UnityInternalUtilsDiffContext _tmp0_;
	gint _tmp1_;
	gint y_length = 0;
	UnityInternalUtilsDiffContext _tmp2_;
	gint _tmp3_;
	guint8* x_changes = NULL;
	UnityInternalUtilsDiffContext _tmp4_;
	guint8* _tmp5_;
	guint8* y_changes = NULL;
	UnityInternalUtilsDiffContext _tmp6_;
	guint8* _tmp7_;
	gint x = 0;
	gint y = 0;
	g_return_val_if_fail (ctx != NULL, NULL);
	script = NULL;
	_tmp0_ = *ctx;
	_tmp1_ = _tmp0_.x_length;
	x_length = _tmp1_;
	_tmp2_ = *ctx;
	_tmp3_ = _tmp2_.y_length;
	y_length = _tmp3_;
	_tmp4_ = *ctx;
	_tmp5_ = _tmp4_.x_changes;
	x_changes = _tmp5_;
	_tmp6_ = *ctx;
	_tmp7_ = _tmp6_.y_changes;
	y_changes = _tmp7_;
	x = 0;
	y = 0;
	while (TRUE) {
		gboolean _tmp8_ = FALSE;
		gint _tmp9_;
		gint _tmp10_;
		guint8* _tmp13_;
		gint _tmp14_;
		guint8 _tmp15_;
		guint8* _tmp16_;
		gint _tmp17_;
		guint8 _tmp18_;
		gint _tmp37_;
		gint _tmp38_;
		_tmp9_ = x;
		_tmp10_ = x_length;
		if (_tmp9_ < _tmp10_) {
			_tmp8_ = TRUE;
		} else {
			gint _tmp11_;
			gint _tmp12_;
			_tmp11_ = y;
			_tmp12_ = y_length;
			_tmp8_ = _tmp11_ < _tmp12_;
		}
		if (!_tmp8_) {
			break;
		}
		_tmp13_ = x_changes;
		_tmp14_ = x;
		_tmp15_ = _tmp13_[_tmp14_];
		_tmp16_ = y_changes;
		_tmp17_ = y;
		_tmp18_ = _tmp16_[_tmp17_];
		if (((gint) (_tmp15_ | _tmp18_)) != 0) {
			gint xx = 0;
			gint _tmp19_;
			gint yy = 0;
			gint _tmp20_;
			gint _tmp29_;
			gint _tmp30_;
			gint _tmp31_;
			gint _tmp32_;
			gint _tmp33_;
			gint _tmp34_;
			UnityInternalUtilsDiffChange _tmp35_ = {0};
			UnityInternalUtilsDiffChange* _tmp36_;
			_tmp19_ = x;
			xx = _tmp19_;
			_tmp20_ = y;
			yy = _tmp20_;
			while (TRUE) {
				guint8* _tmp21_;
				gint _tmp22_;
				guint8 _tmp23_;
				gint _tmp24_;
				_tmp21_ = x_changes;
				_tmp22_ = x;
				_tmp23_ = _tmp21_[_tmp22_];
				if (!(((gint) _tmp23_) != 0)) {
					break;
				}
				_tmp24_ = x;
				x = _tmp24_ + 1;
			}
			while (TRUE) {
				guint8* _tmp25_;
				gint _tmp26_;
				guint8 _tmp27_;
				gint _tmp28_;
				_tmp25_ = y_changes;
				_tmp26_ = y;
				_tmp27_ = _tmp25_[_tmp26_];
				if (!(((gint) _tmp27_) != 0)) {
					break;
				}
				_tmp28_ = y;
				y = _tmp28_ + 1;
			}
			_tmp29_ = xx;
			_tmp30_ = yy;
			_tmp31_ = y;
			_tmp32_ = yy;
			_tmp33_ = x;
			_tmp34_ = xx;
			_tmp35_.x_offset = _tmp29_;
			_tmp35_.y_offset = _tmp30_;
			_tmp35_.inserted = _tmp31_ - _tmp32_;
			_tmp35_.deleted = _tmp33_ - _tmp34_;
			_tmp36_ = _unity_internal_utils_diff_change_dup0 (&_tmp35_);
			script = g_slist_prepend (script, _tmp36_);
		}
		_tmp37_ = x;
		x = _tmp37_ + 1;
		_tmp38_ = y;
		y = _tmp38_ + 1;
	}
	result = script;
	return result;
}


void
unity_internal_utils_diff_find_diag (gint x_offset,
                                     gint x_limit,
                                     gint y_offset,
                                     gint y_limit,
                                     UnityInternalUtilsDiffResultSetCompareFunc equal_func,
                                     gpointer equal_func_target,
                                     UnityInternalUtilsDiffContext* ctx,
                                     UnityInternalUtilsDiffPartition* partition)
{
	gint d_min = 0;
	gint d_max = 0;
	gint f_mid = 0;
	gint b_mid = 0;
	gint f_min = 0;
	gint _tmp0_;
	gint f_max = 0;
	gint _tmp1_;
	gint b_min = 0;
	gint _tmp2_;
	gint b_max = 0;
	gint _tmp3_;
	gint cost = 0;
	gboolean is_odd = FALSE;
	gint _tmp4_;
	gint _tmp5_;
	gint* f_diag = NULL;
	UnityInternalUtilsDiffContext _tmp6_;
	gint* _tmp7_;
	gint* b_diag = NULL;
	UnityInternalUtilsDiffContext _tmp8_;
	gint* _tmp9_;
	gint* _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	gint* _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	g_return_if_fail (ctx != NULL);
	g_return_if_fail (partition != NULL);
	d_min = x_offset - y_limit;
	d_max = x_limit - y_offset;
	f_mid = x_offset - y_offset;
	b_mid = x_limit - y_limit;
	_tmp0_ = f_mid;
	f_min = _tmp0_;
	_tmp1_ = f_mid;
	f_max = _tmp1_;
	_tmp2_ = b_mid;
	b_min = _tmp2_;
	_tmp3_ = b_mid;
	b_max = _tmp3_;
	_tmp4_ = f_mid;
	_tmp5_ = b_mid;
	is_odd = ((_tmp4_ - _tmp5_) & 1) != 0;
	_tmp6_ = *ctx;
	_tmp7_ = _tmp6_.f_diag;
	f_diag = _tmp7_;
	_tmp8_ = *ctx;
	_tmp9_ = _tmp8_.b_diag;
	b_diag = _tmp9_;
	_tmp10_ = f_diag;
	_tmp11_ = f_mid;
	_tmp10_[_tmp11_] = x_offset;
	_tmp12_ = _tmp10_[_tmp11_];
	_tmp13_ = b_diag;
	_tmp14_ = b_mid;
	_tmp13_[_tmp14_] = x_limit;
	_tmp15_ = _tmp13_[_tmp14_];
	{
		gboolean _tmp16_ = FALSE;
		cost = 1;
		_tmp16_ = TRUE;
		while (TRUE) {
			gint d = 0;
			gint _tmp18_;
			gint _tmp19_;
			gint _tmp25_;
			gint _tmp26_;
			gint _tmp79_;
			gint _tmp80_;
			gint _tmp86_;
			gint _tmp87_;
			gint _tmp140_;
			UnityInternalUtilsDiffContext _tmp141_;
			gint _tmp142_;
			if (!_tmp16_) {
				gint _tmp17_;
				_tmp17_ = cost;
				cost = _tmp17_ + 1;
			}
			_tmp16_ = FALSE;
			_tmp18_ = f_min;
			_tmp19_ = d_min;
			if (_tmp18_ > _tmp19_) {
				gint* _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				gint _tmp23_;
				_tmp20_ = f_diag;
				_tmp21_ = f_min;
				f_min = _tmp21_ - 1;
				_tmp22_ = f_min;
				_tmp20_[_tmp22_ - 1] = -1;
				_tmp23_ = _tmp20_[_tmp22_ - 1];
			} else {
				gint _tmp24_;
				_tmp24_ = f_min;
				f_min = _tmp24_ + 1;
			}
			_tmp25_ = f_max;
			_tmp26_ = d_max;
			if (_tmp25_ < _tmp26_) {
				gint* _tmp27_;
				gint _tmp28_;
				gint _tmp29_;
				gint _tmp30_;
				_tmp27_ = f_diag;
				_tmp28_ = f_max;
				f_max = _tmp28_ + 1;
				_tmp29_ = f_max;
				_tmp27_[_tmp29_ + 1] = -1;
				_tmp30_ = _tmp27_[_tmp29_ + 1];
			} else {
				gint _tmp31_;
				_tmp31_ = f_max;
				f_max = _tmp31_ - 1;
			}
			{
				gint _tmp32_;
				gboolean _tmp33_ = FALSE;
				_tmp32_ = f_max;
				d = _tmp32_;
				_tmp33_ = TRUE;
				while (TRUE) {
					gint _tmp35_;
					gint _tmp36_;
					gint x = 0;
					gint y = 0;
					gint t_lo = 0;
					gint* _tmp37_;
					gint _tmp38_;
					gint _tmp39_;
					gint t_hi = 0;
					gint* _tmp40_;
					gint _tmp41_;
					gint _tmp42_;
					gint _tmp43_ = 0;
					gint _tmp44_;
					gint _tmp45_;
					gint x0 = 0;
					gint* _tmp60_;
					gint _tmp61_;
					gint _tmp62_;
					gint _tmp63_;
					gboolean _tmp64_ = FALSE;
					gboolean _tmp65_ = FALSE;
					gboolean _tmp66_ = FALSE;
					gboolean _tmp67_;
					if (!_tmp33_) {
						gint _tmp34_;
						_tmp34_ = d;
						d = _tmp34_ - 2;
					}
					_tmp33_ = FALSE;
					_tmp35_ = d;
					_tmp36_ = f_min;
					if (!(_tmp35_ >= _tmp36_)) {
						break;
					}
					_tmp37_ = f_diag;
					_tmp38_ = d;
					_tmp39_ = _tmp37_[_tmp38_ - 1];
					t_lo = _tmp39_;
					_tmp40_ = f_diag;
					_tmp41_ = d;
					_tmp42_ = _tmp40_[_tmp41_ + 1];
					t_hi = _tmp42_;
					_tmp44_ = t_lo;
					_tmp45_ = t_hi;
					if (_tmp44_ < _tmp45_) {
						gint _tmp46_;
						_tmp46_ = t_hi;
						_tmp43_ = _tmp46_;
					} else {
						gint _tmp47_;
						_tmp47_ = t_lo;
						_tmp43_ = _tmp47_ + 1;
					}
					x0 = _tmp43_;
					{
						gint _tmp48_;
						gint _tmp49_;
						gint _tmp50_;
						gboolean _tmp51_ = FALSE;
						_tmp48_ = x0;
						x = _tmp48_;
						_tmp49_ = x0;
						_tmp50_ = d;
						y = _tmp49_ - _tmp50_;
						_tmp51_ = TRUE;
						while (TRUE) {
							gboolean _tmp54_ = FALSE;
							gboolean _tmp55_ = FALSE;
							gint _tmp56_;
							if (!_tmp51_) {
								gint _tmp52_;
								gint _tmp53_;
								_tmp52_ = x;
								x = _tmp52_ + 1;
								_tmp53_ = y;
								y = _tmp53_ + 1;
							}
							_tmp51_ = FALSE;
							_tmp56_ = x;
							if (_tmp56_ < x_limit) {
								gint _tmp57_;
								_tmp57_ = y;
								_tmp55_ = _tmp57_ < y_limit;
							} else {
								_tmp55_ = FALSE;
							}
							if (_tmp55_) {
								gint _tmp58_;
								gint _tmp59_;
								_tmp58_ = x;
								_tmp59_ = y;
								_tmp54_ = equal_func (_tmp58_, _tmp59_, equal_func_target);
							} else {
								_tmp54_ = FALSE;
							}
							if (!_tmp54_) {
								break;
							}
							continue;
						}
					}
					_tmp60_ = f_diag;
					_tmp61_ = d;
					_tmp62_ = x;
					_tmp60_[_tmp61_] = _tmp62_;
					_tmp63_ = _tmp60_[_tmp61_];
					_tmp67_ = is_odd;
					if (_tmp67_) {
						gint _tmp68_;
						gint _tmp69_;
						_tmp68_ = b_min;
						_tmp69_ = d;
						_tmp66_ = _tmp68_ <= _tmp69_;
					} else {
						_tmp66_ = FALSE;
					}
					if (_tmp66_) {
						gint _tmp70_;
						gint _tmp71_;
						_tmp70_ = d;
						_tmp71_ = b_max;
						_tmp65_ = _tmp70_ <= _tmp71_;
					} else {
						_tmp65_ = FALSE;
					}
					if (_tmp65_) {
						gint* _tmp72_;
						gint _tmp73_;
						gint _tmp74_;
						gint _tmp75_;
						_tmp72_ = b_diag;
						_tmp73_ = d;
						_tmp74_ = _tmp72_[_tmp73_];
						_tmp75_ = x;
						_tmp64_ = _tmp74_ <= _tmp75_;
					} else {
						_tmp64_ = FALSE;
					}
					if (_tmp64_) {
						gint _tmp76_;
						gint _tmp77_;
						gboolean _tmp78_;
						_tmp76_ = x;
						(*partition).x_mid = _tmp76_;
						_tmp77_ = y;
						(*partition).y_mid = _tmp77_;
						(*partition).hi_minimal = TRUE;
						_tmp78_ = (*partition).hi_minimal;
						(*partition).lo_minimal = _tmp78_;
						return;
					}
				}
			}
			_tmp79_ = b_min;
			_tmp80_ = d_min;
			if (_tmp79_ > _tmp80_) {
				gint* _tmp81_;
				gint _tmp82_;
				gint _tmp83_;
				gint _tmp84_;
				_tmp81_ = b_diag;
				_tmp82_ = b_min;
				b_min = _tmp82_ - 1;
				_tmp83_ = b_min;
				_tmp81_[_tmp83_ - 1] = G_MAXINT;
				_tmp84_ = _tmp81_[_tmp83_ - 1];
			} else {
				gint _tmp85_;
				_tmp85_ = b_min;
				b_min = _tmp85_ + 1;
			}
			_tmp86_ = b_max;
			_tmp87_ = d_max;
			if (_tmp86_ < _tmp87_) {
				gint* _tmp88_;
				gint _tmp89_;
				gint _tmp90_;
				gint _tmp91_;
				_tmp88_ = b_diag;
				_tmp89_ = b_max;
				b_max = _tmp89_ + 1;
				_tmp90_ = b_max;
				_tmp88_[_tmp90_ + 1] = G_MAXINT;
				_tmp91_ = _tmp88_[_tmp90_ + 1];
			} else {
				gint _tmp92_;
				_tmp92_ = b_max;
				b_max = _tmp92_ - 1;
			}
			{
				gint _tmp93_;
				gboolean _tmp94_ = FALSE;
				_tmp93_ = b_max;
				d = _tmp93_;
				_tmp94_ = TRUE;
				while (TRUE) {
					gint _tmp96_;
					gint _tmp97_;
					gint x = 0;
					gint y = 0;
					gint t_lo = 0;
					gint* _tmp98_;
					gint _tmp99_;
					gint _tmp100_;
					gint t_hi = 0;
					gint* _tmp101_;
					gint _tmp102_;
					gint _tmp103_;
					gint _tmp104_ = 0;
					gint _tmp105_;
					gint _tmp106_;
					gint x0 = 0;
					gint* _tmp121_;
					gint _tmp122_;
					gint _tmp123_;
					gint _tmp124_;
					gboolean _tmp125_ = FALSE;
					gboolean _tmp126_ = FALSE;
					gboolean _tmp127_ = FALSE;
					gboolean _tmp128_;
					if (!_tmp94_) {
						gint _tmp95_;
						_tmp95_ = d;
						d = _tmp95_ - 2;
					}
					_tmp94_ = FALSE;
					_tmp96_ = d;
					_tmp97_ = b_min;
					if (!(_tmp96_ >= _tmp97_)) {
						break;
					}
					_tmp98_ = b_diag;
					_tmp99_ = d;
					_tmp100_ = _tmp98_[_tmp99_ - 1];
					t_lo = _tmp100_;
					_tmp101_ = b_diag;
					_tmp102_ = d;
					_tmp103_ = _tmp101_[_tmp102_ + 1];
					t_hi = _tmp103_;
					_tmp105_ = t_lo;
					_tmp106_ = t_hi;
					if (_tmp105_ < _tmp106_) {
						gint _tmp107_;
						_tmp107_ = t_lo;
						_tmp104_ = _tmp107_;
					} else {
						gint _tmp108_;
						_tmp108_ = t_hi;
						_tmp104_ = _tmp108_ - 1;
					}
					x0 = _tmp104_;
					{
						gint _tmp109_;
						gint _tmp110_;
						gint _tmp111_;
						gboolean _tmp112_ = FALSE;
						_tmp109_ = x0;
						x = _tmp109_;
						_tmp110_ = x0;
						_tmp111_ = d;
						y = _tmp110_ - _tmp111_;
						_tmp112_ = TRUE;
						while (TRUE) {
							gboolean _tmp115_ = FALSE;
							gboolean _tmp116_ = FALSE;
							gint _tmp117_;
							if (!_tmp112_) {
								gint _tmp113_;
								gint _tmp114_;
								_tmp113_ = x;
								x = _tmp113_ - 1;
								_tmp114_ = y;
								y = _tmp114_ - 1;
							}
							_tmp112_ = FALSE;
							_tmp117_ = x;
							if (x_offset < _tmp117_) {
								gint _tmp118_;
								_tmp118_ = y;
								_tmp116_ = y_offset < _tmp118_;
							} else {
								_tmp116_ = FALSE;
							}
							if (_tmp116_) {
								gint _tmp119_;
								gint _tmp120_;
								_tmp119_ = x;
								_tmp120_ = y;
								_tmp115_ = equal_func (_tmp119_ - 1, _tmp120_ - 1, equal_func_target);
							} else {
								_tmp115_ = FALSE;
							}
							if (!_tmp115_) {
								break;
							}
							continue;
						}
					}
					_tmp121_ = b_diag;
					_tmp122_ = d;
					_tmp123_ = x;
					_tmp121_[_tmp122_] = _tmp123_;
					_tmp124_ = _tmp121_[_tmp122_];
					_tmp128_ = is_odd;
					if (!_tmp128_) {
						gint _tmp129_;
						gint _tmp130_;
						_tmp129_ = f_min;
						_tmp130_ = d;
						_tmp127_ = _tmp129_ <= _tmp130_;
					} else {
						_tmp127_ = FALSE;
					}
					if (_tmp127_) {
						gint _tmp131_;
						gint _tmp132_;
						_tmp131_ = d;
						_tmp132_ = f_max;
						_tmp126_ = _tmp131_ <= _tmp132_;
					} else {
						_tmp126_ = FALSE;
					}
					if (_tmp126_) {
						gint _tmp133_;
						gint* _tmp134_;
						gint _tmp135_;
						gint _tmp136_;
						_tmp133_ = x;
						_tmp134_ = f_diag;
						_tmp135_ = d;
						_tmp136_ = _tmp134_[_tmp135_];
						_tmp125_ = _tmp133_ <= _tmp136_;
					} else {
						_tmp125_ = FALSE;
					}
					if (_tmp125_) {
						gint _tmp137_;
						gint _tmp138_;
						gboolean _tmp139_;
						_tmp137_ = x;
						(*partition).x_mid = _tmp137_;
						_tmp138_ = y;
						(*partition).y_mid = _tmp138_;
						(*partition).hi_minimal = TRUE;
						_tmp139_ = (*partition).hi_minimal;
						(*partition).lo_minimal = _tmp139_;
						return;
					}
				}
			}
			_tmp140_ = cost;
			_tmp141_ = *ctx;
			_tmp142_ = _tmp141_.max_cost;
			if (_tmp140_ >= _tmp142_) {
				gint fxy_best = 0;
				gint bxy_best = 0;
				gint fx_best = 0;
				gint bx_best = 0;
				gint _tmp179_;
				gint _tmp180_;
				fx_best = 0;
				bx_best = 0;
				fxy_best = -1;
				{
					gint _tmp143_;
					gboolean _tmp144_ = FALSE;
					_tmp143_ = f_max;
					d = _tmp143_;
					_tmp144_ = TRUE;
					while (TRUE) {
						gint _tmp146_;
						gint _tmp147_;
						gint x = 0;
						gint* _tmp148_;
						gint _tmp149_;
						gint _tmp150_;
						gint y = 0;
						gint _tmp151_;
						gint _tmp152_;
						gint _tmp153_;
						gint _tmp155_;
						gint _tmp156_;
						gint _tmp157_;
						if (!_tmp144_) {
							gint _tmp145_;
							_tmp145_ = d;
							d = _tmp145_ - 2;
						}
						_tmp144_ = FALSE;
						_tmp146_ = d;
						_tmp147_ = f_min;
						if (!(_tmp146_ >= _tmp147_)) {
							break;
						}
						_tmp148_ = f_diag;
						_tmp149_ = d;
						_tmp150_ = _tmp148_[_tmp149_];
						x = MIN (_tmp150_, x_limit);
						_tmp151_ = x;
						_tmp152_ = d;
						y = _tmp151_ - _tmp152_;
						_tmp153_ = y;
						if (y_limit < _tmp153_) {
							gint _tmp154_;
							_tmp154_ = d;
							x = y_limit + _tmp154_;
							y = y_limit;
						}
						_tmp155_ = fxy_best;
						_tmp156_ = x;
						_tmp157_ = y;
						if (_tmp155_ < (_tmp156_ + _tmp157_)) {
							gint _tmp158_;
							gint _tmp159_;
							gint _tmp160_;
							_tmp158_ = x;
							_tmp159_ = y;
							fxy_best = _tmp158_ + _tmp159_;
							_tmp160_ = x;
							fx_best = _tmp160_;
						}
					}
				}
				bxy_best = G_MAXINT;
				{
					gint _tmp161_;
					gboolean _tmp162_ = FALSE;
					_tmp161_ = b_max;
					d = _tmp161_;
					_tmp162_ = TRUE;
					while (TRUE) {
						gint _tmp164_;
						gint _tmp165_;
						gint x = 0;
						gint* _tmp166_;
						gint _tmp167_;
						gint _tmp168_;
						gint y = 0;
						gint _tmp169_;
						gint _tmp170_;
						gint _tmp171_;
						gint _tmp173_;
						gint _tmp174_;
						gint _tmp175_;
						if (!_tmp162_) {
							gint _tmp163_;
							_tmp163_ = d;
							d = _tmp163_ - 2;
						}
						_tmp162_ = FALSE;
						_tmp164_ = d;
						_tmp165_ = b_min;
						if (!(_tmp164_ >= _tmp165_)) {
							break;
						}
						_tmp166_ = b_diag;
						_tmp167_ = d;
						_tmp168_ = _tmp166_[_tmp167_];
						x = MAX (x_offset, _tmp168_);
						_tmp169_ = x;
						_tmp170_ = d;
						y = _tmp169_ - _tmp170_;
						_tmp171_ = y;
						if (_tmp171_ < y_offset) {
							gint _tmp172_;
							_tmp172_ = d;
							x = y_offset + _tmp172_;
							y = y_offset;
						}
						_tmp173_ = x;
						_tmp174_ = y;
						_tmp175_ = bxy_best;
						if ((_tmp173_ + _tmp174_) < _tmp175_) {
							gint _tmp176_;
							gint _tmp177_;
							gint _tmp178_;
							_tmp176_ = x;
							_tmp177_ = y;
							bxy_best = _tmp176_ + _tmp177_;
							_tmp178_ = x;
							bx_best = _tmp178_;
						}
					}
				}
				_tmp179_ = bxy_best;
				_tmp180_ = fxy_best;
				if (((x_limit + y_limit) - _tmp179_) < (_tmp180_ - (x_offset + y_offset))) {
					gint _tmp181_;
					gint _tmp182_;
					gint _tmp183_;
					_tmp181_ = fx_best;
					(*partition).x_mid = _tmp181_;
					_tmp182_ = fxy_best;
					_tmp183_ = fx_best;
					(*partition).y_mid = _tmp182_ - _tmp183_;
					(*partition).lo_minimal = TRUE;
					(*partition).hi_minimal = FALSE;
				} else {
					gint _tmp184_;
					gint _tmp185_;
					gint _tmp186_;
					_tmp184_ = bx_best;
					(*partition).x_mid = _tmp184_;
					_tmp185_ = bxy_best;
					_tmp186_ = bx_best;
					(*partition).y_mid = _tmp185_ - _tmp186_;
					(*partition).lo_minimal = FALSE;
					(*partition).hi_minimal = TRUE;
				}
				return;
			}
		}
	}
}


gboolean
unity_internal_utils_diff_compare_sequences (gint x_offset,
                                             gint x_limit,
                                             gint y_offset,
                                             gint y_limit,
                                             gboolean find_minimal,
                                             UnityInternalUtilsDiffContext* ctx,
                                             UnityInternalUtilsDiffResultSetCompareFunc equal_func,
                                             gpointer equal_func_target)
{
	gboolean result = FALSE;
	g_return_val_if_fail (ctx != NULL, FALSE);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		gint _tmp2_;
		gint _tmp3_;
		if (x_offset < x_limit) {
			_tmp1_ = y_offset < y_limit;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			_tmp0_ = equal_func (x_offset, y_offset, equal_func_target);
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		_tmp2_ = x_offset;
		x_offset = _tmp2_ + 1;
		_tmp3_ = y_offset;
		y_offset = _tmp3_ + 1;
	}
	while (TRUE) {
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gint _tmp6_;
		gint _tmp7_;
		if (x_offset < x_limit) {
			_tmp5_ = y_offset < y_limit;
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			_tmp4_ = equal_func (x_limit - 1, y_limit - 1, equal_func_target);
		} else {
			_tmp4_ = FALSE;
		}
		if (!_tmp4_) {
			break;
		}
		_tmp6_ = x_limit;
		x_limit = _tmp6_ - 1;
		_tmp7_ = y_limit;
		y_limit = _tmp7_ - 1;
	}
	if (x_offset == x_limit) {
		while (TRUE) {
			UnityInternalUtilsDiffContext _tmp8_;
			guint8* _tmp9_;
			guint8 _tmp10_;
			gint _tmp11_;
			if (!(y_offset < y_limit)) {
				break;
			}
			_tmp8_ = *ctx;
			_tmp9_ = _tmp8_.y_changes;
			_tmp9_[y_offset] = (guint8) 1;
			_tmp10_ = _tmp9_[y_offset];
			_tmp11_ = y_offset;
			y_offset = _tmp11_ + 1;
		}
	} else {
		if (y_offset == y_limit) {
			while (TRUE) {
				UnityInternalUtilsDiffContext _tmp12_;
				guint8* _tmp13_;
				guint8 _tmp14_;
				gint _tmp15_;
				if (!(x_offset < x_limit)) {
					break;
				}
				_tmp12_ = *ctx;
				_tmp13_ = _tmp12_.x_changes;
				_tmp13_[x_offset] = (guint8) 1;
				_tmp14_ = _tmp13_[x_offset];
				_tmp15_ = x_offset;
				x_offset = _tmp15_ + 1;
			}
		} else {
			UnityInternalUtilsDiffPartition partition = {0};
			UnityInternalUtilsDiffPartition _tmp16_ = {0};
			UnityInternalUtilsDiffPartition _tmp17_;
			gint _tmp18_;
			UnityInternalUtilsDiffPartition _tmp19_;
			gint _tmp20_;
			UnityInternalUtilsDiffPartition _tmp21_;
			gboolean _tmp22_;
			gboolean _tmp23_;
			UnityInternalUtilsDiffPartition _tmp24_;
			gint _tmp25_;
			UnityInternalUtilsDiffPartition _tmp26_;
			gint _tmp27_;
			UnityInternalUtilsDiffPartition _tmp28_;
			gboolean _tmp29_;
			gboolean _tmp30_;
			_tmp16_.x_mid = 0;
			_tmp16_.y_mid = 0;
			_tmp16_.lo_minimal = FALSE;
			_tmp16_.hi_minimal = FALSE;
			partition = _tmp16_;
			unity_internal_utils_diff_find_diag (x_offset, x_limit, y_offset, y_limit, equal_func, equal_func_target, ctx, &partition);
			_tmp17_ = partition;
			_tmp18_ = _tmp17_.x_mid;
			_tmp19_ = partition;
			_tmp20_ = _tmp19_.y_mid;
			_tmp21_ = partition;
			_tmp22_ = _tmp21_.lo_minimal;
			_tmp23_ = unity_internal_utils_diff_compare_sequences (x_offset, _tmp18_, y_offset, _tmp20_, _tmp22_, ctx, equal_func, equal_func_target);
			if (_tmp23_) {
				result = TRUE;
				return result;
			}
			_tmp24_ = partition;
			_tmp25_ = _tmp24_.x_mid;
			_tmp26_ = partition;
			_tmp27_ = _tmp26_.y_mid;
			_tmp28_ = partition;
			_tmp29_ = _tmp28_.hi_minimal;
			_tmp30_ = unity_internal_utils_diff_compare_sequences (_tmp25_, x_limit, _tmp27_, y_limit, _tmp29_, ctx, equal_func, equal_func_target);
			if (_tmp30_) {
				result = TRUE;
				return result;
			}
		}
	}
	result = FALSE;
	return result;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



