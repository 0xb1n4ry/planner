/* unity-scope-loader.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-scope-loader.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * Copyright (C) 2013 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by James Henstridge <james.henstridge@canonical.com>
 *
 */


#include <glib.h>
#include <glib-object.h>
#include "unity.h"
#include <stdlib.h>
#include <string.h>
#include <gmodule.h>
#include <gio/gio.h>
#include <unity-protocol.h>

enum  {
	UNITY_SCOPE_LOADER_0_PROPERTY,
	UNITY_SCOPE_LOADER_NUM_PROPERTIES
};
static GParamSpec* unity_scope_loader_properties[UNITY_SCOPE_LOADER_NUM_PROPERTIES];
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_module_close0(var) ((var == NULL) ? NULL : (var = (g_module_close (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __vala_UnityProtocolScopeGroupScopeInfo_free0(var) ((var == NULL) ? NULL : (var = (_vala_UnityProtocolScopeGroupScopeInfo_free (var), NULL)))
#define _unity_protocol_scope_group_config_unref0(var) ((var == NULL) ? NULL : (var = (unity_protocol_scope_group_config_unref (var), NULL)))
#define _unity_protocol_scope_registry_scope_metadata_unref0(var) ((var == NULL) ? NULL : (var = (unity_protocol_scope_registry_scope_metadata_unref (var), NULL)))

typedef GList* (*UnityLoadScopesFunction) (GError** error);
typedef gint (*UnityGetVersionFunction) ();
struct _UnityScopeLoaderPrivate {
	GList* connectors;
	GHashTable* loaded_modules;
};


static gpointer unity_scope_loader_parent_class = NULL;

#define UNITY_SCOPE_LOADER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_SCOPE_LOADER, UnityScopeLoaderPrivate))
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static GList* unity_scope_loader_real_get_scopes (UnityScopeLoader* self,
                                           const gchar* module_name,
                                           const gchar* module_type,
                                           GError** error);
static void unity_scope_loader_real_export_scopes (UnityScopeLoader* self,
                                            GList* scopes,
                                            GError** error);
static void unity_scope_loader_load_and_export (UnityScopeLoader* self,
                                         const gchar* module,
                                         const gchar* module_type,
                                         GError** error);
static void _g_free0_ (gpointer var);
void unity_internal_update_process_timeout (gint new_timeout);
static UnityProtocolScopeGroupScopeInfo* _unity_protocol_scope_group_scope_info_dup (UnityProtocolScopeGroupScopeInfo* self);
static void _vala_UnityProtocolScopeGroupScopeInfo_free (UnityProtocolScopeGroupScopeInfo* self);
static void unity_scope_loader_finalize (GObject * obj);


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}


UnityScopeLoader*
unity_scope_loader_construct (GType object_type)
{
	UnityScopeLoader * self = NULL;
	self = (UnityScopeLoader*) g_object_new (object_type, NULL);
	return self;
}


UnityScopeLoader*
unity_scope_loader_new (void)
{
	return unity_scope_loader_construct (UNITY_TYPE_SCOPE_LOADER);
}


static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static GList*
unity_scope_loader_real_get_scopes (UnityScopeLoader* self,
                                    const gchar* module_name,
                                    const gchar* module_type,
                                    GError** error)
{
	GList* result = NULL;
	GModule* module = NULL;
	GModule* _tmp0_;
	GModule* _tmp1_;
	void* function = NULL;
	GModule* _tmp4_;
	void* _tmp5_ = NULL;
	gboolean _tmp6_;
	UnityGetVersionFunction get_version = NULL;
	void* _tmp12_;
	UnityGetVersionFunction _tmp13_;
	GModule* _tmp19_;
	void* _tmp20_ = NULL;
	gboolean _tmp21_;
	GModule* _tmp27_;
	UnityLoadScopesFunction load_scopes = NULL;
	void* _tmp28_;
	GList* _tmp29_ = NULL;
	UnityLoadScopesFunction _tmp30_;
	GList* _tmp31_;
	GList* _tmp32_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (module_name != NULL, NULL);
	_tmp0_ = g_module_open (module_name, G_MODULE_BIND_LAZY);
	module = _tmp0_;
	_tmp1_ = module;
	if (_tmp1_ == NULL) {
		const gchar* _tmp2_;
		GError* _tmp3_;
		_tmp2_ = g_module_error ();
		_tmp3_ = g_error_new (G_IO_ERROR, G_IO_ERROR_FAILED, "Could not load module '%s': %s", module_name, _tmp2_);
		_inner_error_ = _tmp3_;
		g_propagate_error (error, _inner_error_);
		_g_module_close0 (module);
		return NULL;
	}
	_tmp4_ = module;
	_tmp6_ = g_module_symbol (_tmp4_, "unity_scope_module_get_version", &_tmp5_);
	function = _tmp5_;
	if (!_tmp6_) {
		const gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		GError* _tmp10_;
		GError* _tmp11_;
		_tmp7_ = string_to_string (module_name);
		_tmp8_ = g_strconcat ("Could not find 'get_version' symbol in '", _tmp7_, "'", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, _tmp9_);
		_tmp11_ = _tmp10_;
		_g_free0 (_tmp9_);
		_inner_error_ = _tmp11_;
		g_propagate_error (error, _inner_error_);
		_g_module_close0 (module);
		return NULL;
	}
	_tmp12_ = function;
	get_version = (UnityGetVersionFunction) _tmp12_;
	_tmp13_ = get_version;
	if (_tmp13_ () != UNITY_SCOPE_API_VERSION) {
		const gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		GError* _tmp17_;
		GError* _tmp18_;
		_tmp14_ = string_to_string (module_name);
		_tmp15_ = g_strconcat ("Plugin '", _tmp14_, "' is for wrong Scope API version", NULL);
		_tmp16_ = _tmp15_;
		_tmp17_ = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, _tmp16_);
		_tmp18_ = _tmp17_;
		_g_free0 (_tmp16_);
		_inner_error_ = _tmp18_;
		g_propagate_error (error, _inner_error_);
		_g_module_close0 (module);
		return NULL;
	}
	_tmp19_ = module;
	_tmp21_ = g_module_symbol (_tmp19_, "unity_scope_module_load_scopes", &_tmp20_);
	function = _tmp20_;
	if (!_tmp21_) {
		const gchar* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_;
		GError* _tmp25_;
		GError* _tmp26_;
		_tmp22_ = string_to_string (module_name);
		_tmp23_ = g_strconcat ("Could not find 'load_scopes' symbol in '", _tmp22_, "'", NULL);
		_tmp24_ = _tmp23_;
		_tmp25_ = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, _tmp24_);
		_tmp26_ = _tmp25_;
		_g_free0 (_tmp24_);
		_inner_error_ = _tmp26_;
		g_propagate_error (error, _inner_error_);
		_g_module_close0 (module);
		return NULL;
	}
	_tmp27_ = module;
	g_module_make_resident (_tmp27_);
	_tmp28_ = function;
	load_scopes = (UnityLoadScopesFunction) _tmp28_;
	_tmp30_ = load_scopes;
	_tmp31_ = _tmp30_ (&_inner_error_);
	_tmp29_ = _tmp31_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_module_close0 (module);
		return NULL;
	}
	_tmp32_ = _tmp29_;
	_tmp29_ = NULL;
	result = _tmp32_;
	(_tmp29_ == NULL) ? NULL : (_tmp29_ = (_g_list_free__g_object_unref0_ (_tmp29_), NULL));
	_g_module_close0 (module);
	return result;
}


GList*
unity_scope_loader_get_scopes (UnityScopeLoader* self,
                               const gchar* module_name,
                               const gchar* module_type,
                               GError** error)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_SCOPE_LOADER_GET_CLASS (self)->get_scopes (self, module_name, module_type, error);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static void
unity_scope_loader_real_export_scopes (UnityScopeLoader* self,
                                       GList* scopes,
                                       GError** error)
{
	GError * _inner_error_ = NULL;
	{
		GList* scope_collection = NULL;
		GList* scope_it = NULL;
		scope_collection = scopes;
		for (scope_it = scope_collection; scope_it != NULL; scope_it = scope_it->next) {
			UnityAbstractScope* _tmp0_;
			UnityAbstractScope* scope = NULL;
			_tmp0_ = _g_object_ref0 ((UnityAbstractScope*) scope_it->data);
			scope = _tmp0_;
			{
				UnityScopeDBusConnector* connector = NULL;
				UnityAbstractScope* _tmp1_;
				UnityScopeDBusConnector* _tmp2_;
				UnityScopeDBusConnector* _tmp3_;
				UnityScopeDBusConnector* _tmp4_;
				UnityScopeDBusConnector* _tmp5_;
				_tmp1_ = scope;
				_tmp2_ = unity_scope_dbus_connector_new (_tmp1_);
				connector = _tmp2_;
				_tmp3_ = connector;
				unity_scope_dbus_connector_export (_tmp3_, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (connector);
					_g_object_unref0 (scope);
					return;
				}
				_tmp4_ = connector;
				_tmp5_ = _g_object_ref0 (_tmp4_);
				self->priv->connectors = g_list_prepend (self->priv->connectors, _tmp5_);
				_g_object_unref0 (connector);
				_g_object_unref0 (scope);
			}
		}
	}
}


void
unity_scope_loader_export_scopes (UnityScopeLoader* self,
                                  GList* scopes,
                                  GError** error)
{
	g_return_if_fail (self != NULL);
	UNITY_SCOPE_LOADER_GET_CLASS (self)->export_scopes (self, scopes, error);
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
unity_scope_loader_load_and_export (UnityScopeLoader* self,
                                    const gchar* module,
                                    const gchar* module_type,
                                    GError** error)
{
	GHashTable* _tmp0_;
	GHashTable* _tmp4_;
	GList* module_scopes = NULL;
	GList* _tmp5_;
	GList* _tmp6_;
	GHashTable* _tmp7_;
	gchar* _tmp8_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (module != NULL);
	_tmp0_ = self->priv->loaded_modules;
	if (_tmp0_ == NULL) {
		GHashFunc _tmp1_;
		GEqualFunc _tmp2_;
		GHashTable* _tmp3_;
		_tmp1_ = g_str_hash;
		_tmp2_ = g_str_equal;
		_tmp3_ = g_hash_table_new_full (_tmp1_, _tmp2_, _g_free0_, NULL);
		_g_hash_table_unref0 (self->priv->loaded_modules);
		self->priv->loaded_modules = _tmp3_;
	}
	_tmp4_ = self->priv->loaded_modules;
	if (g_hash_table_contains (_tmp4_, module)) {
		return;
	}
	_tmp5_ = unity_scope_loader_get_scopes (self, module, module_type, &_inner_error_);
	module_scopes = _tmp5_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	_tmp6_ = module_scopes;
	unity_scope_loader_export_scopes (self, _tmp6_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		(module_scopes == NULL) ? NULL : (module_scopes = (_g_list_free__g_object_unref0_ (module_scopes), NULL));
		return;
	}
	_tmp7_ = self->priv->loaded_modules;
	_tmp8_ = g_strdup (module);
	g_hash_table_insert (_tmp7_, _tmp8_, (gpointer) ((gintptr) 1));
	(module_scopes == NULL) ? NULL : (module_scopes = (_g_list_free__g_object_unref0_ (module_scopes), NULL));
}


static UnityProtocolScopeGroupScopeInfo*
_unity_protocol_scope_group_scope_info_dup (UnityProtocolScopeGroupScopeInfo* self)
{
	UnityProtocolScopeGroupScopeInfo* dup;
	dup = g_new0 (UnityProtocolScopeGroupScopeInfo, 1);
	unity_protocol_scope_group_scope_info_copy (self, dup);
	return dup;
}


static gpointer
__unity_protocol_scope_group_scope_info_dup0 (gpointer self)
{
	return self ? _unity_protocol_scope_group_scope_info_dup (self) : NULL;
}


static void
_vala_UnityProtocolScopeGroupScopeInfo_free (UnityProtocolScopeGroupScopeInfo* self)
{
	unity_protocol_scope_group_scope_info_destroy (self);
	g_free (self);
}


void
unity_scope_loader_load_group (UnityScopeLoader* self,
                               const gchar* group_name,
                               GError** error)
{
	UnityProtocolScopeGroupConfig* config = NULL;
	UnityProtocolScopeGroupConfig* _tmp0_;
	UnityProtocolScopeGroupConfig* _tmp1_;
	gint _tmp2_;
	UnityProtocolScopeGroupConfig* _tmp3_;
	GList* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (group_name != NULL);
	_tmp0_ = unity_protocol_scope_group_config_new (group_name, &_inner_error_);
	config = _tmp0_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	_tmp1_ = config;
	_tmp2_ = _tmp1_->timeout;
	unity_internal_update_process_timeout (_tmp2_);
	_tmp3_ = config;
	_tmp4_ = _tmp3_->scopes;
	{
		GList* info_collection = NULL;
		GList* info_it = NULL;
		info_collection = _tmp4_;
		for (info_it = info_collection; info_it != NULL; info_it = info_it->next) {
			UnityProtocolScopeGroupScopeInfo* _tmp5_;
			UnityProtocolScopeGroupScopeInfo* info = NULL;
			_tmp5_ = __unity_protocol_scope_group_scope_info_dup0 ((UnityProtocolScopeGroupScopeInfo*) info_it->data);
			info = _tmp5_;
			{
				UnityProtocolScopeGroupScopeInfo* _tmp6_;
				const gchar* _tmp7_;
				UnityProtocolScopeGroupScopeInfo* _tmp8_;
				const gchar* _tmp9_;
				_tmp6_ = info;
				_tmp7_ = (*_tmp6_).module;
				_tmp8_ = info;
				_tmp9_ = (*_tmp8_).module_type;
				unity_scope_loader_load_and_export (self, _tmp7_, _tmp9_, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_propagate_error (error, _inner_error_);
					__vala_UnityProtocolScopeGroupScopeInfo_free0 (info);
					_unity_protocol_scope_group_config_unref0 (config);
					return;
				}
				__vala_UnityProtocolScopeGroupScopeInfo_free0 (info);
			}
		}
	}
	_unity_protocol_scope_group_config_unref0 (config);
}


void
unity_scope_loader_load_scope (UnityScopeLoader* self,
                               const gchar* scope_id,
                               GError** error)
{
	UnityProtocolScopeRegistryScopeMetadata* metadata = NULL;
	UnityProtocolScopeRegistryScopeMetadata* _tmp0_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp1_;
	gint _tmp2_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp3_;
	const gchar* _tmp4_;
	UnityProtocolScopeRegistryScopeMetadata* _tmp5_;
	const gchar* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (scope_id != NULL);
	_tmp0_ = unity_protocol_scope_registry_scope_metadata_for_id (scope_id, &_inner_error_);
	metadata = _tmp0_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	_tmp1_ = metadata;
	_tmp2_ = _tmp1_->timeout;
	unity_internal_update_process_timeout (_tmp2_);
	_tmp3_ = metadata;
	_tmp4_ = _tmp3_->module;
	_tmp5_ = metadata;
	_tmp6_ = _tmp5_->module_type;
	unity_scope_loader_load_and_export (self, _tmp4_, _tmp6_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_unity_protocol_scope_registry_scope_metadata_unref0 (metadata);
		return;
	}
	_unity_protocol_scope_registry_scope_metadata_unref0 (metadata);
}


void
unity_scope_loader_load_module (UnityScopeLoader* self,
                                const gchar* module,
                                const gchar* module_type,
                                GError** error)
{
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (module != NULL);
	unity_scope_loader_load_and_export (self, module, module_type, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return;
	}
}


static void
unity_scope_loader_class_init (UnityScopeLoaderClass * klass)
{
	unity_scope_loader_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityScopeLoaderPrivate));
	((UnityScopeLoaderClass *) klass)->get_scopes = (GList* (*) (UnityScopeLoader *, const gchar*, const gchar*, GError**)) unity_scope_loader_real_get_scopes;
	((UnityScopeLoaderClass *) klass)->export_scopes = (void (*) (UnityScopeLoader *, GList*, GError**)) unity_scope_loader_real_export_scopes;
	G_OBJECT_CLASS (klass)->finalize = unity_scope_loader_finalize;
}


static void
unity_scope_loader_instance_init (UnityScopeLoader * self)
{
	self->priv = UNITY_SCOPE_LOADER_GET_PRIVATE (self);
}


static void
unity_scope_loader_finalize (GObject * obj)
{
	UnityScopeLoader * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_SCOPE_LOADER, UnityScopeLoader);
	(self->priv->connectors == NULL) ? NULL : (self->priv->connectors = (_g_list_free__g_object_unref0_ (self->priv->connectors), NULL));
	_g_hash_table_unref0 (self->priv->loaded_modules);
	G_OBJECT_CLASS (unity_scope_loader_parent_class)->finalize (obj);
}


GType
unity_scope_loader_get_type (void)
{
	static volatile gsize unity_scope_loader_type_id__volatile = 0;
	if (g_once_init_enter (&unity_scope_loader_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityScopeLoaderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_scope_loader_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityScopeLoader), 0, (GInstanceInitFunc) unity_scope_loader_instance_init, NULL };
		GType unity_scope_loader_type_id;
		unity_scope_loader_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityScopeLoader", &g_define_type_info, 0);
		g_once_init_leave (&unity_scope_loader_type_id__volatile, unity_scope_loader_type_id);
	}
	return unity_scope_loader_type_id__volatile;
}



