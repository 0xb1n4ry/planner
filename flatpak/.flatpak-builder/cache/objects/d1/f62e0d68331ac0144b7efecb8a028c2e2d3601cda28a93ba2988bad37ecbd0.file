/* unity-scope-interface.c generated by valac 0.40.11, the Vala compiler
 * generated from unity-scope-interface.vala, do not modify */

/*
 * Copyright (C) 2013 Canonical, Ltd.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 3.0 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3.0 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.hruby@canonical.com>
 *
 */


#include <glib.h>
#include <glib-object.h>
#include "unity.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <float.h>
#include <math.h>

enum  {
	UNITY_FILTER_SET_0_PROPERTY,
	UNITY_FILTER_SET_NUM_PROPERTIES
};
static GParamSpec* unity_filter_set_properties[UNITY_FILTER_SET_NUM_PROPERTIES];
enum  {
	UNITY_CATEGORY_SET_0_PROPERTY,
	UNITY_CATEGORY_SET_NUM_PROPERTIES
};
static GParamSpec* unity_category_set_properties[UNITY_CATEGORY_SET_NUM_PROPERTIES];
enum  {
	UNITY_SCHEMA_0_PROPERTY,
	UNITY_SCHEMA_NUM_PROPERTIES
};
static GParamSpec* unity_schema_properties[UNITY_SCHEMA_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _unity_scope_result_free0(var) ((var == NULL) ? NULL : (var = (unity_scope_result_free (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
enum  {
	UNITY_CANCELLABLE_0_PROPERTY,
	UNITY_CANCELLABLE_NUM_PROPERTIES
};
static GParamSpec* unity_cancellable_properties[UNITY_CANCELLABLE_NUM_PROPERTIES];

#define UNITY_INTERNAL_TYPE_GLIB_CANCELLABLE (unity_internal_glib_cancellable_get_type ())
#define UNITY_INTERNAL_GLIB_CANCELLABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UNITY_INTERNAL_TYPE_GLIB_CANCELLABLE, UnityInternalGLibCancellable))
#define UNITY_INTERNAL_GLIB_CANCELLABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UNITY_INTERNAL_TYPE_GLIB_CANCELLABLE, UnityInternalGLibCancellableClass))
#define UNITY_INTERNAL_IS_GLIB_CANCELLABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UNITY_INTERNAL_TYPE_GLIB_CANCELLABLE))
#define UNITY_INTERNAL_IS_GLIB_CANCELLABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UNITY_INTERNAL_TYPE_GLIB_CANCELLABLE))
#define UNITY_INTERNAL_GLIB_CANCELLABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UNITY_INTERNAL_TYPE_GLIB_CANCELLABLE, UnityInternalGLibCancellableClass))

typedef struct _UnityInternalGLibCancellable UnityInternalGLibCancellable;
typedef struct _UnityInternalGLibCancellableClass UnityInternalGLibCancellableClass;
enum  {
	UNITY_SCOPE_SEARCH_BASE_0_PROPERTY,
	UNITY_SCOPE_SEARCH_BASE_NUM_PROPERTIES
};
static GParamSpec* unity_scope_search_base_properties[UNITY_SCOPE_SEARCH_BASE_NUM_PROPERTIES];
#define _unity_search_context_free0(var) ((var == NULL) ? NULL : (var = (unity_search_context_free (var), NULL)))
typedef struct _Block8Data Block8Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
enum  {
	UNITY_RESULT_SET_0_PROPERTY,
	UNITY_RESULT_SET_NUM_PROPERTIES
};
static GParamSpec* unity_result_set_properties[UNITY_RESULT_SET_NUM_PROPERTIES];
enum  {
	UNITY_ABSTRACT_PREVIEW_0_PROPERTY,
	UNITY_ABSTRACT_PREVIEW_NUM_PROPERTIES
};
static GParamSpec* unity_abstract_preview_properties[UNITY_ABSTRACT_PREVIEW_NUM_PROPERTIES];
enum  {
	UNITY_RESULT_PREVIEWER_0_PROPERTY,
	UNITY_RESULT_PREVIEWER_NUM_PROPERTIES
};
static GParamSpec* unity_result_previewer_properties[UNITY_RESULT_PREVIEWER_NUM_PROPERTIES];
typedef struct _Block9Data Block9Data;
enum  {
	UNITY_SEARCH_METADATA_0_PROPERTY,
	UNITY_SEARCH_METADATA_LOCALE_PROPERTY,
	UNITY_SEARCH_METADATA_FORM_FACTOR_PROPERTY,
	UNITY_SEARCH_METADATA_LOCATION_PROPERTY,
	UNITY_SEARCH_METADATA_NUM_PROPERTIES
};
static GParamSpec* unity_search_metadata_properties[UNITY_SEARCH_METADATA_NUM_PROPERTIES];

#define UNITY_GEO_COORDINATE_TYPE_COORDINATE_TYPE (unity_geo_coordinate_coordinate_type_get_type ())
enum  {
	UNITY_GEO_COORDINATE_0_PROPERTY,
	UNITY_GEO_COORDINATE_NUM_PROPERTIES
};
static GParamSpec* unity_geo_coordinate_properties[UNITY_GEO_COORDINATE_NUM_PROPERTIES];
enum  {
	UNITY_ABSTRACT_SCOPE_0_PROPERTY,
	UNITY_ABSTRACT_SCOPE_NUM_PROPERTIES
};
static GParamSpec* unity_abstract_scope_properties[UNITY_ABSTRACT_SCOPE_NUM_PROPERTIES];
enum  {
	UNITY_ABSTRACT_SCOPE_RESULTS_INVALIDATED_INTERNAL_SIGNAL,
	UNITY_ABSTRACT_SCOPE_NUM_SIGNALS
};
static guint unity_abstract_scope_signals[UNITY_ABSTRACT_SCOPE_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _UnityFilterSetPrivate {
	GList* filters;
};

struct _UnityCategorySetPrivate {
	GList* categories;
};

struct _UnitySchemaPrivate {
	GList* fields;
};

struct _Block8Data {
	int _ref_count_;
	UnityScopeSearchBase* self;
	UnityScopeSearchBaseCallback async_callback;
	gpointer async_callback_target;
};

struct _Block9Data {
	int _ref_count_;
	UnityResultPreviewer* self;
	UnityAbstractPreviewCallback async_callback;
	gpointer async_callback_target;
};

struct _UnitySearchMetadataPrivate {
	GHashTable* all_metadata;
	UnityGeoCoordinate* geo_coordinate;
};

typedef enum  {
	UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_2D,
	UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_3D
} UnityGeoCoordinateCoordinateType;

struct _UnityGeoCoordinatePrivate {
	UnityGeoCoordinateCoordinateType coord_type;
};


static gpointer unity_filter_set_parent_class = NULL;
static gpointer unity_category_set_parent_class = NULL;
static gpointer unity_schema_parent_class = NULL;
static gpointer unity_cancellable_parent_class = NULL;
static gpointer unity_scope_search_base_parent_class = NULL;
static gpointer unity_result_set_parent_class = NULL;
static gpointer unity_abstract_preview_parent_class = NULL;
static gpointer unity_result_previewer_parent_class = NULL;
static gpointer unity_search_metadata_parent_class = NULL;
static gpointer unity_geo_coordinate_parent_class = NULL;
static gpointer unity_abstract_scope_parent_class = NULL;

#define UNITY_FILTER_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_FILTER_SET, UnityFilterSetPrivate))
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static void unity_filter_set_real_add (UnityFilterSet* self,
                                UnityFilter* filter);
static UnityFilter* unity_filter_set_real_get_filter_by_id (UnityFilterSet* self,
                                                     const gchar* filter_id);
static GList* unity_filter_set_real_get_filters (UnityFilterSet* self);
static GObject * unity_filter_set_constructor (GType type,
                                        guint n_construct_properties,
                                        GObjectConstructParam * construct_properties);
static void unity_filter_set_finalize (GObject * obj);
#define UNITY_CATEGORY_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_CATEGORY_SET, UnityCategorySetPrivate))
static void unity_category_set_real_add (UnityCategorySet* self,
                                  UnityCategory* category);
static GList* unity_category_set_real_get_categories (UnityCategorySet* self);
static GObject * unity_category_set_constructor (GType type,
                                          guint n_construct_properties,
                                          GObjectConstructParam * construct_properties);
static void unity_category_set_finalize (GObject * obj);
#define UNITY_SCHEMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_SCHEMA, UnitySchemaPrivate))
static void _unity_schema_field_info_free0_ (gpointer var);
static inline void _g_list_free__unity_schema_field_info_free0_ (GList* self);
static void unity_schema_real_add_field (UnitySchema* self,
                                  const gchar* name,
                                  const gchar* schema,
                                  UnitySchemaFieldType type);
static void unity_schema_field_info_init (UnitySchemaFieldInfo *self,
                                   const gchar* field_name,
                                   const gchar* field_schema,
                                   UnitySchemaFieldType field_type);
static GList* unity_schema_real_get_fields (UnitySchema* self);
static void unity_schema_finalize (GObject * obj);
static GHashTable* _variant_get29 (GVariant* value);
static void unity_cancellable_real_cancel (UnityCancellable* self);
static gboolean unity_cancellable_real_is_cancelled (UnityCancellable* self);
UnityInternalGLibCancellable* unity_internal_glib_cancellable_new (void);
UnityInternalGLibCancellable* unity_internal_glib_cancellable_construct (GType object_type);
GType unity_internal_glib_cancellable_get_type (void) G_GNUC_CONST;
static GCancellable* unity_cancellable_real_get_gcancellable (UnityCancellable* self);
static void unity_scope_search_base_real_run (UnityScopeSearchBase* self);
static void unity_scope_search_base_real_run_async (UnityScopeSearchBase* self,
                                             UnityScopeSearchBaseCallback async_callback,
                                             gpointer async_callback_target);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static void* __lambda8_ (Block8Data* _data8_);
static gpointer ___lambda8__gthread_func (gpointer self);
static void unity_scope_search_base_real_set_search_context (UnityScopeSearchBase* self,
                                                      UnitySearchContext* ctx);
static void unity_scope_search_base_finalize (GObject * obj);
static void unity_result_set_real_add_result (UnityResultSet* self,
                                       UnityScopeResult* _result_);
static void unity_result_set_real_add_result_from_variant (UnityResultSet* self,
                                                    GVariant* variant);
static GHashTable* _variant_get30 (GVariant* value);
static void unity_result_set_real_flush (UnityResultSet* self);
static void unity_result_set_finalize (GObject * obj);
static guint8* unity_abstract_preview_real_serialize_as (UnityAbstractPreview* self,
                                                  UnitySerializationType serialization_type,
                                                  int* result_length1);
static UnityAbstractPreview* unity_result_previewer_real_run (UnityResultPreviewer* self);
static void unity_result_previewer_real_run_async (UnityResultPreviewer* self,
                                            UnityAbstractPreviewCallback async_callback,
                                            gpointer async_callback_target);
static Block9Data* block9_data_ref (Block9Data* _data9_);
static void block9_data_unref (void * _userdata_);
static void* __lambda39_ (Block9Data* _data9_);
static gpointer ___lambda39__gthread_func (gpointer self);
static void unity_result_previewer_finalize (GObject * obj);
#define UNITY_SEARCH_METADATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_SEARCH_METADATA, UnitySearchMetadataPrivate))
static GHashTable* _variant_get31 (GVariant* value);
static GType unity_geo_coordinate_coordinate_type_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void unity_search_metadata_finalize (GObject * obj);
static void _vala_unity_search_metadata_get_property (GObject * object,
                                               guint property_id,
                                               GValue * value,
                                               GParamSpec * pspec);
#define UNITY_GEO_COORDINATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UNITY_TYPE_GEO_COORDINATE, UnityGeoCoordinatePrivate))
static void unity_geo_coordinate_finalize (GObject * obj);
static UnityScopeSearchBase* unity_abstract_scope_real_create_search_for_query (UnityAbstractScope* self,
                                                                         UnitySearchContext* search_context);
static UnityResultPreviewer* unity_abstract_scope_real_create_previewer (UnityAbstractScope* self,
                                                                  UnityScopeResult* _result_,
                                                                  UnitySearchMetadata* metadata);
static UnityCategorySet* unity_abstract_scope_real_get_categories (UnityAbstractScope* self);
static UnityFilterSet* unity_abstract_scope_real_get_filters (UnityAbstractScope* self);
static UnitySchema* unity_abstract_scope_real_get_schema (UnityAbstractScope* self);
static gchar* unity_abstract_scope_real_get_search_hint (UnityAbstractScope* self);
static gchar* unity_abstract_scope_real_get_group_name (UnityAbstractScope* self);
static gchar* unity_abstract_scope_real_get_unique_name (UnityAbstractScope* self);
static UnityActivationResponse* unity_abstract_scope_real_activate (UnityAbstractScope* self,
                                                             UnityScopeResult* _result_,
                                                             UnitySearchMetadata* metadata,
                                                             const gchar* action_id);
static gchar* unity_abstract_scope_real_normalize_search_query (UnityAbstractScope* self,
                                                         const gchar* search_query);


GType
unity_search_type_get_type (void)
{
	static volatile gsize unity_search_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_search_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_SEARCH_TYPE_DEFAULT, "UNITY_SEARCH_TYPE_DEFAULT", "default"}, {UNITY_SEARCH_TYPE_GLOBAL, "UNITY_SEARCH_TYPE_GLOBAL", "global"}, {UNITY_SEARCH_TYPE_N_TYPES, "UNITY_SEARCH_TYPE_N_TYPES", "n-types"}, {0, NULL, NULL}};
		GType unity_search_type_type_id;
		unity_search_type_type_id = g_enum_register_static ("UnitySearchType", values);
		g_once_init_leave (&unity_search_type_type_id__volatile, unity_search_type_type_id);
	}
	return unity_search_type_type_id__volatile;
}


GType
unity_result_type_get_type (void)
{
	static volatile gsize unity_result_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_result_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_RESULT_TYPE_DEFAULT, "UNITY_RESULT_TYPE_DEFAULT", "default"}, {UNITY_RESULT_TYPE_PERSONAL, "UNITY_RESULT_TYPE_PERSONAL", "personal"}, {UNITY_RESULT_TYPE_SEMI_PERSONAL, "UNITY_RESULT_TYPE_SEMI_PERSONAL", "semi-personal"}, {0, NULL, NULL}};
		GType unity_result_type_type_id;
		unity_result_type_type_id = g_enum_register_static ("UnityResultType", values);
		g_once_init_leave (&unity_result_type_type_id__volatile, unity_result_type_type_id);
	}
	return unity_result_type_type_id__volatile;
}


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static void
unity_filter_set_real_add (UnityFilterSet* self,
                           UnityFilter* filter)
{
	UnityFilter* _tmp0_;
	g_return_if_fail (filter != NULL);
	_tmp0_ = _g_object_ref0 (filter);
	self->priv->filters = g_list_append (self->priv->filters, _tmp0_);
}


void
unity_filter_set_add (UnityFilterSet* self,
                      UnityFilter* filter)
{
	g_return_if_fail (self != NULL);
	UNITY_FILTER_SET_GET_CLASS (self)->add (self, filter);
}


static UnityFilter*
unity_filter_set_real_get_filter_by_id (UnityFilterSet* self,
                                        const gchar* filter_id)
{
	UnityFilter* result = NULL;
	GList* _tmp0_;
	g_return_val_if_fail (filter_id != NULL, NULL);
	_tmp0_ = self->priv->filters;
	{
		GList* filter_collection = NULL;
		GList* filter_it = NULL;
		filter_collection = _tmp0_;
		for (filter_it = filter_collection; filter_it != NULL; filter_it = filter_it->next) {
			UnityFilter* filter = NULL;
			filter = (UnityFilter*) filter_it->data;
			{
				UnityFilter* _tmp1_;
				const gchar* _tmp2_;
				const gchar* _tmp3_;
				_tmp1_ = filter;
				_tmp2_ = unity_filter_get_id (_tmp1_);
				_tmp3_ = _tmp2_;
				if (g_strcmp0 (_tmp3_, filter_id) == 0) {
					UnityFilter* _tmp4_;
					_tmp4_ = filter;
					result = _tmp4_;
					return result;
				}
			}
		}
	}
	result = NULL;
	return result;
}


UnityFilter*
unity_filter_set_get_filter_by_id (UnityFilterSet* self,
                                   const gchar* filter_id)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_FILTER_SET_GET_CLASS (self)->get_filter_by_id (self, filter_id);
}


static GList*
unity_filter_set_real_get_filters (UnityFilterSet* self)
{
	GList* result = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	_tmp0_ = self->priv->filters;
	_tmp1_ = g_list_copy (_tmp0_);
	result = _tmp1_;
	return result;
}


GList*
unity_filter_set_get_filters (UnityFilterSet* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_FILTER_SET_GET_CLASS (self)->get_filters (self);
}


UnityFilterSet*
unity_filter_set_construct (GType object_type)
{
	UnityFilterSet * self = NULL;
	self = (UnityFilterSet*) g_object_new (object_type, NULL);
	return self;
}


UnityFilterSet*
unity_filter_set_new (void)
{
	return unity_filter_set_construct (UNITY_TYPE_FILTER_SET);
}


static GObject *
unity_filter_set_constructor (GType type,
                              guint n_construct_properties,
                              GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	UnityFilterSet * self;
	parent_class = G_OBJECT_CLASS (unity_filter_set_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_FILTER_SET, UnityFilterSet);
	(self->priv->filters == NULL) ? NULL : (self->priv->filters = (_g_list_free__g_object_unref0_ (self->priv->filters), NULL));
	self->priv->filters = NULL;
	return obj;
}


static void
unity_filter_set_class_init (UnityFilterSetClass * klass)
{
	unity_filter_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityFilterSetPrivate));
	((UnityFilterSetClass *) klass)->add = (void (*) (UnityFilterSet *, UnityFilter*)) unity_filter_set_real_add;
	((UnityFilterSetClass *) klass)->get_filter_by_id = (UnityFilter* (*) (UnityFilterSet *, const gchar*)) unity_filter_set_real_get_filter_by_id;
	((UnityFilterSetClass *) klass)->get_filters = (GList* (*) (UnityFilterSet *)) unity_filter_set_real_get_filters;
	G_OBJECT_CLASS (klass)->constructor = unity_filter_set_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_filter_set_finalize;
}


static void
unity_filter_set_instance_init (UnityFilterSet * self)
{
	self->priv = UNITY_FILTER_SET_GET_PRIVATE (self);
}


static void
unity_filter_set_finalize (GObject * obj)
{
	UnityFilterSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_FILTER_SET, UnityFilterSet);
	(self->priv->filters == NULL) ? NULL : (self->priv->filters = (_g_list_free__g_object_unref0_ (self->priv->filters), NULL));
	G_OBJECT_CLASS (unity_filter_set_parent_class)->finalize (obj);
}


GType
unity_filter_set_get_type (void)
{
	static volatile gsize unity_filter_set_type_id__volatile = 0;
	if (g_once_init_enter (&unity_filter_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityFilterSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_filter_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityFilterSet), 0, (GInstanceInitFunc) unity_filter_set_instance_init, NULL };
		GType unity_filter_set_type_id;
		unity_filter_set_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityFilterSet", &g_define_type_info, 0);
		g_once_init_leave (&unity_filter_set_type_id__volatile, unity_filter_set_type_id);
	}
	return unity_filter_set_type_id__volatile;
}


static void
unity_category_set_real_add (UnityCategorySet* self,
                             UnityCategory* category)
{
	UnityCategory* _tmp0_;
	g_return_if_fail (category != NULL);
	_tmp0_ = _g_object_ref0 (category);
	self->priv->categories = g_list_append (self->priv->categories, _tmp0_);
}


void
unity_category_set_add (UnityCategorySet* self,
                        UnityCategory* category)
{
	g_return_if_fail (self != NULL);
	UNITY_CATEGORY_SET_GET_CLASS (self)->add (self, category);
}


static GList*
unity_category_set_real_get_categories (UnityCategorySet* self)
{
	GList* result = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	_tmp0_ = self->priv->categories;
	_tmp1_ = g_list_copy (_tmp0_);
	result = _tmp1_;
	return result;
}


GList*
unity_category_set_get_categories (UnityCategorySet* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_CATEGORY_SET_GET_CLASS (self)->get_categories (self);
}


UnityCategorySet*
unity_category_set_construct (GType object_type)
{
	UnityCategorySet * self = NULL;
	self = (UnityCategorySet*) g_object_new (object_type, NULL);
	return self;
}


UnityCategorySet*
unity_category_set_new (void)
{
	return unity_category_set_construct (UNITY_TYPE_CATEGORY_SET);
}


static GObject *
unity_category_set_constructor (GType type,
                                guint n_construct_properties,
                                GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	UnityCategorySet * self;
	parent_class = G_OBJECT_CLASS (unity_category_set_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_CATEGORY_SET, UnityCategorySet);
	(self->priv->categories == NULL) ? NULL : (self->priv->categories = (_g_list_free__g_object_unref0_ (self->priv->categories), NULL));
	self->priv->categories = NULL;
	return obj;
}


static void
unity_category_set_class_init (UnityCategorySetClass * klass)
{
	unity_category_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityCategorySetPrivate));
	((UnityCategorySetClass *) klass)->add = (void (*) (UnityCategorySet *, UnityCategory*)) unity_category_set_real_add;
	((UnityCategorySetClass *) klass)->get_categories = (GList* (*) (UnityCategorySet *)) unity_category_set_real_get_categories;
	G_OBJECT_CLASS (klass)->constructor = unity_category_set_constructor;
	G_OBJECT_CLASS (klass)->finalize = unity_category_set_finalize;
}


static void
unity_category_set_instance_init (UnityCategorySet * self)
{
	self->priv = UNITY_CATEGORY_SET_GET_PRIVATE (self);
}


static void
unity_category_set_finalize (GObject * obj)
{
	UnityCategorySet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_CATEGORY_SET, UnityCategorySet);
	(self->priv->categories == NULL) ? NULL : (self->priv->categories = (_g_list_free__g_object_unref0_ (self->priv->categories), NULL));
	G_OBJECT_CLASS (unity_category_set_parent_class)->finalize (obj);
}


GType
unity_category_set_get_type (void)
{
	static volatile gsize unity_category_set_type_id__volatile = 0;
	if (g_once_init_enter (&unity_category_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityCategorySetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_category_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityCategorySet), 0, (GInstanceInitFunc) unity_category_set_instance_init, NULL };
		GType unity_category_set_type_id;
		unity_category_set_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityCategorySet", &g_define_type_info, 0);
		g_once_init_leave (&unity_category_set_type_id__volatile, unity_category_set_type_id);
	}
	return unity_category_set_type_id__volatile;
}


GType
unity_schema_field_type_get_type (void)
{
	static volatile gsize unity_schema_field_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_schema_field_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_SCHEMA_FIELD_TYPE_OPTIONAL, "UNITY_SCHEMA_FIELD_TYPE_OPTIONAL", "optional"}, {UNITY_SCHEMA_FIELD_TYPE_REQUIRED, "UNITY_SCHEMA_FIELD_TYPE_REQUIRED", "required"}, {0, NULL, NULL}};
		GType unity_schema_field_type_type_id;
		unity_schema_field_type_type_id = g_enum_register_static ("UnitySchemaFieldType", values);
		g_once_init_leave (&unity_schema_field_type_type_id__volatile, unity_schema_field_type_type_id);
	}
	return unity_schema_field_type_type_id__volatile;
}


static void
_unity_schema_field_info_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (unity_schema_field_info_free (var), NULL));
}


static inline void
_g_list_free__unity_schema_field_info_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _unity_schema_field_info_free0_);
}


static gpointer
_unity_schema_field_info_dup0 (gpointer self)
{
	return self ? unity_schema_field_info_dup (self) : NULL;
}


static void
unity_schema_real_add_field (UnitySchema* self,
                             const gchar* name,
                             const gchar* schema,
                             UnitySchemaFieldType type)
{
	GList* _tmp0_;
	UnitySchemaFieldInfo _tmp1_ = {0};
	UnitySchemaFieldInfo _tmp2_;
	UnitySchemaFieldInfo* _tmp3_;
	g_return_if_fail (name != NULL);
	g_return_if_fail (schema != NULL);
	_tmp0_ = self->priv->fields;
	if (_tmp0_ == NULL) {
		(self->priv->fields == NULL) ? NULL : (self->priv->fields = (_g_list_free__unity_schema_field_info_free0_ (self->priv->fields), NULL));
		self->priv->fields = NULL;
	}
	unity_schema_field_info_init (&_tmp1_, name, schema, type);
	_tmp2_ = _tmp1_;
	_tmp3_ = _unity_schema_field_info_dup0 (&_tmp2_);
	self->priv->fields = g_list_append (self->priv->fields, _tmp3_);
	unity_schema_field_info_destroy (&_tmp2_);
}


void
unity_schema_add_field (UnitySchema* self,
                        const gchar* name,
                        const gchar* schema,
                        UnitySchemaFieldType type)
{
	g_return_if_fail (self != NULL);
	UNITY_SCHEMA_GET_CLASS (self)->add_field (self, name, schema, type);
}


static GList*
unity_schema_real_get_fields (UnitySchema* self)
{
	GList* result = NULL;
	GList* _tmp0_;
	GList* _tmp1_;
	_tmp0_ = self->priv->fields;
	_tmp1_ = g_list_copy (_tmp0_);
	result = _tmp1_;
	return result;
}


GList*
unity_schema_get_fields (UnitySchema* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_SCHEMA_GET_CLASS (self)->get_fields (self);
}


UnitySchema*
unity_schema_construct (GType object_type)
{
	UnitySchema * self = NULL;
	self = (UnitySchema*) g_object_new (object_type, NULL);
	return self;
}


UnitySchema*
unity_schema_new (void)
{
	return unity_schema_construct (UNITY_TYPE_SCHEMA);
}


static void
unity_schema_field_info_init (UnitySchemaFieldInfo *self,
                              const gchar* field_name,
                              const gchar* field_schema,
                              UnitySchemaFieldType field_type)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (field_name != NULL);
	g_return_if_fail (field_schema != NULL);
	memset (self, 0, sizeof (UnitySchemaFieldInfo));
	_tmp0_ = g_strdup (field_name);
	_g_free0 ((*self).name);
	(*self).name = _tmp0_;
	_tmp1_ = g_strdup (field_schema);
	_g_free0 ((*self).schema);
	(*self).schema = _tmp1_;
	(*self).type = field_type;
}


void
unity_schema_field_info_copy (const UnitySchemaFieldInfo* self,
                              UnitySchemaFieldInfo* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	UnitySchemaFieldType _tmp4_;
	_tmp0_ = (*self).name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp1_;
	_tmp2_ = (*self).schema;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).schema);
	(*dest).schema = _tmp3_;
	_tmp4_ = (*self).type;
	(*dest).type = _tmp4_;
}


void
unity_schema_field_info_destroy (UnitySchemaFieldInfo* self)
{
	_g_free0 ((*self).name);
	_g_free0 ((*self).schema);
}


UnitySchemaFieldInfo*
unity_schema_field_info_dup (const UnitySchemaFieldInfo* self)
{
	UnitySchemaFieldInfo* dup;
	dup = g_new0 (UnitySchemaFieldInfo, 1);
	unity_schema_field_info_copy (self, dup);
	return dup;
}


void
unity_schema_field_info_free (UnitySchemaFieldInfo* self)
{
	unity_schema_field_info_destroy (self);
	g_free (self);
}


GType
unity_schema_field_info_get_type (void)
{
	static volatile gsize unity_schema_field_info_type_id__volatile = 0;
	if (g_once_init_enter (&unity_schema_field_info_type_id__volatile)) {
		GType unity_schema_field_info_type_id;
		unity_schema_field_info_type_id = g_boxed_type_register_static ("UnitySchemaFieldInfo", (GBoxedCopyFunc) unity_schema_field_info_dup, (GBoxedFreeFunc) unity_schema_field_info_free);
		g_once_init_leave (&unity_schema_field_info_type_id__volatile, unity_schema_field_info_type_id);
	}
	return unity_schema_field_info_type_id__volatile;
}


static void
unity_schema_class_init (UnitySchemaClass * klass)
{
	unity_schema_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnitySchemaPrivate));
	((UnitySchemaClass *) klass)->add_field = (void (*) (UnitySchema *, const gchar*, const gchar*, UnitySchemaFieldType)) unity_schema_real_add_field;
	((UnitySchemaClass *) klass)->get_fields = (GList* (*) (UnitySchema *)) unity_schema_real_get_fields;
	G_OBJECT_CLASS (klass)->finalize = unity_schema_finalize;
}


static void
unity_schema_instance_init (UnitySchema * self)
{
	self->priv = UNITY_SCHEMA_GET_PRIVATE (self);
}


static void
unity_schema_finalize (GObject * obj)
{
	UnitySchema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_SCHEMA, UnitySchema);
	(self->priv->fields == NULL) ? NULL : (self->priv->fields = (_g_list_free__unity_schema_field_info_free0_ (self->priv->fields), NULL));
	G_OBJECT_CLASS (unity_schema_parent_class)->finalize (obj);
}


GType
unity_schema_get_type (void)
{
	static volatile gsize unity_schema_type_id__volatile = 0;
	if (g_once_init_enter (&unity_schema_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnitySchemaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_schema_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnitySchema), 0, (GInstanceInitFunc) unity_schema_instance_init, NULL };
		GType unity_schema_type_id;
		unity_schema_type_id = g_type_register_static (G_TYPE_OBJECT, "UnitySchema", &g_define_type_info, 0);
		g_once_init_leave (&unity_schema_type_id__volatile, unity_schema_type_id);
	}
	return unity_schema_type_id__volatile;
}


/**
   * Create a new ScopeResult
   *
   * This method will create a new heap-allocated ScopeResult.
   * It is primarily meant for low-level language bindings, to ensure correct
   * memory management of the individual fields in the struct.
   */
static gpointer
_unity_scope_result_dup0 (gpointer self)
{
	return self ? unity_scope_result_dup (self) : NULL;
}


static gpointer
_g_hash_table_ref0 (gpointer self)
{
	return self ? g_hash_table_ref (self) : NULL;
}


UnityScopeResult*
unity_scope_result_create (const gchar* uri,
                           const gchar* icon_hint,
                           guint category,
                           UnityResultType result_type,
                           const gchar* mimetype,
                           const gchar* title,
                           const gchar* comment,
                           const gchar* dnd_uri,
                           GHashTable* metadata)
{
	UnityScopeResult* result = NULL;
	UnityScopeResult* _result_ = NULL;
	UnityScopeResult _tmp0_ = {0};
	UnityScopeResult _tmp1_;
	UnityScopeResult* _tmp2_;
	UnityScopeResult* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	GHashTable* _tmp10_;
	g_return_val_if_fail (uri != NULL, NULL);
	g_return_val_if_fail (mimetype != NULL, NULL);
	g_return_val_if_fail (title != NULL, NULL);
	g_return_val_if_fail (comment != NULL, NULL);
	g_return_val_if_fail (dnd_uri != NULL, NULL);
	g_return_val_if_fail (metadata != NULL, NULL);
	memset (&_tmp0_, 0, sizeof (UnityScopeResult));
	_tmp1_ = _tmp0_;
	_tmp2_ = _unity_scope_result_dup0 (&_tmp1_);
	_tmp3_ = _tmp2_;
	unity_scope_result_destroy (&_tmp1_);
	_result_ = _tmp3_;
	_tmp4_ = g_strdup (uri);
	_g_free0 ((*_result_).uri);
	(*_result_).uri = _tmp4_;
	_tmp5_ = g_strdup (icon_hint);
	_g_free0 ((*_result_).icon_hint);
	(*_result_).icon_hint = _tmp5_;
	(*_result_).category = category;
	(*_result_).result_type = result_type;
	_tmp6_ = g_strdup (mimetype);
	_g_free0 ((*_result_).mimetype);
	(*_result_).mimetype = _tmp6_;
	_tmp7_ = g_strdup (title);
	_g_free0 ((*_result_).title);
	(*_result_).title = _tmp7_;
	_tmp8_ = g_strdup (comment);
	_g_free0 ((*_result_).comment);
	(*_result_).comment = _tmp8_;
	_tmp9_ = g_strdup (dnd_uri);
	_g_free0 ((*_result_).dnd_uri);
	(*_result_).dnd_uri = _tmp9_;
	_tmp10_ = _g_hash_table_ref0 (metadata);
	_g_hash_table_unref0 ((*_result_).metadata);
	(*_result_).metadata = _tmp10_;
	result = _result_;
	return result;
}


/**
   * Create a new ScopeResult from a tuple variant
   *
   * This method will create a new heap-allocated ScopeResult.
   * It is primarily meant for low-level language bindings.
   */
static GHashTable*
_variant_get29 (GVariant* value)
{
	GHashTable* _tmp5_;
	GVariantIter _tmp6_;
	GVariant* _tmp7_;
	GVariant* _tmp8_;
	_tmp5_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
	g_variant_iter_init (&_tmp6_, value);
	while (g_variant_iter_loop (&_tmp6_, "{?*}", &_tmp7_, &_tmp8_)) {
		g_hash_table_insert (_tmp5_, g_variant_dup_string (_tmp7_, NULL), g_variant_get_variant (_tmp8_));
	}
	return _tmp5_;
}


UnityScopeResult*
unity_scope_result_create_from_variant (GVariant* variant)
{
	UnityScopeResult* result = NULL;
	static const char EXPECTED_SIG[] = "(ssuussssa{sv})";
	const gchar* _tmp0_;
	GVariant* dict = NULL;
	UnityScopeResult real_result = {0};
	UnityScopeResult _result_ = {0};
	UnityScopeResult _tmp2_;
	GHashTable* metadata = NULL;
	GVariant* _tmp3_;
	GHashTable* _tmp4_;
	GHashTable* _tmp9_;
	GHashTable* _tmp10_;
	UnityScopeResult _tmp11_;
	UnityScopeResult _tmp12_;
	UnityScopeResult* _tmp13_;
	g_return_val_if_fail (variant != NULL, NULL);
	_tmp0_ = g_variant_get_type_string (variant);
	if (g_strcmp0 (_tmp0_, EXPECTED_SIG) != 0) {
		const gchar* _tmp1_;
		_tmp1_ = g_variant_get_type_string (variant);
		g_warning ("unity-scope-interface.vala:169: Incorrect variant signature, expected " \
"\"%s\", got \"%s\"", EXPECTED_SIG, _tmp1_);
		result = NULL;
		return result;
	}
	memset (&real_result, 0, sizeof (UnityScopeResult));
	_tmp2_ = real_result;
	_result_ = _tmp2_;
	g_variant_get (variant, "(&s&suu&s&s&s&s@a{sv})", &_result_.uri, &_result_.icon_hint, &_result_.category, &_result_.result_type, &_result_.mimetype, &_result_.title, &_result_.comment, &_result_.dnd_uri, &dict, NULL);
	_tmp3_ = dict;
	_tmp4_ = _variant_get29 (_tmp3_);
	metadata = _tmp4_;
	_tmp9_ = metadata;
	_tmp10_ = _g_hash_table_ref0 (_tmp9_);
	_g_hash_table_unref0 (_result_.metadata);
	_result_.metadata = _tmp10_;
	_tmp11_ = _result_;
	_tmp12_ = _tmp11_;
	_tmp13_ = _unity_scope_result_dup0 (&_tmp12_);
	result = _tmp13_;
	_g_hash_table_unref0 (metadata);
	unity_scope_result_destroy (&real_result);
	_g_variant_unref0 (dict);
	return result;
}


void
unity_scope_result_copy (const UnityScopeResult* self,
                         UnityScopeResult* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	guint _tmp4_;
	UnityResultType _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	GHashTable* _tmp14_;
	GHashTable* _tmp15_;
	_tmp0_ = (*self).uri;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).uri);
	(*dest).uri = _tmp1_;
	_tmp2_ = (*self).icon_hint;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).icon_hint);
	(*dest).icon_hint = _tmp3_;
	_tmp4_ = (*self).category;
	(*dest).category = _tmp4_;
	_tmp5_ = (*self).result_type;
	(*dest).result_type = _tmp5_;
	_tmp6_ = (*self).mimetype;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 ((*dest).mimetype);
	(*dest).mimetype = _tmp7_;
	_tmp8_ = (*self).title;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 ((*dest).title);
	(*dest).title = _tmp9_;
	_tmp10_ = (*self).comment;
	_tmp11_ = g_strdup (_tmp10_);
	_g_free0 ((*dest).comment);
	(*dest).comment = _tmp11_;
	_tmp12_ = (*self).dnd_uri;
	_tmp13_ = g_strdup (_tmp12_);
	_g_free0 ((*dest).dnd_uri);
	(*dest).dnd_uri = _tmp13_;
	_tmp14_ = (*self).metadata;
	_tmp15_ = _g_hash_table_ref0 (_tmp14_);
	_g_hash_table_unref0 ((*dest).metadata);
	(*dest).metadata = _tmp15_;
}


void
unity_scope_result_destroy (UnityScopeResult* self)
{
	_g_free0 ((*self).uri);
	_g_free0 ((*self).icon_hint);
	_g_free0 ((*self).mimetype);
	_g_free0 ((*self).title);
	_g_free0 ((*self).comment);
	_g_free0 ((*self).dnd_uri);
	_g_hash_table_unref0 ((*self).metadata);
}


UnityScopeResult*
unity_scope_result_dup (const UnityScopeResult* self)
{
	UnityScopeResult* dup;
	dup = g_new0 (UnityScopeResult, 1);
	unity_scope_result_copy (self, dup);
	return dup;
}


void
unity_scope_result_free (UnityScopeResult* self)
{
	unity_scope_result_destroy (self);
	g_free (self);
}


GType
unity_scope_result_get_type (void)
{
	static volatile gsize unity_scope_result_type_id__volatile = 0;
	if (g_once_init_enter (&unity_scope_result_type_id__volatile)) {
		GType unity_scope_result_type_id;
		unity_scope_result_type_id = g_boxed_type_register_static ("UnityScopeResult", (GBoxedCopyFunc) unity_scope_result_dup, (GBoxedFreeFunc) unity_scope_result_free);
		g_once_init_leave (&unity_scope_result_type_id__volatile, unity_scope_result_type_id);
	}
	return unity_scope_result_type_id__volatile;
}


static void
unity_cancellable_real_cancel (UnityCancellable* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_cancellable_cancel'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void
unity_cancellable_cancel (UnityCancellable* self)
{
	g_return_if_fail (self != NULL);
	UNITY_CANCELLABLE_GET_CLASS (self)->cancel (self);
}


static gboolean
unity_cancellable_real_is_cancelled (UnityCancellable* self)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `unity_cancellable_is_cancelled'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}


gboolean
unity_cancellable_is_cancelled (UnityCancellable* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return UNITY_CANCELLABLE_GET_CLASS (self)->is_cancelled (self);
}


/**
   * Instantiate a default implementation of the Cancellable
   *
   * Create a new instance of Cancellable.
   */
UnityCancellable*
unity_cancellable_create (void)
{
	UnityCancellable* result = NULL;
	UnityInternalGLibCancellable* _tmp0_;
	_tmp0_ = unity_internal_glib_cancellable_new ();
	result = (UnityCancellable*) _tmp0_;
	return result;
}


/**
   * Return a GCancellable that can be used to monitor this cancellable.
   */
static GCancellable*
unity_cancellable_real_get_gcancellable (UnityCancellable* self)
{
	GCancellable* result = NULL;
	result = NULL;
	return result;
}


GCancellable*
unity_cancellable_get_gcancellable (UnityCancellable* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_CANCELLABLE_GET_CLASS (self)->get_gcancellable (self);
}


UnityCancellable*
unity_cancellable_construct (GType object_type)
{
	UnityCancellable * self = NULL;
	self = (UnityCancellable*) g_object_new (object_type, NULL);
	return self;
}


static void
unity_cancellable_class_init (UnityCancellableClass * klass)
{
	unity_cancellable_parent_class = g_type_class_peek_parent (klass);
	((UnityCancellableClass *) klass)->cancel = (void (*) (UnityCancellable *)) unity_cancellable_real_cancel;
	((UnityCancellableClass *) klass)->is_cancelled = (gboolean (*) (UnityCancellable *)) unity_cancellable_real_is_cancelled;
	((UnityCancellableClass *) klass)->get_gcancellable = (GCancellable* (*) (UnityCancellable *)) unity_cancellable_real_get_gcancellable;
}


static void
unity_cancellable_instance_init (UnityCancellable * self)
{
}


GType
unity_cancellable_get_type (void)
{
	static volatile gsize unity_cancellable_type_id__volatile = 0;
	if (g_once_init_enter (&unity_cancellable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityCancellableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_cancellable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityCancellable), 0, (GInstanceInitFunc) unity_cancellable_instance_init, NULL };
		GType unity_cancellable_type_id;
		unity_cancellable_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityCancellable", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_cancellable_type_id__volatile, unity_cancellable_type_id);
	}
	return unity_cancellable_type_id__volatile;
}


/**
   * Abstract method where the search is performed
   *
   * Scopes need to implement this method and add results to the ResultSet
   * which was passed to the {@link Unity.AbstractScope.create_search_for_query}.
   * By the time this method returns, the ResultSet is considered complete.
   */
static void
unity_scope_search_base_real_run (UnityScopeSearchBase* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_scope_search_base_run'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void
unity_scope_search_base_run (UnityScopeSearchBase* self)
{
	g_return_if_fail (self != NULL);
	UNITY_SCOPE_SEARCH_BASE_GET_CLASS (self)->run (self);
}


/**
   * Virtual method to perform the search asynchronously
   *
   * The default implementation of this method will spawn a new thread,
   * call the run() method (which is synchronous) inside the thread, and
   * invoke the callback when run() returns.
   * Implementations that perform searches asynchronously should override
   * this method as well as run() method.
   *
   * @param async_callback Callback to invoke when the search finishes
   */
static Block8Data*
block8_data_ref (Block8Data* _data8_)
{
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void
block8_data_unref (void * _userdata_)
{
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		UnityScopeSearchBase* self;
		self = _data8_->self;
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}


static void*
__lambda8_ (Block8Data* _data8_)
{
	UnityScopeSearchBase* self;
	void* result = NULL;
	self = _data8_->self;
	unity_scope_search_base_run (self);
	_data8_->async_callback (self, _data8_->async_callback_target);
	result = NULL;
	return result;
}


static gpointer
___lambda8__gthread_func (gpointer self)
{
	gpointer result;
	result = __lambda8_ (self);
	block8_data_unref (self);
	return result;
}


static void
unity_scope_search_base_real_run_async (UnityScopeSearchBase* self,
                                        UnityScopeSearchBaseCallback async_callback,
                                        gpointer async_callback_target)
{
	Block8Data* _data8_;
	GThread* _tmp0_;
	GThread* _tmp1_;
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_object_ref (self);
	_data8_->async_callback = async_callback;
	_data8_->async_callback_target = async_callback_target;
	_tmp0_ = g_thread_new ("search-thread", ___lambda8__gthread_func, block8_data_ref (_data8_));
	_tmp1_ = _tmp0_;
	_g_thread_unref0 (_tmp1_);
	block8_data_unref (_data8_);
	_data8_ = NULL;
}


void
unity_scope_search_base_run_async (UnityScopeSearchBase* self,
                                   UnityScopeSearchBaseCallback async_callback,
                                   gpointer async_callback_target)
{
	g_return_if_fail (self != NULL);
	UNITY_SCOPE_SEARCH_BASE_GET_CLASS (self)->run_async (self, async_callback, async_callback_target);
}


/**
   * Set associated SearchContext
   *
   * This method should be called inside 
   * Unity.AbstractScope.create_search_for_query() after instantiating your
   * ScopeSearchBase subclass. It will ensure that all search_context fields
   * are properly initialized.
   */
static gpointer
_unity_search_context_dup0 (gpointer self)
{
	return self ? unity_search_context_dup (self) : NULL;
}


static void
unity_scope_search_base_real_set_search_context (UnityScopeSearchBase* self,
                                                 UnitySearchContext* ctx)
{
	UnitySearchContext _tmp0_;
	UnitySearchContext _tmp1_;
	UnitySearchContext* _tmp2_;
	g_return_if_fail (ctx != NULL);
	_tmp0_ = *ctx;
	_tmp1_ = _tmp0_;
	_tmp2_ = _unity_search_context_dup0 (&_tmp1_);
	_unity_search_context_free0 (self->search_context);
	self->search_context = _tmp2_;
}


void
unity_scope_search_base_set_search_context (UnityScopeSearchBase* self,
                                            UnitySearchContext* ctx)
{
	g_return_if_fail (self != NULL);
	UNITY_SCOPE_SEARCH_BASE_GET_CLASS (self)->set_search_context (self, ctx);
}


UnityScopeSearchBase*
unity_scope_search_base_construct (GType object_type)
{
	UnityScopeSearchBase * self = NULL;
	self = (UnityScopeSearchBase*) g_object_new (object_type, NULL);
	return self;
}


static void
unity_scope_search_base_class_init (UnityScopeSearchBaseClass * klass)
{
	unity_scope_search_base_parent_class = g_type_class_peek_parent (klass);
	((UnityScopeSearchBaseClass *) klass)->run = (void (*) (UnityScopeSearchBase *)) unity_scope_search_base_real_run;
	((UnityScopeSearchBaseClass *) klass)->run_async = (void (*) (UnityScopeSearchBase *, UnityScopeSearchBaseCallback, gpointer)) unity_scope_search_base_real_run_async;
	((UnityScopeSearchBaseClass *) klass)->set_search_context = (void (*) (UnityScopeSearchBase *, UnitySearchContext*)) unity_scope_search_base_real_set_search_context;
	G_OBJECT_CLASS (klass)->finalize = unity_scope_search_base_finalize;
}


static void
unity_scope_search_base_instance_init (UnityScopeSearchBase * self)
{
}


static void
unity_scope_search_base_finalize (GObject * obj)
{
	UnityScopeSearchBase * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_SCOPE_SEARCH_BASE, UnityScopeSearchBase);
	_unity_search_context_free0 (self->search_context);
	G_OBJECT_CLASS (unity_scope_search_base_parent_class)->finalize (obj);
}


GType
unity_scope_search_base_get_type (void)
{
	static volatile gsize unity_scope_search_base_type_id__volatile = 0;
	if (g_once_init_enter (&unity_scope_search_base_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityScopeSearchBaseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_scope_search_base_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityScopeSearchBase), 0, (GInstanceInitFunc) unity_scope_search_base_instance_init, NULL };
		GType unity_scope_search_base_type_id;
		unity_scope_search_base_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityScopeSearchBase", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_scope_search_base_type_id__volatile, unity_scope_search_base_type_id);
	}
	return unity_scope_search_base_type_id__volatile;
}


GType
unity_serialization_type_get_type (void)
{
	static volatile gsize unity_serialization_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_serialization_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_SERIALIZATION_TYPE_BINARY, "UNITY_SERIALIZATION_TYPE_BINARY", "binary"}, {UNITY_SERIALIZATION_TYPE_JSON, "UNITY_SERIALIZATION_TYPE_JSON", "json"}, {0, NULL, NULL}};
		GType unity_serialization_type_type_id;
		unity_serialization_type_type_id = g_enum_register_static ("UnitySerializationType", values);
		g_once_init_leave (&unity_serialization_type_type_id__volatile, unity_serialization_type_type_id);
	}
	return unity_serialization_type_type_id__volatile;
}


static void
unity_result_set_real_add_result (UnityResultSet* self,
                                  UnityScopeResult* _result_)
{
	g_critical ("Type `%s' does not implement abstract method `unity_result_set_add_result'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void
unity_result_set_add_result (UnityResultSet* self,
                             UnityScopeResult* _result_)
{
	g_return_if_fail (self != NULL);
	UNITY_RESULT_SET_GET_CLASS (self)->add_result (self, _result_);
}


/**
   * Add a result from a tuple variant
   *
   * This method will add a new result to the result set from a variant.
   * The default implementation will transform the variant into a ScopeResult
   * and invoke the add_result() method.
   * The expected type of the variant is '(ssuussssa{sv})'.
   * It is primarily meant for low-level language bindings.
   */
static GHashTable*
_variant_get30 (GVariant* value)
{
	GHashTable* _tmp5_;
	GVariantIter _tmp6_;
	GVariant* _tmp7_;
	GVariant* _tmp8_;
	_tmp5_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
	g_variant_iter_init (&_tmp6_, value);
	while (g_variant_iter_loop (&_tmp6_, "{?*}", &_tmp7_, &_tmp8_)) {
		g_hash_table_insert (_tmp5_, g_variant_dup_string (_tmp7_, NULL), g_variant_get_variant (_tmp8_));
	}
	return _tmp5_;
}


static void
unity_result_set_real_add_result_from_variant (UnityResultSet* self,
                                               GVariant* variant)
{
	static const char EXPECTED_SIG[] = "(ssuussssa{sv})";
	const gchar* _tmp0_;
	GVariant* dict = NULL;
	UnityScopeResult real_result = {0};
	UnityScopeResult _result_ = {0};
	UnityScopeResult _tmp2_;
	GHashTable* metadata = NULL;
	GVariant* _tmp3_;
	GHashTable* _tmp4_;
	GHashTable* _tmp9_;
	GHashTable* _tmp10_;
	UnityScopeResult _tmp11_;
	g_return_if_fail (variant != NULL);
	_tmp0_ = g_variant_get_type_string (variant);
	if (g_strcmp0 (_tmp0_, EXPECTED_SIG) != 0) {
		const gchar* _tmp1_;
		_tmp1_ = g_variant_get_type_string (variant);
		g_warning ("unity-scope-interface.vala:288: Incorrect variant signature, expected " \
"\"%s\", got \"%s\"", EXPECTED_SIG, _tmp1_);
		return;
	}
	memset (&real_result, 0, sizeof (UnityScopeResult));
	_tmp2_ = real_result;
	_result_ = _tmp2_;
	g_variant_get (variant, "(&s&suu&s&s&s&s@a{sv})", &_result_.uri, &_result_.icon_hint, &_result_.category, &_result_.result_type, &_result_.mimetype, &_result_.title, &_result_.comment, &_result_.dnd_uri, &dict, NULL);
	_tmp3_ = dict;
	_tmp4_ = _variant_get30 (_tmp3_);
	metadata = _tmp4_;
	_tmp9_ = metadata;
	_tmp10_ = _g_hash_table_ref0 (_tmp9_);
	_g_hash_table_unref0 (_result_.metadata);
	_result_.metadata = _tmp10_;
	_tmp11_ = _result_;
	unity_result_set_add_result (self, &_tmp11_);
	_g_hash_table_unref0 (metadata);
	unity_scope_result_destroy (&real_result);
	_g_variant_unref0 (dict);
}


void
unity_result_set_add_result_from_variant (UnityResultSet* self,
                                          GVariant* variant)
{
	g_return_if_fail (self != NULL);
	UNITY_RESULT_SET_GET_CLASS (self)->add_result_from_variant (self, variant);
}


/**
   * Flush recently added results before continuing.
   *
   * Hint the transport to flush the ResultSet backend to ensure that results
   * are sent to the origin of the search. Note that this is just a hint
   * and it might be a noop or the request can be ignored
   * because of rate-limiting.
   */
static void
unity_result_set_real_flush (UnityResultSet* self)
{
}


void
unity_result_set_flush (UnityResultSet* self)
{
	g_return_if_fail (self != NULL);
	UNITY_RESULT_SET_GET_CLASS (self)->flush (self);
}


UnityResultSet*
unity_result_set_construct (GType object_type)
{
	UnityResultSet * self = NULL;
	self = (UnityResultSet*) g_object_new (object_type, NULL);
	return self;
}


static void
unity_result_set_class_init (UnityResultSetClass * klass)
{
	unity_result_set_parent_class = g_type_class_peek_parent (klass);
	((UnityResultSetClass *) klass)->add_result = (void (*) (UnityResultSet *, UnityScopeResult*)) unity_result_set_real_add_result;
	((UnityResultSetClass *) klass)->add_result_from_variant = (void (*) (UnityResultSet *, GVariant*)) unity_result_set_real_add_result_from_variant;
	((UnityResultSetClass *) klass)->flush = (void (*) (UnityResultSet *)) unity_result_set_real_flush;
	G_OBJECT_CLASS (klass)->finalize = unity_result_set_finalize;
}


static void
unity_result_set_instance_init (UnityResultSet * self)
{
}


static void
unity_result_set_finalize (GObject * obj)
{
	UnityResultSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_RESULT_SET, UnityResultSet);
	G_OBJECT_CLASS (unity_result_set_parent_class)->finalize (obj);
}


GType
unity_result_set_get_type (void)
{
	static volatile gsize unity_result_set_type_id__volatile = 0;
	if (g_once_init_enter (&unity_result_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityResultSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_result_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityResultSet), 0, (GInstanceInitFunc) unity_result_set_instance_init, NULL };
		GType unity_result_set_type_id;
		unity_result_set_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityResultSet", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_result_set_type_id__volatile, unity_result_set_type_id);
	}
	return unity_result_set_type_id__volatile;
}


static guint8*
unity_abstract_preview_real_serialize_as (UnityAbstractPreview* self,
                                          UnitySerializationType serialization_type,
                                          int* result_length1)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_preview_serialize_as'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


guint8*
unity_abstract_preview_serialize_as (UnityAbstractPreview* self,
                                     UnitySerializationType serialization_type,
                                     int* result_length1)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_PREVIEW_GET_CLASS (self)->serialize_as (self, serialization_type, result_length1);
}


UnityAbstractPreview*
unity_abstract_preview_construct (GType object_type)
{
	UnityAbstractPreview * self = NULL;
	self = (UnityAbstractPreview*) g_object_new (object_type, NULL);
	return self;
}


static void
unity_abstract_preview_class_init (UnityAbstractPreviewClass * klass)
{
	unity_abstract_preview_parent_class = g_type_class_peek_parent (klass);
	((UnityAbstractPreviewClass *) klass)->serialize_as = (guint8* (*) (UnityAbstractPreview *, UnitySerializationType, int*)) unity_abstract_preview_real_serialize_as;
}


static void
unity_abstract_preview_instance_init (UnityAbstractPreview * self)
{
}


GType
unity_abstract_preview_get_type (void)
{
	static volatile gsize unity_abstract_preview_type_id__volatile = 0;
	if (g_once_init_enter (&unity_abstract_preview_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityAbstractPreviewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_abstract_preview_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityAbstractPreview), 0, (GInstanceInitFunc) unity_abstract_preview_instance_init, NULL };
		GType unity_abstract_preview_type_id;
		unity_abstract_preview_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityAbstractPreview", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_abstract_preview_type_id__volatile, unity_abstract_preview_type_id);
	}
	return unity_abstract_preview_type_id__volatile;
}


static UnityAbstractPreview*
unity_result_previewer_real_run (UnityResultPreviewer* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_result_previewer_run'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


UnityAbstractPreview*
unity_result_previewer_run (UnityResultPreviewer* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_RESULT_PREVIEWER_GET_CLASS (self)->run (self);
}


static Block9Data*
block9_data_ref (Block9Data* _data9_)
{
	g_atomic_int_inc (&_data9_->_ref_count_);
	return _data9_;
}


static void
block9_data_unref (void * _userdata_)
{
	Block9Data* _data9_;
	_data9_ = (Block9Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data9_->_ref_count_)) {
		UnityResultPreviewer* self;
		self = _data9_->self;
		_g_object_unref0 (self);
		g_slice_free (Block9Data, _data9_);
	}
}


static void*
__lambda39_ (Block9Data* _data9_)
{
	UnityResultPreviewer* self;
	void* result = NULL;
	UnityAbstractPreview* preview = NULL;
	UnityAbstractPreview* _tmp0_;
	self = _data9_->self;
	_tmp0_ = unity_result_previewer_run (self);
	preview = _tmp0_;
	_data9_->async_callback (self, preview, _data9_->async_callback_target);
	result = NULL;
	_g_object_unref0 (preview);
	return result;
}


static gpointer
___lambda39__gthread_func (gpointer self)
{
	gpointer result;
	result = __lambda39_ (self);
	block9_data_unref (self);
	return result;
}


static void
unity_result_previewer_real_run_async (UnityResultPreviewer* self,
                                       UnityAbstractPreviewCallback async_callback,
                                       gpointer async_callback_target)
{
	Block9Data* _data9_;
	GThread* _tmp0_;
	GThread* _tmp1_;
	_data9_ = g_slice_new0 (Block9Data);
	_data9_->_ref_count_ = 1;
	_data9_->self = g_object_ref (self);
	_data9_->async_callback = async_callback;
	_data9_->async_callback_target = async_callback_target;
	_tmp0_ = g_thread_new ("preview-thread", ___lambda39__gthread_func, block9_data_ref (_data9_));
	_tmp1_ = _tmp0_;
	_g_thread_unref0 (_tmp1_);
	block9_data_unref (_data9_);
	_data9_ = NULL;
}


void
unity_result_previewer_run_async (UnityResultPreviewer* self,
                                  UnityAbstractPreviewCallback async_callback,
                                  gpointer async_callback_target)
{
	g_return_if_fail (self != NULL);
	UNITY_RESULT_PREVIEWER_GET_CLASS (self)->run_async (self, async_callback, async_callback_target);
}


void
unity_result_previewer_set_scope_result (UnityResultPreviewer* self,
                                         UnityScopeResult* scope_result)
{
	UnityScopeResult _tmp0_;
	UnityScopeResult _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (scope_result != NULL);
	_tmp0_ = *scope_result;
	unity_scope_result_copy (&_tmp0_, &_tmp1_);
	unity_scope_result_destroy (&self->result);
	self->result = _tmp1_;
}


void
unity_result_previewer_set_search_metadata (UnityResultPreviewer* self,
                                            UnitySearchMetadata* search_metadata)
{
	UnitySearchMetadata* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (search_metadata != NULL);
	_tmp0_ = _g_object_ref0 (search_metadata);
	_g_object_unref0 (self->metadata);
	self->metadata = _tmp0_;
}


UnityResultPreviewer*
unity_result_previewer_construct (GType object_type)
{
	UnityResultPreviewer * self = NULL;
	self = (UnityResultPreviewer*) g_object_new (object_type, NULL);
	return self;
}


static void
unity_result_previewer_class_init (UnityResultPreviewerClass * klass)
{
	unity_result_previewer_parent_class = g_type_class_peek_parent (klass);
	((UnityResultPreviewerClass *) klass)->run = (UnityAbstractPreview* (*) (UnityResultPreviewer *)) unity_result_previewer_real_run;
	((UnityResultPreviewerClass *) klass)->run_async = (void (*) (UnityResultPreviewer *, UnityAbstractPreviewCallback, gpointer)) unity_result_previewer_real_run_async;
	G_OBJECT_CLASS (klass)->finalize = unity_result_previewer_finalize;
}


static void
unity_result_previewer_instance_init (UnityResultPreviewer * self)
{
}


static void
unity_result_previewer_finalize (GObject * obj)
{
	UnityResultPreviewer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_RESULT_PREVIEWER, UnityResultPreviewer);
	unity_scope_result_destroy (&self->result);
	_g_object_unref0 (self->metadata);
	_g_object_unref0 (self->cancellable);
	G_OBJECT_CLASS (unity_result_previewer_parent_class)->finalize (obj);
}


GType
unity_result_previewer_get_type (void)
{
	static volatile gsize unity_result_previewer_type_id__volatile = 0;
	if (g_once_init_enter (&unity_result_previewer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityResultPreviewerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_result_previewer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityResultPreviewer), 0, (GInstanceInitFunc) unity_result_previewer_instance_init, NULL };
		GType unity_result_previewer_type_id;
		unity_result_previewer_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityResultPreviewer", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_result_previewer_type_id__volatile, unity_result_previewer_type_id);
	}
	return unity_result_previewer_type_id__volatile;
}


UnitySearchMetadata*
unity_search_metadata_create (GHashTable* metadata)
{
	UnitySearchMetadata* result = NULL;
	UnitySearchMetadata* m = NULL;
	UnitySearchMetadata* _tmp0_;
	GHashTable* _tmp1_;
	_tmp0_ = unity_search_metadata_new ();
	m = _tmp0_;
	_tmp1_ = _g_hash_table_ref0 (metadata);
	_g_hash_table_unref0 (m->priv->all_metadata);
	m->priv->all_metadata = _tmp1_;
	result = m;
	return result;
}


/**
   * Create a new SearchMetadata from a variant
   *
   * This method will create a new heap-allocated SearchMetadata.
   * The expected type for the variant is 'a{sv}'.
   * It is primarily meant for low-level language bindings.
   */
static GHashTable*
_variant_get31 (GVariant* value)
{
	GHashTable* _tmp8_;
	GVariantIter _tmp9_;
	GVariant* _tmp10_;
	GVariant* _tmp11_;
	_tmp8_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
	g_variant_iter_init (&_tmp9_, value);
	while (g_variant_iter_loop (&_tmp9_, "{?*}", &_tmp10_, &_tmp11_)) {
		g_hash_table_insert (_tmp8_, g_variant_dup_string (_tmp10_, NULL), g_variant_get_variant (_tmp11_));
	}
	return _tmp8_;
}


UnitySearchMetadata*
unity_search_metadata_create_from_variant (GVariant* metadata)
{
	UnitySearchMetadata* result = NULL;
	UnitySearchMetadata* m = NULL;
	UnitySearchMetadata* _tmp0_;
	const GVariantType* _tmp1_;
	UnitySearchMetadata* _tmp6_;
	GHashTable* _tmp7_;
	g_return_val_if_fail (metadata != NULL, NULL);
	_tmp0_ = unity_search_metadata_new ();
	m = _tmp0_;
	_tmp1_ = G_VARIANT_TYPE_VARDICT;
	if (!g_variant_is_of_type (metadata, _tmp1_)) {
		const GVariantType* _tmp2_;
		gchar* _tmp3_;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		_tmp2_ = G_VARIANT_TYPE_VARDICT;
		_tmp3_ = g_variant_type_dup_string (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_variant_get_type_string (metadata);
		g_warning ("Incorrect variant type for SearchMetadata.create_from_variant. " "Expected %s, but got %s", _tmp4_, _tmp5_);
		_g_free0 (_tmp4_);
		result = m;
		return result;
	}
	_tmp6_ = m;
	_tmp7_ = _variant_get31 (metadata);
	_g_hash_table_unref0 (_tmp6_->priv->all_metadata);
	_tmp6_->priv->all_metadata = _tmp7_;
	result = m;
	return result;
}


UnitySearchMetadata*
unity_search_metadata_construct (GType object_type)
{
	UnitySearchMetadata * self = NULL;
	self = (UnitySearchMetadata*) g_object_new (object_type, NULL);
	return self;
}


UnitySearchMetadata*
unity_search_metadata_new (void)
{
	return unity_search_metadata_construct (UNITY_TYPE_SEARCH_METADATA);
}


static gpointer
_g_variant_ref0 (gpointer self)
{
	return self ? g_variant_ref (self) : NULL;
}


const gchar*
unity_search_metadata_get_locale (UnitySearchMetadata* self)
{
	const gchar* result;
	GHashTable* _tmp0_;
	GVariant* locale_v = NULL;
	GHashTable* _tmp1_;
	gconstpointer _tmp2_;
	GVariant* _tmp3_;
	GVariant* _tmp4_;
	GVariant* _tmp5_;
	const gchar* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->all_metadata;
	if (_tmp0_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = self->priv->all_metadata;
	_tmp2_ = g_hash_table_lookup (_tmp1_, "locale");
	_tmp3_ = _g_variant_ref0 ((GVariant*) _tmp2_);
	locale_v = _tmp3_;
	_tmp4_ = locale_v;
	if (_tmp4_ == NULL) {
		result = NULL;
		_g_variant_unref0 (locale_v);
		return result;
	}
	_tmp5_ = locale_v;
	_tmp6_ = g_variant_get_string (_tmp5_, NULL);
	result = _tmp6_;
	_g_variant_unref0 (locale_v);
	return result;
}


const gchar*
unity_search_metadata_get_form_factor (UnitySearchMetadata* self)
{
	const gchar* result;
	GHashTable* _tmp0_;
	GVariant* form_factor_v = NULL;
	GHashTable* _tmp1_;
	gconstpointer _tmp2_;
	GVariant* _tmp3_;
	GVariant* _tmp4_;
	GVariant* _tmp5_;
	const gchar* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->all_metadata;
	if (_tmp0_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = self->priv->all_metadata;
	_tmp2_ = g_hash_table_lookup (_tmp1_, "form-factor");
	_tmp3_ = _g_variant_ref0 ((GVariant*) _tmp2_);
	form_factor_v = _tmp3_;
	_tmp4_ = form_factor_v;
	if (_tmp4_ == NULL) {
		result = NULL;
		_g_variant_unref0 (form_factor_v);
		return result;
	}
	_tmp5_ = form_factor_v;
	_tmp6_ = g_variant_get_string (_tmp5_, NULL);
	result = _tmp6_;
	_g_variant_unref0 (form_factor_v);
	return result;
}


UnityGeoCoordinate*
unity_search_metadata_get_location (UnitySearchMetadata* self)
{
	UnityGeoCoordinate* result;
	UnityGeoCoordinate* _tmp0_;
	static const char EXPECTED_TYPE[] = "(iddd)";
	GHashTable* _tmp2_;
	GVariant* location_v = NULL;
	GHashTable* _tmp3_;
	gconstpointer _tmp4_;
	GVariant* _tmp5_;
	gboolean _tmp6_ = FALSE;
	GVariant* _tmp7_;
	gdouble lat = 0.0;
	gdouble lon = 0.0;
	gdouble alt = 0.0;
	gint loc_type = 0;
	GVariant* _tmp10_;
	gint _tmp11_;
	UnityGeoCoordinate* _tmp19_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->geo_coordinate;
	if (_tmp0_ != NULL) {
		UnityGeoCoordinate* _tmp1_;
		_tmp1_ = self->priv->geo_coordinate;
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->priv->all_metadata;
	if (_tmp2_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp3_ = self->priv->all_metadata;
	_tmp4_ = g_hash_table_lookup (_tmp3_, "location");
	_tmp5_ = _g_variant_ref0 ((GVariant*) _tmp4_);
	location_v = _tmp5_;
	_tmp7_ = location_v;
	if (_tmp7_ == NULL) {
		_tmp6_ = TRUE;
	} else {
		GVariant* _tmp8_;
		const gchar* _tmp9_;
		_tmp8_ = location_v;
		_tmp9_ = g_variant_get_type_string (_tmp8_);
		_tmp6_ = g_strcmp0 (_tmp9_, EXPECTED_TYPE) != 0;
	}
	if (_tmp6_) {
		result = NULL;
		_g_variant_unref0 (location_v);
		return result;
	}
	_tmp10_ = location_v;
	g_variant_get (_tmp10_, EXPECTED_TYPE, &loc_type, &lat, &lon, &alt, NULL);
	_tmp11_ = loc_type;
	if (_tmp11_ == ((gint) UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_3D)) {
		gdouble _tmp12_;
		gdouble _tmp13_;
		gdouble _tmp14_;
		UnityGeoCoordinate* _tmp15_;
		_tmp12_ = lat;
		_tmp13_ = lon;
		_tmp14_ = alt;
		_tmp15_ = unity_geo_coordinate_new_with_altitude (_tmp12_, _tmp13_, _tmp14_);
		_g_object_unref0 (self->priv->geo_coordinate);
		self->priv->geo_coordinate = _tmp15_;
	} else {
		gdouble _tmp16_;
		gdouble _tmp17_;
		UnityGeoCoordinate* _tmp18_;
		_tmp16_ = lat;
		_tmp17_ = lon;
		_tmp18_ = unity_geo_coordinate_new (_tmp16_, _tmp17_);
		_g_object_unref0 (self->priv->geo_coordinate);
		self->priv->geo_coordinate = _tmp18_;
	}
	_tmp19_ = self->priv->geo_coordinate;
	result = _tmp19_;
	_g_variant_unref0 (location_v);
	return result;
}


static void
unity_search_metadata_class_init (UnitySearchMetadataClass * klass)
{
	unity_search_metadata_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnitySearchMetadataPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_unity_search_metadata_get_property;
	G_OBJECT_CLASS (klass)->finalize = unity_search_metadata_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SEARCH_METADATA_LOCALE_PROPERTY, unity_search_metadata_properties[UNITY_SEARCH_METADATA_LOCALE_PROPERTY] = g_param_spec_string ("locale", "locale", "locale", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SEARCH_METADATA_FORM_FACTOR_PROPERTY, unity_search_metadata_properties[UNITY_SEARCH_METADATA_FORM_FACTOR_PROPERTY] = g_param_spec_string ("form-factor", "form-factor", "form-factor", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), UNITY_SEARCH_METADATA_LOCATION_PROPERTY, unity_search_metadata_properties[UNITY_SEARCH_METADATA_LOCATION_PROPERTY] = g_param_spec_object ("location", "location", "location", UNITY_TYPE_GEO_COORDINATE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}


static void
unity_search_metadata_instance_init (UnitySearchMetadata * self)
{
	self->priv = UNITY_SEARCH_METADATA_GET_PRIVATE (self);
}


static void
unity_search_metadata_finalize (GObject * obj)
{
	UnitySearchMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_SEARCH_METADATA, UnitySearchMetadata);
	_g_hash_table_unref0 (self->priv->all_metadata);
	_g_object_unref0 (self->priv->geo_coordinate);
	G_OBJECT_CLASS (unity_search_metadata_parent_class)->finalize (obj);
}


GType
unity_search_metadata_get_type (void)
{
	static volatile gsize unity_search_metadata_type_id__volatile = 0;
	if (g_once_init_enter (&unity_search_metadata_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnitySearchMetadataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_search_metadata_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnitySearchMetadata), 0, (GInstanceInitFunc) unity_search_metadata_instance_init, NULL };
		GType unity_search_metadata_type_id;
		unity_search_metadata_type_id = g_type_register_static (G_TYPE_OBJECT, "UnitySearchMetadata", &g_define_type_info, 0);
		g_once_init_leave (&unity_search_metadata_type_id__volatile, unity_search_metadata_type_id);
	}
	return unity_search_metadata_type_id__volatile;
}


static void
_vala_unity_search_metadata_get_property (GObject * object,
                                          guint property_id,
                                          GValue * value,
                                          GParamSpec * pspec)
{
	UnitySearchMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, UNITY_TYPE_SEARCH_METADATA, UnitySearchMetadata);
	switch (property_id) {
		case UNITY_SEARCH_METADATA_LOCALE_PROPERTY:
		g_value_set_string (value, unity_search_metadata_get_locale (self));
		break;
		case UNITY_SEARCH_METADATA_FORM_FACTOR_PROPERTY:
		g_value_set_string (value, unity_search_metadata_get_form_factor (self));
		break;
		case UNITY_SEARCH_METADATA_LOCATION_PROPERTY:
		g_value_set_object (value, unity_search_metadata_get_location (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GType
unity_geo_coordinate_coordinate_type_get_type (void)
{
	static volatile gsize unity_geo_coordinate_coordinate_type_type_id__volatile = 0;
	if (g_once_init_enter (&unity_geo_coordinate_coordinate_type_type_id__volatile)) {
		static const GEnumValue values[] = {{UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_2D, "UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_2D", "coordinate-2d"}, {UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_3D, "UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_3D", "coordinate-3d"}, {0, NULL, NULL}};
		GType unity_geo_coordinate_coordinate_type_type_id;
		unity_geo_coordinate_coordinate_type_type_id = g_enum_register_static ("UnityGeoCoordinateCoordinateType", values);
		g_once_init_leave (&unity_geo_coordinate_coordinate_type_type_id__volatile, unity_geo_coordinate_coordinate_type_type_id);
	}
	return unity_geo_coordinate_coordinate_type_type_id__volatile;
}


UnityGeoCoordinate*
unity_geo_coordinate_construct (GType object_type,
                                gdouble latitude_,
                                gdouble longitude_)
{
	UnityGeoCoordinate * self = NULL;
	self = (UnityGeoCoordinate*) g_object_new (object_type, NULL);
	self->latitude = latitude_;
	self->longitude = longitude_;
	self->priv->coord_type = UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_2D;
	return self;
}


UnityGeoCoordinate*
unity_geo_coordinate_new (gdouble latitude_,
                          gdouble longitude_)
{
	return unity_geo_coordinate_construct (UNITY_TYPE_GEO_COORDINATE, latitude_, longitude_);
}


UnityGeoCoordinate*
unity_geo_coordinate_construct_with_altitude (GType object_type,
                                              gdouble latitude_,
                                              gdouble longitude_,
                                              gdouble altitude_)
{
	UnityGeoCoordinate * self = NULL;
	self = (UnityGeoCoordinate*) g_object_new (object_type, NULL);
	self->latitude = latitude_;
	self->longitude = longitude_;
	self->altitude = altitude_;
	self->priv->coord_type = UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_3D;
	return self;
}


UnityGeoCoordinate*
unity_geo_coordinate_new_with_altitude (gdouble latitude_,
                                        gdouble longitude_,
                                        gdouble altitude_)
{
	return unity_geo_coordinate_construct_with_altitude (UNITY_TYPE_GEO_COORDINATE, latitude_, longitude_, altitude_);
}


gboolean
unity_geo_coordinate_has_valid_altitude (UnityGeoCoordinate* self)
{
	gboolean result = FALSE;
	UnityGeoCoordinateCoordinateType _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->coord_type;
	result = _tmp0_ == UNITY_GEO_COORDINATE_COORDINATE_TYPE_COORDINATE_3D;
	return result;
}


static void
unity_geo_coordinate_class_init (UnityGeoCoordinateClass * klass)
{
	unity_geo_coordinate_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UnityGeoCoordinatePrivate));
	G_OBJECT_CLASS (klass)->finalize = unity_geo_coordinate_finalize;
}


static void
unity_geo_coordinate_instance_init (UnityGeoCoordinate * self)
{
	self->priv = UNITY_GEO_COORDINATE_GET_PRIVATE (self);
}


static void
unity_geo_coordinate_finalize (GObject * obj)
{
	UnityGeoCoordinate * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UNITY_TYPE_GEO_COORDINATE, UnityGeoCoordinate);
	G_OBJECT_CLASS (unity_geo_coordinate_parent_class)->finalize (obj);
}


GType
unity_geo_coordinate_get_type (void)
{
	static volatile gsize unity_geo_coordinate_type_id__volatile = 0;
	if (g_once_init_enter (&unity_geo_coordinate_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityGeoCoordinateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_geo_coordinate_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityGeoCoordinate), 0, (GInstanceInitFunc) unity_geo_coordinate_instance_init, NULL };
		GType unity_geo_coordinate_type_id;
		unity_geo_coordinate_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityGeoCoordinate", &g_define_type_info, 0);
		g_once_init_leave (&unity_geo_coordinate_type_id__volatile, unity_geo_coordinate_type_id);
	}
	return unity_geo_coordinate_type_id__volatile;
}


/**
   * Create a new SearchContext
   *
   * This method will create a new heap-allocated SearchContext.
   * It is primarily meant for low-level language bindings, to ensure correct
   * memory management of the individual fields in the struct.
   */
UnitySearchContext*
unity_search_context_create (const gchar* search_query,
                             UnitySearchType search_type,
                             UnityFilterSet* filter_state,
                             GHashTable* metadata,
                             UnityResultSet* result_set,
                             UnityCancellable* cancellable)
{
	UnitySearchContext* result = NULL;
	UnitySearchContext* ctx = NULL;
	UnitySearchContext _tmp0_ = {0};
	UnitySearchContext _tmp1_;
	UnitySearchContext* _tmp2_;
	UnitySearchContext* _tmp3_;
	gchar* _tmp4_;
	UnityFilterSet* _tmp5_;
	UnitySearchMetadata* _tmp6_;
	UnityResultSet* _tmp7_;
	UnityCancellable* _tmp8_;
	g_return_val_if_fail (search_query != NULL, NULL);
	g_return_val_if_fail (result_set != NULL, NULL);
	memset (&_tmp0_, 0, sizeof (UnitySearchContext));
	_tmp1_ = _tmp0_;
	_tmp2_ = _unity_search_context_dup0 (&_tmp1_);
	_tmp3_ = _tmp2_;
	unity_search_context_destroy (&_tmp1_);
	ctx = _tmp3_;
	_tmp4_ = g_strdup (search_query);
	_g_free0 ((*ctx).search_query);
	(*ctx).search_query = _tmp4_;
	(*ctx).search_type = search_type;
	_tmp5_ = _g_object_ref0 (filter_state);
	_g_object_unref0 ((*ctx).filter_state);
	(*ctx).filter_state = _tmp5_;
	_tmp6_ = unity_search_metadata_create (metadata);
	_g_object_unref0 ((*ctx).search_metadata);
	(*ctx).search_metadata = _tmp6_;
	_tmp7_ = _g_object_ref0 (result_set);
	_g_object_unref0 ((*ctx).result_set);
	(*ctx).result_set = _tmp7_;
	_tmp8_ = _g_object_ref0 (cancellable);
	_g_object_unref0 ((*ctx).cancellable);
	(*ctx).cancellable = _tmp8_;
	result = ctx;
	return result;
}


/**
   * Set search_metadata
   *
   * This method will create a new heap-allocated SearchContext.
   * It is primarily meant for low-level language bindings, to ensure correct
   * memory management of the individual fields in the struct.
   */
void
unity_search_context_set_search_metadata (UnitySearchContext *self,
                                          UnitySearchMetadata* metadata)
{
	UnitySearchMetadata* _tmp0_;
	g_return_if_fail (metadata != NULL);
	_tmp0_ = _g_object_ref0 (metadata);
	_g_object_unref0 ((*self).search_metadata);
	(*self).search_metadata = _tmp0_;
}


void
unity_search_context_copy (const UnitySearchContext* self,
                           UnitySearchContext* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	UnitySearchType _tmp2_;
	UnityFilterSet* _tmp3_;
	UnityFilterSet* _tmp4_;
	UnitySearchMetadata* _tmp5_;
	UnitySearchMetadata* _tmp6_;
	UnityResultSet* _tmp7_;
	UnityResultSet* _tmp8_;
	UnityCancellable* _tmp9_;
	UnityCancellable* _tmp10_;
	_tmp0_ = (*self).search_query;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).search_query);
	(*dest).search_query = _tmp1_;
	_tmp2_ = (*self).search_type;
	(*dest).search_type = _tmp2_;
	_tmp3_ = (*self).filter_state;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	_g_object_unref0 ((*dest).filter_state);
	(*dest).filter_state = _tmp4_;
	_tmp5_ = (*self).search_metadata;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	_g_object_unref0 ((*dest).search_metadata);
	(*dest).search_metadata = _tmp6_;
	_tmp7_ = (*self).result_set;
	_tmp8_ = _g_object_ref0 (_tmp7_);
	_g_object_unref0 ((*dest).result_set);
	(*dest).result_set = _tmp8_;
	_tmp9_ = (*self).cancellable;
	_tmp10_ = _g_object_ref0 (_tmp9_);
	_g_object_unref0 ((*dest).cancellable);
	(*dest).cancellable = _tmp10_;
}


void
unity_search_context_destroy (UnitySearchContext* self)
{
	_g_free0 ((*self).search_query);
	_g_object_unref0 ((*self).filter_state);
	_g_object_unref0 ((*self).search_metadata);
	_g_object_unref0 ((*self).result_set);
	_g_object_unref0 ((*self).cancellable);
}


UnitySearchContext*
unity_search_context_dup (const UnitySearchContext* self)
{
	UnitySearchContext* dup;
	dup = g_new0 (UnitySearchContext, 1);
	unity_search_context_copy (self, dup);
	return dup;
}


void
unity_search_context_free (UnitySearchContext* self)
{
	unity_search_context_destroy (self);
	g_free (self);
}


GType
unity_search_context_get_type (void)
{
	static volatile gsize unity_search_context_type_id__volatile = 0;
	if (g_once_init_enter (&unity_search_context_type_id__volatile)) {
		GType unity_search_context_type_id;
		unity_search_context_type_id = g_boxed_type_register_static ("UnitySearchContext", (GBoxedCopyFunc) unity_search_context_dup, (GBoxedFreeFunc) unity_search_context_free);
		g_once_init_leave (&unity_search_context_type_id__volatile, unity_search_context_type_id);
	}
	return unity_search_context_type_id__volatile;
}


static UnityScopeSearchBase*
unity_abstract_scope_real_create_search_for_query (UnityAbstractScope* self,
                                                   UnitySearchContext* search_context)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_create_search_for_query'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


UnityScopeSearchBase*
unity_abstract_scope_create_search_for_query (UnityAbstractScope* self,
                                              UnitySearchContext* search_context)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->create_search_for_query (self, search_context);
}


static UnityResultPreviewer*
unity_abstract_scope_real_create_previewer (UnityAbstractScope* self,
                                            UnityScopeResult* _result_,
                                            UnitySearchMetadata* metadata)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_create_previewer'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


UnityResultPreviewer*
unity_abstract_scope_create_previewer (UnityAbstractScope* self,
                                       UnityScopeResult* _result_,
                                       UnitySearchMetadata* metadata)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->create_previewer (self, _result_, metadata);
}


static UnityCategorySet*
unity_abstract_scope_real_get_categories (UnityAbstractScope* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_get_categories'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


UnityCategorySet*
unity_abstract_scope_get_categories (UnityAbstractScope* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->get_categories (self);
}


static UnityFilterSet*
unity_abstract_scope_real_get_filters (UnityAbstractScope* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_get_filters'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


UnityFilterSet*
unity_abstract_scope_get_filters (UnityAbstractScope* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->get_filters (self);
}


static UnitySchema*
unity_abstract_scope_real_get_schema (UnityAbstractScope* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_get_schema'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


UnitySchema*
unity_abstract_scope_get_schema (UnityAbstractScope* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->get_schema (self);
}


/**
   * Getter for the search hint
   *
   * Search hint is usually displayed in a text entry widget when the search
   * string is empty.
   */
static gchar*
unity_abstract_scope_real_get_search_hint (UnityAbstractScope* self)
{
	gchar* result = NULL;
	gchar* _tmp0_;
	_tmp0_ = g_strdup ("");
	result = _tmp0_;
	return result;
}


gchar*
unity_abstract_scope_get_search_hint (UnityAbstractScope* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->get_search_hint (self);
}


/**
   * Get scope group name
   *
   * Each scope should provide a group name that's specific to the scope.
   * The name should be in the format similar to "com.example.Scope.ScopeName".
   */
static gchar*
unity_abstract_scope_real_get_group_name (UnityAbstractScope* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_get_group_name'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


gchar*
unity_abstract_scope_get_group_name (UnityAbstractScope* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->get_group_name (self);
}


/**
   * Get the unique name of the scope
   *
   * Each scope needs to provide a unique name that identifies the scope.
   * The name should be in the format of "/com/example/Scope/ScopeName".
   * Note that the combination of scope group name and unique name needs to
   * be globally unique for each scope.
   */
static gchar*
unity_abstract_scope_real_get_unique_name (UnityAbstractScope* self)
{
	g_critical ("Type `%s' does not implement abstract method `unity_abstract_scope_get_unique_name'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


gchar*
unity_abstract_scope_get_unique_name (UnityAbstractScope* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->get_unique_name (self);
}


static UnityActivationResponse*
unity_abstract_scope_real_activate (UnityAbstractScope* self,
                                    UnityScopeResult* _result_,
                                    UnitySearchMetadata* metadata,
                                    const gchar* action_id)
{
	UnityActivationResponse* result = NULL;
	g_return_val_if_fail (_result_ != NULL, NULL);
	g_return_val_if_fail (metadata != NULL, NULL);
	result = NULL;
	return result;
}


UnityActivationResponse*
unity_abstract_scope_activate (UnityAbstractScope* self,
                               UnityScopeResult* _result_,
                               UnitySearchMetadata* metadata,
                               const gchar* action_id)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->activate (self, _result_, metadata, action_id);
}


/**
   * Virtual method to normalize the search string
   *
   * Scope can override this method to specify custom normalization
   * of the search query. Normalized search query is usually stripped
   * of whitespace and lowercased.
   * The default implementation doesn't modify the search string in any way.
   */
static gchar*
unity_abstract_scope_real_normalize_search_query (UnityAbstractScope* self,
                                                  const gchar* search_query)
{
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (search_query != NULL, NULL);
	_tmp0_ = g_strdup (search_query);
	result = _tmp0_;
	return result;
}


gchar*
unity_abstract_scope_normalize_search_query (UnityAbstractScope* self,
                                             const gchar* search_query)
{
	g_return_val_if_fail (self != NULL, NULL);
	return UNITY_ABSTRACT_SCOPE_GET_CLASS (self)->normalize_search_query (self, search_query);
}


/**
   * Invalidate previously sent results.
   *
   * If a scope knows that results it has sent out previously are no
   * longer valid, it can call this function to notify any interested
   * parties that they may want to perform a new search.
   */
void
unity_abstract_scope_results_invalidated (UnityAbstractScope* self,
                                          UnitySearchType search_type)
{
	g_return_if_fail (self != NULL);
	_vala_return_if_fail (search_type < UNITY_SEARCH_TYPE_N_TYPES, "search_type < SearchType.N_TYPES");
	g_signal_emit (self, unity_abstract_scope_signals[UNITY_ABSTRACT_SCOPE_RESULTS_INVALIDATED_INTERNAL_SIGNAL], 0, search_type);
}


UnityAbstractScope*
unity_abstract_scope_construct (GType object_type)
{
	UnityAbstractScope * self = NULL;
	self = (UnityAbstractScope*) g_object_new (object_type, NULL);
	return self;
}


static void
unity_abstract_scope_class_init (UnityAbstractScopeClass * klass)
{
	unity_abstract_scope_parent_class = g_type_class_peek_parent (klass);
	((UnityAbstractScopeClass *) klass)->create_search_for_query = (UnityScopeSearchBase* (*) (UnityAbstractScope *, UnitySearchContext*)) unity_abstract_scope_real_create_search_for_query;
	((UnityAbstractScopeClass *) klass)->create_previewer = (UnityResultPreviewer* (*) (UnityAbstractScope *, UnityScopeResult*, UnitySearchMetadata*)) unity_abstract_scope_real_create_previewer;
	((UnityAbstractScopeClass *) klass)->get_categories = (UnityCategorySet* (*) (UnityAbstractScope *)) unity_abstract_scope_real_get_categories;
	((UnityAbstractScopeClass *) klass)->get_filters = (UnityFilterSet* (*) (UnityAbstractScope *)) unity_abstract_scope_real_get_filters;
	((UnityAbstractScopeClass *) klass)->get_schema = (UnitySchema* (*) (UnityAbstractScope *)) unity_abstract_scope_real_get_schema;
	((UnityAbstractScopeClass *) klass)->get_search_hint = (gchar* (*) (UnityAbstractScope *)) unity_abstract_scope_real_get_search_hint;
	((UnityAbstractScopeClass *) klass)->get_group_name = (gchar* (*) (UnityAbstractScope *)) unity_abstract_scope_real_get_group_name;
	((UnityAbstractScopeClass *) klass)->get_unique_name = (gchar* (*) (UnityAbstractScope *)) unity_abstract_scope_real_get_unique_name;
	((UnityAbstractScopeClass *) klass)->activate = (UnityActivationResponse* (*) (UnityAbstractScope *, UnityScopeResult*, UnitySearchMetadata*, const gchar*)) unity_abstract_scope_real_activate;
	((UnityAbstractScopeClass *) klass)->normalize_search_query = (gchar* (*) (UnityAbstractScope *, const gchar*)) unity_abstract_scope_real_normalize_search_query;
	unity_abstract_scope_signals[UNITY_ABSTRACT_SCOPE_RESULTS_INVALIDATED_INTERNAL_SIGNAL] = g_signal_new ("results-invalidated-internal", UNITY_TYPE_ABSTRACT_SCOPE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__ENUM, G_TYPE_NONE, 1, UNITY_TYPE_SEARCH_TYPE);
}


static void
unity_abstract_scope_instance_init (UnityAbstractScope * self)
{
}


GType
unity_abstract_scope_get_type (void)
{
	static volatile gsize unity_abstract_scope_type_id__volatile = 0;
	if (g_once_init_enter (&unity_abstract_scope_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnityAbstractScopeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_abstract_scope_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityAbstractScope), 0, (GInstanceInitFunc) unity_abstract_scope_instance_init, NULL };
		GType unity_abstract_scope_type_id;
		unity_abstract_scope_type_id = g_type_register_static (G_TYPE_OBJECT, "UnityAbstractScope", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&unity_abstract_scope_type_id__volatile, unity_abstract_scope_type_id);
	}
	return unity_abstract_scope_type_id__volatile;
}



